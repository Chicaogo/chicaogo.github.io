{"meta":{"title":"Chicago_01","subtitle":null,"description":null,"author":"Chicago_01","url":"http://chicago01.top","root":"/"},"pages":[{"title":"about","date":"2019-01-26T08:13:09.000Z","updated":"2019-06-16T23:36:58.463Z","comments":true,"path":"about/index.html","permalink":"http://chicago01.top/about/index.html","excerpt":"","text":"站长：Chicago_01(Chicago) 河南师大附中在校学生 河南省OIer(半退役)。 年龄：17+ 联系方式 QQ: 2832853025 Email: Chicago01wa@gmail.com 技能底层编程语言 C/C++ Python 语言能力 中文 China 英语(弱) English 长期目标 NOIP一等奖 深圳大学/华南理工大学/华东理工大学/郑州大学 ACM区域赛金奖 考研 THU/ZJU 爱好 前端开发 算法 羽毛球（业余）"},{"title":"Some Life","date":"2019-06-06T04:13:09.000Z","updated":"2019-06-06T05:12:54.309Z","comments":true,"path":"some/index.html","permalink":"http://chicago01.top/some/index.html","excerpt":"","text":"每一个不曾起舞的日子，都是对生命的辜负。——尼采 蒹葭苍苍，白露为霜。所谓伊人，在水一方。——诗经 如果你独自一人笑了，那是真心的笑。 ——安迪·鲁尼 她可以褪色，可以枯萎，怎样都可以，但我只要看她一眼，万般柔情，涌上心头。 No matter what the ending will be, I feel so grateful that we can meet. 我年华虚度，空有一身疲倦。——海子《以梦为马》 生活不能等待别人来安排，要自己去争取和奋斗；而不论其结果是喜是悲，但可以慰藉的是，你总不枉在这世界上活了一场。有了这样的认识，你就会珍重生活，而不会玩世不恭；同时，也会给人自身注入一种强大的内在力量。——《平凡的世界》 我还有改变的可能性。一想起这一点，我就心潮澎湃。(by 北野武) $Mg + ZnCl_2 = Zn + MgCl_2$"},{"title":"My dream way","date":"2019-06-08T15:20:09.000Z","updated":"2019-06-17T23:46:23.161Z","comments":true,"path":"dream/index.html","permalink":"http://chicago01.top/dream/index.html","excerpt":"","text":"每一个不曾起舞的日子，都是对生命的辜负。——尼采为了自己，为了我爱的人，为了爱我的人，奋斗。 置顶：2019年6月8日现在是2019年6月8日，这个专栏不定期更新，用来记录我的高三生活。 倒叙更新!!! 2019年6月18日物理 三角函数解析法 三力呈垂直，等腰等特殊角 动态三角形法 定不变 平移 转动 相似三角形法 顺着力的方向延长出现相似三角形 正交分解法 希望你明白，我凡事都看得开，但并不影响我记仇。 2019年6月18日被老师谈话，一天沉沉闷闷，好似什么也没干。 2019年6月16日 2019年6月15日物理传送带模型 2019年6月14日 命运是不可改变的，可改变的是我们对命运的态度。 ——周国平 数学 表示 $\\vec a - \\vec b = \\vec a + (- \\vec b)$ 运算 相加 数乘 两个乘法结合律 共线判定定理 向量证明三点共线 向量基本定理 坐标表示 相加 数乘 共线 重心 向量解题 向量问题坐标化（数形结合的思想） 建立平面直角坐标系 由题目得点坐标 数量运算-》垂直，共线 巧用方程思想求坐标 加法，减法，数乘，瞎胡搞 垂直，平行 不知道 平面向量数量积 $\\vec a * \\vec b = |\\vec a||\\vec b|\\cos \\theta = x_1x_2+y_1y_2$ $\\vec a * \\vec a = |\\vec a|^2​$ $\\vec a ⊥ \\vec b = \\vec a * \\vec b = 0​$ 四心 重心的性质： 1、重心到顶点的距离与重心到对边中点的距离之比为2︰1。 2、重心和三角形任意两个顶点组成的3个三角形面积相等。即重心到三条边的距离与三条边的长成反比。 3、重心到三角形3个顶点距离的平方和最小。 4、在平面直角坐标系中，重心的坐标是顶点坐标的算术平均数，即其重心坐标为 ​ 5、以重心为起点，以三角形三顶点为终点的三条向量之和等于零向量。 外心的性质：三角形外接圆的圆心，叫做三角形的外心。： 1、三角形的三条边的垂直平分线交于一点，该点即为该三角形的外心。 2、若O是△ABC的外心，则∠BOC=2∠A（∠A为锐角或直角）或∠BOC=360°-2∠A（∠A为钝角）。 3、当三角形为锐角三角形时，外心在三角形内部；当三角形为钝角三角形时，外心在三角形外部；当三角形为直角三角形时，外心在斜边上，与斜边的中点重合。 4、外心到三顶点的距离相等 垂心的性质：三角形的三条高（所在直线）交于一点，该点叫做三角形的垂心。 1、三角形三个顶点，三个垂足，垂心这7个点可以得到6个四点圆。 2、三角形外心O、重心G和垂心H三点共线，且OG︰GH=1︰2。（此直线称为三角形的欧拉线（Euler line））（除正三角形） 3、垂心到三角形一顶点距离为此三角形外心到此顶点对边距离的2倍。 4、垂心分每条高线的两部分乘积相等。 内心的性质：三角形内切圆的圆心，叫做三角形的内心。 1、三角形的三条内角平分线交于一点。该点即为三角形的内心。 2、直角三角形的内心到边的距离等于两直角边的和与斜边的差的二分之一。 3、P为ΔABC所在空间中任意一点，点0是ΔABC内心的充要条件是：向量P0=(a×向量PA+b×向量PB+c×向量PC)/(a+b+c). 4、O为三角形的内心，A、B、C分别为三角形的三个顶点，延长AO交BC边于N，则有AO:ON=AB:BN=AC:CN=(AB+AC):BC 5、(欧拉定理)⊿ABC中，R和r分别为外接圆为和内切圆的半径，O和I分别为其外心和内心，则OI^2=R^2-2Rr． 6、（内角平分线分三边长度关系） △ABC中，0为内心，∠A 、∠B、 ∠C的内角平分线分别交BC、AC、AB于Q、P、R， 则BQ/QC=c/b, CP/PA=a/c, BR/RA=a/b. 7、内心到三角形三边距离相等。 2019年6月13日 青霄有路终须到 金榜无名誓不归 待到相偕看花时 不负如来不负卿 数学 复数几何意义？几何意义 超越函数的解法 找周期 奇偶性 单调性 由题目已知条件求解 $log_27 = 2 + log_2\\frac{7}{4}$ 函数图像解法 奇偶，对称 零点 特殊点 求导 直线 $k = tanα = \\frac{y_1-y_2}{x_1-x_2}$ 点斜：$y-y_0 = k(x-x_0)$ 斜截：$y = kx+b$ 两点：$\\frac{y-y_1}{y_2-y_1} = \\frac{x-x_1}{x_2-x_1}$ 两直线位置关系 $k_1=k_2$ $k_1 ≠ k_2$ $k_1*k_2 = -1$ 距离 $A(x_1,y_1),B(x_2,y_2)$ 两点间距离公式: $|AB| = \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$ $P(x_1,y_1)​$到直线$Ax+By+C = 0​$的距离公式：$d = \\frac{|Ax_1+By_1+C|}{\\sqrt{A^2+B^2}}​$ 两条平行线之间的距离$l_1:Ax+By+C_1 = 0$,$l_2:Ax+By+C_2=0$,$d=\\frac{|C_1-C_2|}{\\sqrt{A^2+b^2}}$ 数形结合的思想 由数据推出图像，图像确定相关关系，联系方程 直线关于点对称 点关于直线对称 直线关于直线对称 生物 光合作用 2019年6月12日数学 过切点，已知$k$，求参数 设切点$(x_0,0)$ 代入求导后参数方程 = $k$ 代入原函数方程，过所设切点 关于原点对称的函数 =》 奇函数 分段函数单调恒成立问题 所有的段在区间内单调成立 分段的连接点左右两侧单调成立 $f(x+2)$的函数图像关于直线$x = -2$对称 =》 偶函数 物理 牛一定律是严谨的科学实验得到的 牛二定律得出$a$是与$F$和$m$有关的，与速度和时间无关 力改变物体运动状态，而不是维持物体运动状态 相互作用力与平衡力 相互作用力：两个物体之间的相互作用 平衡力：作用于同一点 牛二定律的应用 两类问题 由力找运动 由运动找力（知三求二） 超重和失重 a的方向辨别超重还是失重 a的瞬时性 动态平衡力受力分析（图解法） 受力分析画出矢量三角形 定∠改变 边长长度变化确定力的变化 整体法和隔离法 A：歪，呢么努力学习干嘛？ B：为了她妈妈放心把优秀的她嫁给我啊！ 化学 碳 $2C + SiO_2 = Si + CO↑$ $C + H_2O(g) = CO + H_2$ 工业制硅 粗硅：$SiO_2+2C = Si + 2CO↑$ $Si + 2Cl_2 = SiCl_4$ $SiCl_4 + H_2 = Si + 4HCl​$ 二氧化碳$CO_2$ $CO_2 + H_2O = H_2CO_3​$ 和酸不反应 $CO_2$少量：$2NaOH + CO_2 = Na_2CO_3 + H_2O$ $CO_2​$大量：$NaOH+CO_2 = NaHCO_3​$ 二氧化硅$SiO_2​$ $Na_2SiO_3 + CO_2 + H_2O = Na_2CO_3 + H_2SO_4$ $SiO_2+HF = SiF_4↑ + 2H_2O$ $SiO_2 + 2NaOH = Na_2SiO_3 + H_2O​$ $NaCO_3 + SiO_2 = Na_2SiO_3 + CO_2↑​$ 高沸点制低沸点 $Na_2CO_3+SiO_2=Na_2SiO_3+CO_2↑$ $Al_2O_3+Na_2CO_3 = 2NaAlO_2+CO_2↑$ 语文 梅花：坚贞不渝、高洁、坚强、谦虚 菊花：坚贞不屈、高洁情操、幽静安逸 兰花：卓尔独立、淡泊名利、追求个性自由 竹子：刚直、谦逊，不亢不卑，潇洒处世 李白 李白一生都怀有远大的抱负，他毫不掩饰地表达对功名事业的向往；但他的政治理想和黑暗的现实，发生了尖锐的矛盾，胸中淤积了难以言状的痛苦和愤懑。所以愤而辞官，以表达出他那种酷爱自由、渴望解放的情怀，把一身傲骨展露无遗。 李白作为一个热爱祖国、关怀人民、不忘现实的伟大诗人，也十分关心战争这一重要问题。 杜甫 杜甫心怀天下，忧国忧民，心系苍生，胸怀国事。 杜甫的诗具有丰富的社会内容、强烈的时代色彩和鲜明的政治倾向，真实深刻地反映了安史之乱前后一个历史时代政治时事和广阔的社会生活画面，因而被称为一代“诗史”。 苏轼 一个浪漫的诗人，一个豪放的词家，一个超脱的文人，一个潇洒的人间过客，一个最具人格魅力的人生大师。 淡泊，看淡名利，会写会做饭，会享受生活。抗击打能力强，即便是被贬到海边等偏僻处，也不怨天尤人，而是奋发干事创业，至今百姓称赞。 杜牧 出身名门望族，为中唐宰相、史学家杜佑之孙。大和二年（公元828年）进士，初为弘文馆校书郎，因秉性刚直，遭人排挤，后历任淮南节度推官，监察御史，黄、池、睦诸州刺史，晚年任司勋员外郎、史馆修撰，官终中书舍人。 杜牧生于晚唐多事之秋，早年以济世之才自负，甚想有所作为，曾作《阿房宫赋》以讽喻当世。 爱国热情，散文如《罪言》《燕将录》《送薛处士序》等，或抨击藩镇跋扈，或感慨朝政昏暗，多方面反映了晚唐社会现实。 屈原 屈原是我国第一个真正的诗人，第一个浪漫主义诗歌高峰的缔造者，我国伟大的爱国诗人，世界四大诗人之一，名平，字原，战国楚人。主要诗作《离骚》、《九歌》、《九章》。之所以把他列在首位，正在于他的首创性。因此，如果说李白是诗仙，那么，屈原就是诗祖。 陶渊明 东晋著名诗人，名潜，字元亮。所作诗文多描写农村景色，以《归田园居》、《桃花源诗》为代表作。是田园诗人的鼻祖。 王维 唐朝著名山水田园诗人，字摩诘，被誉为“诗中有画，画中有诗”。受陶渊明影响较大，故列后。 陆游 南宋著名的爱国诗人，字务观，号放翁，存诗9000多首，诗风激昂豪放，有《剑南诗稿》等。大概没有比他更勤奋的诗人了。 李商隐 唐末著名诗人，字义山，以七言律诗见长，有《李义山诗集》。知道“春蚕到死丝方尽，蜡炬成灰泪始干”吗？ 白居易 唐朝大诗人，新乐府运动的倡导者，字乐天，晚年号香山居士，有《白氏长庆集》。就凭《长恨歌》和《琵琶行》这两首诗，任何一个评论家就都不能够忽视他的存在。 李煜 李煜初名从嘉，字重光，号钟隐，又号莲峰居士。南唐后主，现存词四十四首。一个本该是伟大诗人，却阴差阳错成了皇帝的可怜人。 李清照 李清照前后期作品风格迥异。宋室南渡前，李清照生活美满，作品热情活泼，明快天真，多写少女生活的无忧无虑，以及婚后的离别相思，充分表现女性闺阁的感情。宋室南渡之后，丈夫病死，又逢国家破亡，都一一映入词作之中，李清照多写颠沛流离之苦，孤独无依之悲，缠绵凄苦，而入于深沉的伤感。 李清照前期词风婉约，委婉含蓄。后期因历经国破家亡、丧夫等之痛，词风转为孤寂凄苦。作词特点为音律和谐，善于白描，刻画细腻，形象生动，比喻贴切，用典妥贴，善用叠字、叠句和对句，喜以浅白之字和寻常之语入词，浅近自然。 李清照对诗词的分界看的很严格，她在《词论》中提出“词，别是一家”之说。主张词必须尚文雅，协音律，铺叙，典重，故实。李清照将婉约词派推向了新的高峰。同时通过描写个人的苦难遭遇，反映出两宋之交整个国家、民族的历史悲剧，创造了“易安体”风格特点：以寻常语入词；格调凄婉悲怆；倜傥有丈夫气。 2019年6月11日数学： 图像交点问题 画图一定要认真 会结合对称性，周期性 特殊点特殊代入 比大小问题 卡范围 同等时等于k，然后未知数化统一形式 同类型比较 特殊值代入 做差，做商 函数图像问题 对比选项找不同 奇偶性 特殊点 极限求导 人呐，就和自己爱的人，爱自己的人，去做喜欢的事情。为了共同的未来去奋斗，拼搏。累了，有个依靠；想放弃了，爱你的人给你加油鼓气。人到中年，一起去旅行；人到晚年，相互照顾。 生物： 光合作用 不可见光色素不吸收 主要吸收红光和蓝紫光，所以叶片呈现绿色 白光下光合作用产物最多 恩格尔曼实验 -&gt; 叶绿体是光合作用场所，光合作用产生氧气"},{"title":"","date":"2019-05-22T05:34:23.800Z","updated":"2019-03-12T13:57:31.474Z","comments":true,"path":"404.html","permalink":"http://chicago01.top/404.html","excerpt":"","text":"404 .me404 { width: 1000px; height: 480px; position: absolute; top: 50%; left: 50%; margin-left: -400px; margin-top: -240px; } .st0 { fill-rule: evenodd; clip-rule: evenodd; fill: #E8EBED; } .st1 { fill: #FFFFFF; stroke: #89949B; stroke-width: 3; stroke-linecap: round; stroke-linejoin: round; stroke-miterlimit: 10; } .st2 { fill-rule: evenodd; clip-rule: evenodd; fill: #DBDFE1; } .st3 { fill: #FFFFFF; } .st4 { fill-rule: evenodd; clip-rule: evenodd; fill: #E8EBED; stroke: #89949B; stroke-width: 3; stroke-linecap: round; stroke-linejoin: round; stroke-miterlimit: 10; } .st5 { fill-rule: evenodd; clip-rule: evenodd; fill: #FFFFFF; stroke: #89949B; stroke-width: 3; stroke-linecap: round; stroke-linejoin: round; stroke-miterlimit: 10; } .st6 { fill-rule: evenodd; clip-rule: evenodd; fill: none; stroke: #89949B; stroke-width: 3; stroke-linecap: round; stroke-linejoin: round; stroke-miterlimit: 10; } .st7 { fill-rule: evenodd; clip-rule: evenodd; fill: none; stroke: #89949B; stroke-width: 4; stroke-linecap: round; stroke-linejoin: round; stroke-miterlimit: 10; } .st8 { fill-rule: evenodd; clip-rule: evenodd; fill: #FFFFFF; stroke: #89949B; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; stroke-miterlimit: 10; } .st9 { fill: #89949B; } .st10 { fill-rule: evenodd; clip-rule: evenodd; fill: #89949B; } .st11 { fill-rule: evenodd; clip-rule: evenodd; fill: none; stroke: #89949B; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; stroke-miterlimit: 10; } .st12 { fill-rule: evenodd; clip-rule: evenodd; fill: #FFFFFF; } .st13 { fill-rule: evenodd; clip-rule: evenodd; fill: #FFFFFF; stroke: #8894A0; stroke-width: 3; stroke-linecap: round; stroke-linejoin: round; stroke-miterlimit: 10; } .st14 { fill-rule: evenodd; clip-rule: evenodd; fill: none; stroke: #89949B; stroke-linecap: round; stroke-linejoin: round; stroke-miterlimit: 10; } .st15 { fill: none; stroke: #89949B; stroke-linecap: round; stroke-linejoin: round; stroke-miterlimit: 10; } #cloud { -webkit-animation: cloud 9s infinite ease-in-out; -moz-animation: cloud 9s infinite ease-in-out; -o-animation: cloud 9s infinite ease-in-out; animation: cloud 9s infinite ease-in-out; } lesshat-selector { -lh-property: 0; } @-webkit-keyframes cloud { 0% { opacity: 0.3; left: 160px; -webkit-transform: skewX(20deg); } 65% { opacity: 1; left: 114px; -webkit-transform: skewX(0deg); } 100% { opacity: 0.3; left: 160px; -webkit-transform: skewX(20deg); } } @-moz-keyframes cloud { 0% { opacity: 0.3; left: 160px; -moz-transform: skewX(20deg); } 65% { opacity: 1; left: 114px; -moz-transform: skewX(0deg); } 100% { opacity: 0.3; left: 160px; -moz-transform: skewX(20deg); } } @-o-keyframes cloud { 0% { opacity: 0.3; left: 160px; -o-transform: skewX(20deg); } 65% { opacity: 1; left: 114px; -o-transform: skewX(0deg); } 100% { opacity: 0.3; left: 160px; -o-transform: skewX(20deg); } } @keyframes cloud { 0% { opacity: 0.3; left: 160px; -webkit-transform: skewX(20deg); -moz-transform: skewX(20deg); -ms-transform: skewX(20deg); transform: skewX(20deg); } 65% { opacity: 1; left: 114px; -webkit-transform: skewX(0deg); -moz-transform: skewX(0deg); -ms-transform: skewX(0deg); transform: skewX(0deg); } 100% { opacity: 0.3; left: 160px; -webkit-transform: skewX(20deg); -moz-transform: skewX(20deg); -ms-transform: skewX(20deg); transform: skewX(20deg); } } [not-existing] { zoom: 1; } #moon { transform-origin: 640px 81px; -webkit-animation: moon-float 6s infinite ease-in-out; -moz-animation: moon-float 6s infinite ease-in-out; -o-animation: moon-float 6s infinite ease-in-out; animation: moon-float 6s infinite ease-in-out; } lesshat-selector { -lh-property: 0; } @-webkit-keyframes moon-float { 0% { -webkit-transform: translate(0, 20px) scale(1.1); } 65% { -webkit-transform: translate(0, 0px) scale(1.0); } 100% { -webkit-transform: translate(0, 20px) scale(1.1); } } @-moz-keyframes moon-float { 0% { -moz-transform: translate(0, 20px) scale(1.1); } 65% { -moz-transform: translate(0, 0px) scale(1.0); } 100% { -moz-transform: translate(0, 20px) scale(1.1); } } @-o-keyframes moon-float { 0% { -o-transform: translate(0, 20px) scale(1.1); } 65% { -o-transform: translate(0, 0px) scale(1.0); } 100% { -o-transform: translate(0, 20px) scale(1.1); } } @keyframes moon-float { 0% { -webkit-transform: translate(0, 20px) scale(1.1); -moz-transform: translate(0, 20px) scale(1.1); -ms-transform: translate(0, 20px) scale(1.1); transform: translate(0, 20px) scale(1.1); } 65% { -webkit-transform: translate(0, 0px) scale(1.0); -moz-transform: translate(0, 0px) scale(1.0); -ms-transform: translate(0, 0px) scale(1.0); transform: translate(0, 0px) scale(1.0); } 100% { -webkit-transform: translate(0, 20px) scale(1.1); -moz-transform: translate(0, 20px) scale(1.1); -ms-transform: translate(0, 20px) scale(1.1); transform: translate(0, 20px) scale(1.1); } } [not-existing] { zoom: 1; } #monkey-eye-l { transform-origin: 191px 257px; -webkit-animation: blink-l 12s infinite ease-in-out; -moz-animation: blink-l 12s infinite ease-in-out; -o-animation: blink-l 12s infinite ease-in-out; animation: blink-l 12s infinite ease-in-out; } #monkey-eye-r { transform-origin: 205px 256px; -webkit-animation: blink-r 12s infinite ease-in-out; -moz-animation: blink-r 12s infinite ease-in-out; -o-animation: blink-r 12s infinite ease-in-out; animation: blink-r 12s infinite ease-in-out; } #monkey-arm { transform-origin: 155px 298px; -webkit-animation: monkey-arm 4s infinite ease-in-out; -moz-animation: monkey-arm 4s infinite ease-in-out; -o-animation: monkey-arm 4s infinite ease-in-out; animation: monkey-arm 4s infinite ease-in-out; } lesshat-selector { -lh-property: 0; } @-webkit-keyframes monkey-arm { 0% { -webkit-transform: rotateZ(-10deg); } 50% { -webkit-transform: rotateZ(20deg); } 100% { -webkit-transform: rotateZ(-10deg); } } @-moz-keyframes monkey-arm { 0% { -moz-transform: rotateZ(-10deg); } 50% { -moz-transform: rotateZ(20deg); } 100% { -moz-transform: rotateZ(-10deg); } } @-o-keyframes monkey-arm { 0% { -o-transform: rotateZ(-10deg); } 50% { -o-transform: rotateZ(20deg); } 100% { -o-transform: rotateZ(-10deg); } } @keyframes monkey-arm { 0% { -webkit-transform: rotateZ(-10deg); -moz-transform: rotateZ(-10deg); -ms-transform: rotateZ(-10deg); transform: rotateZ(-10deg); } 50% { -webkit-transform: rotateZ(20deg); -moz-transform: rotateZ(20deg); -ms-transform: rotateZ(20deg); transform: rotateZ(20deg); } 100% { -webkit-transform: rotateZ(-10deg); -moz-transform: rotateZ(-10deg); -ms-transform: rotateZ(-10deg); transform: rotateZ(-10deg); } } [not-existing] { zoom: 1; } lesshat-selector { -lh-property: 0; } @-webkit-keyframes blink-l { 0% { -webkit-transform: rotateX(0deg); } 2% { -webkit-transform: rotateX(80deg); } 4%, 20% { -webkit-transform: rotateX(0deg); } 22% { -webkit-transform: rotateX(80deg); } 24%, 30% { -webkit-transform: rotateX(0deg); } 32% { -webkit-transform: rotateX(80deg); } 34%, 70% { -webkit-transform: rotateX(0deg); } 72% { -webkit-transform: rotateX(80deg); } 74%, 100% { -webkit-transform: rotateX(0deg); } } @-moz-keyframes blink-l { 0% { -moz-transform: rotateX(0deg); } 2% { -moz-transform: rotateX(80deg); } 4%, 20% { -moz-transform: rotateX(0deg); } 22% { -moz-transform: rotateX(80deg); } 24%, 30% { -moz-transform: rotateX(0deg); } 32% { -moz-transform: rotateX(80deg); } 34%, 70% { -moz-transform: rotateX(0deg); } 72% { -moz-transform: rotateX(80deg); } 74%, 100% { -moz-transform: rotateX(0deg); } } @-o-keyframes blink-l { 0% { -o-transform: rotateX(0deg); } 2% { -o-transform: rotateX(80deg); } 4%, 20% { -o-transform: rotateX(0deg); } 22% { -o-transform: rotateX(80deg); } 24%, 30% { -o-transform: rotateX(0deg); } 32% { -o-transform: rotateX(80deg); } 34%, 70% { -o-transform: rotateX(0deg); } 72% { -o-transform: rotateX(80deg); } 74%, 100% { -o-transform: rotateX(0deg); } } @keyframes blink-l { 0% { -webkit-transform: rotateX(0deg); -moz-transform: rotateX(0deg); -ms-transform: rotateX(0deg); transform: rotateX(0deg); } 2% { -webkit-transform: rotateX(80deg); -moz-transform: rotateX(80deg); -ms-transform: rotateX(80deg); transform: rotateX(80deg); } 4%, 20% { -webkit-transform: rotateX(0deg); -moz-transform: rotateX(0deg); -ms-transform: rotateX(0deg); transform: rotateX(0deg); } 22% { -webkit-transform: rotateX(80deg); -moz-transform: rotateX(80deg); -ms-transform: rotateX(80deg); transform: rotateX(80deg); } 24%, 30% { -webkit-transform: rotateX(0deg); -moz-transform: rotateX(0deg); -ms-transform: rotateX(0deg); transform: rotateX(0deg); } 32% { -webkit-transform: rotateX(80deg); -moz-transform: rotateX(80deg); -ms-transform: rotateX(80deg); transform: rotateX(80deg); } 34%, 70% { -webkit-transform: rotateX(0deg); -moz-transform: rotateX(0deg); -ms-transform: rotateX(0deg); transform: rotateX(0deg); } 72% { -webkit-transform: rotateX(80deg); -moz-transform: rotateX(80deg); -ms-transform: rotateX(80deg); transform: rotateX(80deg); } 74%, 100% { -webkit-transform: rotateX(0deg); -moz-transform: rotateX(0deg); -ms-transform: rotateX(0deg); transform: rotateX(0deg); } } [not-existing] { zoom: 1; } lesshat-selector { -lh-property: 0; } @-webkit-keyframes blink-r { 0% { -webkit-transform: rotateX(0deg); } 2% { -webkit-transform: rotateX(80deg); } 4%, 30% { -webkit-transform: rotateX(0deg); } 32% { -webkit-transform: rotateX(80deg); } 34%, 50% { -webkit-transform: rotateX(0deg); } 52% { -webkit-transform: rotateX(80deg); } 54%, 100% { -webkit-transform: rotateX(0deg); } } @-moz-keyframes blink-r { 0% { -moz-transform: rotateX(0deg); } 2% { -moz-transform: rotateX(80deg); } 4%, 30% { -moz-transform: rotateX(0deg); } 32% { -moz-transform: rotateX(80deg); } 34%, 50% { -moz-transform: rotateX(0deg); } 52% { -moz-transform: rotateX(80deg); } 54%, 100% { -moz-transform: rotateX(0deg); } } @-o-keyframes blink-r { 0% { -o-transform: rotateX(0deg); } 2% { -o-transform: rotateX(80deg); } 4%, 30% { -o-transform: rotateX(0deg); } 32% { -o-transform: rotateX(80deg); } 34%, 50% { -o-transform: rotateX(0deg); } 52% { -o-transform: rotateX(80deg); } 54%, 100% { -o-transform: rotateX(0deg); } } @keyframes blink-r { 0% { -webkit-transform: rotateX(0deg); -moz-transform: rotateX(0deg); -ms-transform: rotateX(0deg); transform: rotateX(0deg); } 2% { -webkit-transform: rotateX(80deg); -moz-transform: rotateX(80deg); -ms-transform: rotateX(80deg); transform: rotateX(80deg); } 4%, 30% { -webkit-transform: rotateX(0deg); -moz-transform: rotateX(0deg); -ms-transform: rotateX(0deg); transform: rotateX(0deg); } 32% { -webkit-transform: rotateX(80deg); -moz-transform: rotateX(80deg); -ms-transform: rotateX(80deg); transform: rotateX(80deg); } 34%, 50% { -webkit-transform: rotateX(0deg); -moz-transform: rotateX(0deg); -ms-transform: rotateX(0deg); transform: rotateX(0deg); } 52% { -webkit-transform: rotateX(80deg); -moz-transform: rotateX(80deg); -ms-transform: rotateX(80deg); transform: rotateX(80deg); } 54%, 100% { -webkit-transform: rotateX(0deg); -moz-transform: rotateX(0deg); -ms-transform: rotateX(0deg); transform: rotateX(0deg); } } [not-existing] { zoom: 1; } #star1 { transform-origin: 643px 338px; -webkit-animation: star1 12s infinite linear, star1-fade 12s infinite ease-in-out; -moz-animation: star1 12s infinite linear, star1-fade 12s infinite ease-in-out; -o-animation: star1 12s infinite linear, star1-fade 12s infinite ease-in-out; animation: star1 12s infinite linear, star1-fade 12s infinite ease-in-out; } #star2 { transform-origin: 489px 82px; -webkit-animation: star2 12s infinite linear, star2-fade 12s infinite ease-in-out; -moz-animation: star2 12s infinite linear, star2-fade 12s infinite ease-in-out; -o-animation: star2 12s infinite linear, star2-fade 12s infinite ease-in-out; animation: star2 12s infinite linear, star2-fade 12s infinite ease-in-out; } #star3 { transform-origin: 316px 344px; -webkit-animation: star3 12s infinite linear, star3-fade 12s infinite ease-in-out; -moz-animation: star3 12s infinite linear, star3-fade 12s infinite ease-in-out; -o-animation: star3 12s infinite linear, star3-fade 12s infinite ease-in-out; animation: star3 12s infinite linear, star3-fade 12s infinite ease-in-out; } #star4 { transform-origin: 126px 182px; -webkit-animation: star4 12s infinite linear, star4-fade 12s infinite ease-in-out; -moz-animation: star4 12s infinite linear, star4-fade 12s infinite ease-in-out; -o-animation: star4 12s infinite linear, star4-fade 12s infinite ease-in-out; animation: star4 12s infinite linear, star4-fade 12s infinite ease-in-out; } lesshat-selector { -lh-property: 0; } @-webkit-keyframes star1 { 0% { -webkit-transform: scale(.5) skewX(15deg) rotateZ(0deg); } 15% { -webkit-transform: scale(1) skewX(0deg) rotateZ(360deg); } 30%, 100% { -webkit-transform: scale(.5) skewX(15deg) rotateZ(720deg); } } @-moz-keyframes star1 { 0% { -moz-transform: scale(.5) skewX(15deg) rotateZ(0deg); } 15% { -moz-transform: scale(1) skewX(0deg) rotateZ(360deg); } 30%, 100% { -moz-transform: scale(.5) skewX(15deg) rotateZ(720deg); } } @-o-keyframes star1 { 0% { -o-transform: scale(.5) skewX(15deg) rotateZ(0deg); } 15% { -o-transform: scale(1) skewX(0deg) rotateZ(360deg); } 30%, 100% { -o-transform: scale(.5) skewX(15deg) rotateZ(720deg); } } @keyframes star1 { 0% { -webkit-transform: scale(.5) skewX(15deg) rotateZ(0deg); -moz-transform: scale(.5) skewX(15deg) rotateZ(0deg); -ms-transform: scale(.5) skewX(15deg) rotateZ(0deg); transform: scale(.5) skewX(15deg) rotateZ(0deg); } 15% { -webkit-transform: scale(1) skewX(0deg) rotateZ(360deg); -moz-transform: scale(1) skewX(0deg) rotateZ(360deg); -ms-transform: scale(1) skewX(0deg) rotateZ(360deg); transform: scale(1) skewX(0deg) rotateZ(360deg); } 30%, 100% { -webkit-transform: scale(.5) skewX(15deg) rotateZ(720deg); -moz-transform: scale(.5) skewX(15deg) rotateZ(720deg); -ms-transform: scale(.5) skewX(15deg) rotateZ(720deg); transform: scale(.5) skewX(15deg) rotateZ(720deg); } } [not-existing] { zoom: 1; } lesshat-selector { -lh-property: 0; } @-webkit-keyframes star2 { 0%, 15% { -webkit-transform: scale(.5) skewX(15deg) rotateZ(0deg); } 30% { -webkit-transform: scale(1) skewX(0deg) rotateZ(360deg); } 45%, 100% { -webkit-transform: scale(.5) skewX(15deg) rotateZ(720deg); } } @-moz-keyframes star2 { 0%, 15% { -moz-transform: scale(.5) skewX(15deg) rotateZ(0deg); } 30% { -moz-transform: scale(1) skewX(0deg) rotateZ(360deg); } 45%, 100% { -moz-transform: scale(.5) skewX(15deg) rotateZ(720deg); } } @-o-keyframes star2 { 0%, 15% { -o-transform: scale(.5) skewX(15deg) rotateZ(0deg); } 30% { -o-transform: scale(1) skewX(0deg) rotateZ(360deg); } 45%, 100% { -o-transform: scale(.5) skewX(15deg) rotateZ(720deg); } } @keyframes star2 { 0%, 15% { -webkit-transform: scale(.5) skewX(15deg) rotateZ(0deg); -moz-transform: scale(.5) skewX(15deg) rotateZ(0deg); -ms-transform: scale(.5) skewX(15deg) rotateZ(0deg); transform: scale(.5) skewX(15deg) rotateZ(0deg); } 30% { -webkit-transform: scale(1) skewX(0deg) rotateZ(360deg); -moz-transform: scale(1) skewX(0deg) rotateZ(360deg); -ms-transform: scale(1) skewX(0deg) rotateZ(360deg); transform: scale(1) skewX(0deg) rotateZ(360deg); } 45%, 100% { -webkit-transform: scale(.5) skewX(15deg) rotateZ(720deg); -moz-transform: scale(.5) skewX(15deg) rotateZ(720deg); -ms-transform: scale(.5) skewX(15deg) rotateZ(720deg); transform: scale(.5) skewX(15deg) rotateZ(720deg); } } [not-existing] { zoom: 1; } lesshat-selector { -lh-property: 0; } @-webkit-keyframes star3 { 0%, 30% { -webkit-transform: scale(.5) skewX(15deg) rotateZ(0deg); } 45% { -webkit-transform: scale(1) skewX(0deg) rotateZ(360deg); } 60%, 100% { -webkit-transform: scale(.5) skewX(15deg) rotateZ(720deg); } } @-moz-keyframes star3 { 0%, 30% { -moz-transform: scale(.5) skewX(15deg) rotateZ(0deg); } 45% { -moz-transform: scale(1) skewX(0deg) rotateZ(360deg); } 60%, 100% { -moz-transform: scale(.5) skewX(15deg) rotateZ(720deg); } } @-o-keyframes star3 { 0%, 30% { -o-transform: scale(.5) skewX(15deg) rotateZ(0deg); } 45% { -o-transform: scale(1) skewX(0deg) rotateZ(360deg); } 60%, 100% { -o-transform: scale(.5) skewX(15deg) rotateZ(720deg); } } @keyframes star3 { 0%, 30% { -webkit-transform: scale(.5) skewX(15deg) rotateZ(0deg); -moz-transform: scale(.5) skewX(15deg) rotateZ(0deg); -ms-transform: scale(.5) skewX(15deg) rotateZ(0deg); transform: scale(.5) skewX(15deg) rotateZ(0deg); } 45% { -webkit-transform: scale(1) skewX(0deg) rotateZ(360deg); -moz-transform: scale(1) skewX(0deg) rotateZ(360deg); -ms-transform: scale(1) skewX(0deg) rotateZ(360deg); transform: scale(1) skewX(0deg) rotateZ(360deg); } 60%, 100% { -webkit-transform: scale(.5) skewX(15deg) rotateZ(720deg); -moz-transform: scale(.5) skewX(15deg) rotateZ(720deg); -ms-transform: scale(.5) skewX(15deg) rotateZ(720deg); transform: scale(.5) skewX(15deg) rotateZ(720deg); } } [not-existing] { zoom: 1; } lesshat-selector { -lh-property: 0; } @-webkit-keyframes star4 { 0%, 45% { -webkit-transform: scale(.5) skewX(15deg) rotateZ(0deg); } 60% { -webkit-transform: scale(1) skewX(0deg) rotateZ(360deg); } 75%, 100% { -webkit-transform: scale(.5) skewX(15deg) rotateZ(720deg); } } @-moz-keyframes star4 { 0%, 45% { -moz-transform: scale(.5) skewX(15deg) rotateZ(0deg); } 60% { -moz-transform: scale(1) skewX(0deg) rotateZ(360deg); } 75%, 100% { -moz-transform: scale(.5) skewX(15deg) rotateZ(720deg); } } @-o-keyframes star4 { 0%, 45% { -o-transform: scale(.5) skewX(15deg) rotateZ(0deg); } 60% { -o-transform: scale(1) skewX(0deg) rotateZ(360deg); } 75%, 100% { -o-transform: scale(.5) skewX(15deg) rotateZ(720deg); } } @keyframes star4 { 0%, 45% { -webkit-transform: scale(.5) skewX(15deg) rotateZ(0deg); -moz-transform: scale(.5) skewX(15deg) rotateZ(0deg); -ms-transform: scale(.5) skewX(15deg) rotateZ(0deg); transform: scale(.5) skewX(15deg) rotateZ(0deg); } 60% { -webkit-transform: scale(1) skewX(0deg) rotateZ(360deg); -moz-transform: scale(1) skewX(0deg) rotateZ(360deg); -ms-transform: scale(1) skewX(0deg) rotateZ(360deg); transform: scale(1) skewX(0deg) rotateZ(360deg); } 75%, 100% { -webkit-transform: scale(.5) skewX(15deg) rotateZ(720deg); -moz-transform: scale(.5) skewX(15deg) rotateZ(720deg); -ms-transform: scale(.5) skewX(15deg) rotateZ(720deg); transform: scale(.5) skewX(15deg) rotateZ(720deg); } } [not-existing] { zoom: 1; } lesshat-selector { -lh-property: 0; } @-webkit-keyframes star1-fade { 0% { opacity: 0; } 15% { opacity: 1; } 30%, 100% { opacity: 0; } } @-moz-keyframes star1-fade { 0% { opacity: 0; } 15% { opacity: 1; } 30%, 100% { opacity: 0; } } @-o-keyframes star1-fade { 0% { opacity: 0; } 15% { opacity: 1; } 30%, 100% { opacity: 0; } } @keyframes star1-fade { 0% { opacity: 0; } 15% { opacity: 1; } 30%, 100% { opacity: 0; } } [not-existing] { zoom: 1; } lesshat-selector { -lh-property: 0; } @-webkit-keyframes star2-fade { 0%, 15% { opacity: 0; } 30% { opacity: 1; } 45%, 100% { opacity: 0; } } @-moz-keyframes star2-fade { 0%, 15% { opacity: 0; } 30% { opacity: 1; } 45%, 100% { opacity: 0; } } @-o-keyframes star2-fade { 0%, 15% { opacity: 0; } 30% { opacity: 1; } 45%, 100% { opacity: 0; } } @keyframes star2-fade { 0%, 15% { opacity: 0; } 30% { opacity: 1; } 45%, 100% { opacity: 0; } } [not-existing] { zoom: 1; } lesshat-selector { -lh-property: 0; } @-webkit-keyframes star3-fade { 0%, 30% { opacity: 0; } 45% { opacity: 1; } 60%, 100% { opacity: 0; } } @-moz-keyframes star3-fade { 0%, 30% { opacity: 0; } 45% { opacity: 1; } 60%, 100% { opacity: 0; } } @-o-keyframes star3-fade { 0%, 30% { opacity: 0; } 45% { opacity: 1; } 60%, 100% { opacity: 0; } } @keyframes star3-fade { 0%, 30% { opacity: 0; } 45% { opacity: 1; } 60%, 100% { opacity: 0; } } [not-existing] { zoom: 1; } lesshat-selector { -lh-property: 0; } @-webkit-keyframes star4-fade { 0%, 45% { opacity: 0; } 60% { opacity: 1; } 75%, 100% { opacity: 0; } } @-moz-keyframes star4-fade { 0%, 45% { opacity: 0; } 60% { opacity: 1; } 75%, 100% { opacity: 0; } } @-o-keyframes star4-fade { 0%, 45% { opacity: 0; } 60% { opacity: 1; } 75%, 100% { opacity: 0; } } @keyframes star4-fade { 0%, 45% { opacity: 0; } 60% { opacity: 1; } 75%, 100% { opacity: 0; } } [not-existing] { zoom: 1; } #sword-path { transform-origin: 458px 206px; -webkit-animation: tetris-float 3s infinite ease-in-out; -moz-animation: tetris-float 3s infinite ease-in-out; -o-animation: tetris-float 3s infinite ease-in-out; animation: tetris-float 3s infinite ease-in-out; } #sword { transform-origin: 458px 206px; -webkit-animation: sword 4s infinite ease-out; -moz-animation: sword 4s infinite ease-out; -o-animation: sword 4s infinite ease-out; animation: sword 4s infinite ease-out; } lesshat-selector { -lh-property: 0; } @-webkit-keyframes sword { 0%, 15% { -webkit-transform: rotate(-40deg); } 87% { -webkit-transform: rotate(50deg); } 100% { -webkit-transform: rotate(-40deg); } } @-moz-keyframes sword { 0%, 15% { -moz-transform: rotate(-40deg); } 87% { -moz-transform: rotate(50deg); } 100% { -moz-transform: rotate(-40deg); } } @-o-keyframes sword { 0%, 15% { -o-transform: rotate(-40deg); } 87% { -o-transform: rotate(50deg); } 100% { -o-transform: rotate(-40deg); } } @keyframes sword { 0%, 15% { -webkit-transform: rotate(-40deg); -moz-transform: rotate(-40deg); -ms-transform: rotate(-40deg); transform: rotate(-40deg); } 87% { -webkit-transform: rotate(50deg); -moz-transform: rotate(50deg); -ms-transform: rotate(50deg); transform: rotate(50deg); } 100% { -webkit-transform: rotate(-40deg); -moz-transform: rotate(-40deg); -ms-transform: rotate(-40deg); transform: rotate(-40deg); } } [not-existing] { zoom: 1; } #tetris-path { transform-origin: 538px 374px; -webkit-animation: tetris-float 5s infinite ease-in-out; -moz-animation: tetris-float 5s infinite ease-in-out; -o-animation: tetris-float 5s infinite ease-in-out; animation: tetris-float 5s infinite ease-in-out; } #tetris { transform-origin: 538px 374px; -webkit-animation: rotate 10s steps(1) infinite alternate; -moz-animation: rotate 10s steps(1) infinite alternate; -o-animation: rotate 10s steps(1) infinite alternate; animation: rotate 10s steps(1) infinite alternate; } lesshat-selector { -lh-property: 0; } @-webkit-keyframes rotate { 0% { -webkit-transform: rotateZ(0deg); } 25% { -webkit-transform: rotateZ(90deg); } 50% { -webkit-transform: rotateZ(180deg); } 75% { -webkit-transform: rotateZ(270deg); } 100% { -webkit-transform: rotateZ(360deg); } } @-moz-keyframes rotate { 0% { -moz-transform: rotateZ(0deg); } 25% { -moz-transform: rotateZ(90deg); } 50% { -moz-transform: rotateZ(180deg); } 75% { -moz-transform: rotateZ(270deg); } 100% { -moz-transform: rotateZ(360deg); } } @-o-keyframes rotate { 0% { -o-transform: rotateZ(0deg); } 25% { -o-transform: rotateZ(90deg); } 50% { -o-transform: rotateZ(180deg); } 75% { -o-transform: rotateZ(270deg); } 100% { -o-transform: rotateZ(360deg); } } @keyframes rotate { 0% { -webkit-transform: rotateZ(0deg); -moz-transform: rotateZ(0deg); -ms-transform: rotateZ(0deg); transform: rotateZ(0deg); } 25% { -webkit-transform: rotateZ(90deg); -moz-transform: rotateZ(90deg); -ms-transform: rotateZ(90deg); transform: rotateZ(90deg); } 50% { -webkit-transform: rotateZ(180deg); -moz-transform: rotateZ(180deg); -ms-transform: rotateZ(180deg); transform: rotateZ(180deg); } 75% { -webkit-transform: rotateZ(270deg); -moz-transform: rotateZ(270deg); -ms-transform: rotateZ(270deg); transform: rotateZ(270deg); } 100% { -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); -ms-transform: rotateZ(360deg); transform: rotateZ(360deg); } } [not-existing] { zoom: 1; } lesshat-selector { -lh-property: 0; } @-webkit-keyframes tetris-float { 0% { -webkit-transform: translate(0px, 0px) scale(0.90) } 65% { -webkit-transform: translate(0px, 30px) scale(1.0); } 100% { -webkit-transform: translate(0px, 0px) scale(0.90); } } @-moz-keyframes tetris-float { 0% { -moz-transform: translate(0px, 0px) scale(0.90) } 65% { -moz-transform: translate(0px, 30px) scale(1.0); } 100% { -moz-transform: translate(0px, 0px) scale(0.90); } } @-o-keyframes tetris-float { 0% { -o-transform: translate(0px, 0px) scale(0.90) } 65% { -o-transform: translate(0px, 30px) scale(1.0); } 100% { -o-transform: translate(0px, 0px) scale(0.90); } } @keyframes tetris-float { 0% { -webkit-transform: translate(0px, 0px) scale(0.90); -moz-transform: translate(0px, 0px) scale(0.90); -ms-transform: translate(0px, 0px) scale(0.90); transform: translate(0px, 0px) scale(0.90); } 65% { -webkit-transform: translate(0px, 30px) scale(1.0); -moz-transform: translate(0px, 30px) scale(1.0); -ms-transform: translate(0px, 30px) scale(1.0); transform: translate(0px, 30px) scale(1.0); } 100% { -webkit-transform: translate(0px, 0px) scale(0.90); -moz-transform: translate(0px, 0px) scale(0.90); -ms-transform: translate(0px, 0px) scale(0.90); transform: translate(0px, 0px) scale(0.90); } } [not-existing] { zoom: 1; } #triforce { transform-origin: 175px 91px; -webkit-animation: triforce-float 3s infinite ease-in-out; -moz-animation: triforce-float 3s infinite ease-in-out; -o-animation: triforce-float 3s infinite ease-in-out; animation: triforce-float 3s infinite ease-in-out; } lesshat-selector { -lh-property: 0; } @-webkit-keyframes triforce-float { 0% { -webkit-transform: translate(0px, 0px) scale(0.90) } 65% { -webkit-transform: translate(0px, 30px) scale(1.0); } 100% { -webkit-transform: translate(0px, 0px) scale(0.90); } } @-moz-keyframes triforce-float { 0% { -moz-transform: translate(0px, 0px) scale(0.90) } 65% { -moz-transform: translate(0px, 30px) scale(1.0); } 100% { -moz-transform: translate(0px, 0px) scale(0.90); } } @-o-keyframes triforce-float { 0% { -o-transform: translate(0px, 0px) scale(0.90) } 65% { -o-transform: translate(0px, 30px) scale(1.0); } 100% { -o-transform: translate(0px, 0px) scale(0.90); } } @keyframes triforce-float { 0% { -webkit-transform: translate(0px, 0px) scale(0.90); -moz-transform: translate(0px, 0px) scale(0.90); -ms-transform: translate(0px, 0px) scale(0.90); transform: translate(0px, 0px) scale(0.90); } 65% { -webkit-transform: translate(0px, 30px) scale(1.0); -moz-transform: translate(0px, 30px) scale(1.0); -ms-transform: translate(0px, 30px) scale(1.0); transform: translate(0px, 30px) scale(1.0); } 100% { -webkit-transform: translate(0px, 0px) scale(0.90); -moz-transform: translate(0px, 0px) scale(0.90); -ms-transform: translate(0px, 0px) scale(0.90); transform: translate(0px, 0px) scale(0.90); } } [not-existing] { zoom: 1; } var path = document.getElementById('tail'); path.setAttribute('d', 'M89,315c2.2-15.2-23-13.2-21.6,4.8c1.7,22.3,24.4,22.1,42.5,9.1c10.8-7.8,15.3-1.8,19.1,1.1 c2.3,1.7,6.7,3.3,11-3');"}],"posts":[{"title":"动态规划","slug":"动态规划","date":"2019-06-11T11:08:47.000Z","updated":"2019-06-13T06:21:22.874Z","comments":true,"path":"2019/06/11/动态规划/","link":"","permalink":"http://chicago01.top/2019/06/11/动态规划/","excerpt":"人生就像动态规划一样。","text":"人生就像动态规划一样。 我们老实人，先把课件传上来：点击下载 众所周知，老生常谈的，动态规划分为坐标型，线性型，区间型，背包型，树型，数位型等动态规划。呢就一个个谈谈吧。 坐标型在二维的坐标系中，规定好了方向，求最值的问题，比较容易的写出动态规划方程。 最经典的问题就是，给你 $n*m$ 的格子，每个格子上有一定的权值，从左上到右下权值和最大（最小）为多少？ 哎呦，上洛谷上正好找到一个非常不错的例题。 例题：P1508 Likecloud-吃、吃、吃题目背景问世间，青春期为何物？ 答曰：“甲亢，甲亢，再甲亢；挨饿，挨饿，再挨饿！” 题目描述正处在某一特定时期之中的李大水牛由于消化系统比较发达，最近一直处在饥饿的状态中。某日上课，正当他饿得头昏眼花之时，眼前突然闪现出了一个nm(n and m&lt;=200)的矩型的巨型大餐桌，而自己正处在这个大餐桌的一侧的中点下边。餐桌被划分为了nm个小方格，每一个方格中都有一个圆形的巨型大餐盘，上面盛满了令李大水牛朝思暮想的食物。李大水牛已将餐桌上所有的食物按其所能提供的能量打了分（有些是负的，因为吃了要拉肚子），他决定从自己所处的位置吃到餐桌的另一侧，但他吃东西有一个习惯——只吃自己前方或左前方或右前方的盘中的食物。 由于李大水牛已饿得不想动脑了，而他又想获得最大的能量，因此，他将这个问题交给了你。 每组数据的出发点都是最后一行的中间位置的下方！ 输入输出格式输入格式： [输入数据：] 第一行为m n.(n为奇数)，李大水牛一开始在最后一行的中间的下方 接下来为m*n的数字距阵. 共有m行,每行n个数字.数字间用空格隔开.代表该格子上的盘中的食物所能提供的能量. 数字全是整数. 输出格式： [输出数据：] 一个数,为你所找出的最大能量值. 输入输出样例输入样例#1： 12345676 716 4 3 12 6 0 34 -5 6 7 0 0 26 0 -1 -2 3 6 85 3 4 0 0 -2 7-1 7 4 0 7 -5 60 -1 3 4 12 4 2 输出样例#1： 141 说明快吃！快吃！快吃！ 题解这题跟数字金字塔的做法类似。。 只不过数字金字塔是往两条路线搜索，这题是往三条路线搜。。。 动态方程： $f[i][j]=max(max(f[i-1][j],f[i-1][j-1]),f[i-1][j+1])+a[i][j]$; 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int n,m,a[201][201],f[201][201]=&#123;0&#125;,x,y;int main()&#123; cin&gt;&gt;n&gt;&gt;m; y=m/2+1;x=n; memset(a,-9999,sizeof(a)); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; f[i][j]=max(max(f[i-1][j],f[i-1][j-1]),f[i-1][j+1])+a[i][j]; //动态方程 &#125; &#125; cout&lt;&lt;max(max(f[x][y],f[x][y-1]),f[x][y+1])&lt;&lt;endl; //因为最大值只可能在李大水牛的前方、左前方、右前方，所以只要找这三个的最大就行了 return 0;&#125; 引自洛谷题解。 例题：公共汽车【问题描述】一个城市的道路，南北向的路有n条，并由西向东从1标记到n,东西向的路有m条，并从南向北从1标记到m,每一个交叉点代表一个路口，有的路口有正在等车的乘客。一辆公共汽车将从(1,1)点驶到（n,m）点，车只能向东或者向北开. 问：司机怎么走能接到最多的乘客。 【输入】 第一行是n,m,和k,其中k是有乘客的路口的个数。以下k行是有乘客的路口的坐标和乘客的数量。已知每个路口的乘客数量不超过1000000。n,m&lt;=1000. 【输出】 接到的最多的乘客数。 题解 $a[i,j]$ : $ (i,j)$位置的人数， $f[i,j]​$:从（1,1）走到$（i，j）​$能接的最多人数。 $f[i,j]=max{f[i-1,j],f[i,j-1]}+a[i,j]​$ 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=1010;long a[maxn][maxn]; int main()&#123; int n,m,k,t,s,c; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); memset(a,0,sizeof(a)); for (int i=0;i&lt;k;i++) &#123; scanf(\"%d%d%d\",&amp;t,&amp;s,&amp;c); a[t][s]=c; &#125; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) a[i][j]+=max(a[i][j-1],a[i-1][j]); printf(\"%ld\",a[n][m]); return 0;&#125; 线性型 目标函数为特定变量的线性函数，约束是这些变量的线性不等式（standard form）或等式（slack form），目的是求目标函数的最大值或最小值。这类动态规划是平时比较常见的一类动态规划问题。 LIS最长上升子序列LIS (Longest Increasing Subsequence）最长上升子序列：给定n个元素的数列，求最长的上升子序列长度(LIS)。 一个数的序列$bi$，当$b1&lt;b2&lt;…&lt;bSb1&lt;b2&lt;…&lt;bS$的时候，我们称这个序列是上升的。对于给定的一个序列$(a1,a2,…,aN)$，我们可以得到一些上升的子序列$(ai1,ai2,…,aiK)$，这里$1≤i1&lt;i2&lt;…&lt;iK≤N$。 比如，对于序列$(1,7,3,5,9,4,8)$，有它的一些上升子序列，如$(1,7),(3,4,8)$等等。这些子序列中最长的长度是4，比如子序列$(1,3,5,8)$。 12345678910118 2 7 1 9 10 1 4 3 -&gt; 2 7 9 10找出以每个元素为起点的所有的上升子序列：8 9 102 7 9 107 9 101 9 109 10101 443 每个数向后面比他大的点建立有向边；求最长路（顶点数最多） 由此可以得出 ： $f[i]=max(f[j])+1 $$(i&lt;j&lt;=n$&amp;&amp;$a[i]&lt;a[j])$ 暴力法当然，我们可以考虑一些暴力搜索能不能做，毕竟暴力搜索是我们做题最后得分的法宝。 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int n,ANS;int num[100010];int dfs(int i)&#123; int ans = 0; for(int j = i + 1;j &lt;= n;++j) if(num[i] &lt; num[j]) ans = max(ans,dfs(j)); ans++; return ans;&#125;int main(void)&#123; cin &gt;&gt; n; for(int i = 1;i &lt;= n;++i) cin &gt;&gt; num[i]; for(int i = 1;i &lt;= n;++i) ANS = max(ANS,dfs(i)); cout &lt;&lt; ANS; return 0;&#125; 显然这个暴力非常的暴力，这样做是肯定会超时的，但是我们看看搜索有没有重复的状态！？ 记忆化搜索是不是可以加个记忆化搜索呢？真棒！ 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int n,ANS;int num[100010],dp[100010];int dfs(int i)&#123; if(dp[i] &gt; 0) return dp[i]; for(int j = i + 1;j &lt;= n;++j) if(num[i] &lt; num[j]) dp[i] = max(dp[i],dfs(j)); dp[i]++; return dp[i];&#125;int main(void)&#123; cin &gt;&gt; n; for(int i = 1;i &lt;= n;++i) cin &gt;&gt; num[i]; for(int i = 1;i &lt;= n;++i) ANS = max(ANS,dfs(i)); cout &lt;&lt; ANS; return 0;&#125; 糟糕X﹏X！！！！有没有更好的做法呢？ 倒序递推求$dp[i]$以$num[i]$为起点元素的最长上升子序列长度 每个数向后面比他大的点建立有向边； 求最长路（顶点数最多） 观察：边的顺序：$num[i]$向后的边$i+1,i+1,..,n$中选择。 可以直接倒序求即可。 $dp[n]=1​$; $dp[i]=max(dp[j])+1 (i&lt;j&lt;=n​$&amp;&amp;$num[i]&lt;num[j])​$ $ans=max(dp[i])$; 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int n,ans;int num[100010],dp[100010];int main(void)&#123; cin &gt;&gt; n; for(int i = 1;i &lt;= n;++i) cin &gt;&gt; num[i]; //------------------------------------------------- dp[n] = 1; for(int i = n - 1;i &gt;= 1;i--) &#123; dp[i] = 0; for(int j = i + 1;j &lt;= n;j++) if(num[i] &lt; num[j]) dp[i] = max(dp[i],dp[j]); dp[i]++; &#125; //------------------------------------------------- for(int i = 1;i &lt;= n;++i) ans = max(ans,dp[i]); cout &lt;&lt; ans; return 0;&#125; 正向递推方法当然是越少越好，所以你们自己学吧😂。 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int n,ans;int num[100010],dp[100010];int main(void)&#123; cin &gt;&gt; n; for(int i = 1;i &lt;= n;++i) cin &gt;&gt; num[i]; //------------------------------------------------- dp[1] = 1; for(int i = 2;i &lt;= n;++i) &#123; dp[i] = 0; for(int j = 1;j &lt;= i;++j) if(num[j] &lt; num[i]) dp[i] = max(dp[i],dp[j]); dp[i]++; &#125; //------------------------------------------------- for(int i = 1;i &lt;= n;++i) ans = max(ans,dp[i]); cout &lt;&lt; ans; return 0;&#125; LIS变式求 最长不下降序 列长度及输出改序列。 合唱队列 这真的是一道好题，吹爆。 题目表述N位同学站成一排，音乐老师要请其中的（N-K）位同学出列，使得剩下的K位同学排成合唱队形。合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1，2..，K，他们的身高分别为T1，T2…，Tk，则他们的身高满足T1&lt;…Ti+1&gt;…&gt;Tk（1≤i≤K）。你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。 输入输出格式输入格式共二行。第一行是一个整数N（2≤N≤100），表示同学的总数。第二行有n个整数，用空格分隔，第个整数h（130≤Ti≤230）是第同学的身高（厘米）。 输出格式一个整数，最少需要几位同学出列。 输入输出样例输入样例#1： 128186 186 150 200 160 130 197 220 输出样例#1： 14 说明对于50%的数据，保证有n≤20；对于全部的数据，保证有n≤100。 题解本人觉得这题是很不错的，虽然难度不高。首先，我们要想出列最少，那么就想要留下的最多。很容易想的最长升，但是，这个序列是一个中间高，两头底的序列，最长升只能处理出单调性的序列。 那么怎么做到呢？ 我们先看从T1到Ti这一段单调递增的序列，再看Ti到TK这一段单调递减的序列，那么问题就解决了。先从1到n求一趟最长升，然后从n到1也求一趟，最后枚举中间的Ti，然后从众多Ti中挑个大的。 代码如下： 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std; int a1[105][2];int height[105];int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;height[i]; for(int i=1;i&lt;=n;i++)&#123;//递推求最长上升子序列 a1[i][0]=1; for(int j=1;j&lt;i;j++)&#123; if(height[i]&gt;height[j]) a1[i][0]=max(a1[i][0],a1[j][0]+1); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; a1[i][1]=1; for(int j=1;j&lt;i;j++) if(height[i]&lt;height[j]) a1[i][1]=max(a1[i][1],max(a1[j][0],a1[j][1] )+1); &#125; int ans=0; for(int i=1;i&lt;=n;i++)&#123; ans=max( ans, max( a1[i][0],a1[i][1])); &#125; cout&lt;&lt;n-ans; return 0;&#125; 摘自洛谷题解 最大上升子序列的和 把加1变为加a[i]即可。 LIS： 12345f[n]=1;f[i]=max(f[j])+1 (i&lt;j&lt;=n&amp;&amp;a[i]&lt;a[j])ans=max(f[i]); 变为： 12345f[n]=a[n];f[i]=max(f[j])+a[i] (i&lt;j&lt;=n&amp;&amp;a[i]&lt;a[j])ans=max(f[i]); 最大连续子序列的和1、以$a[i]$为结束点和以$a[i-1]$为结束点的最大连续子序列和有没有联系？有什么样的联系？ 2、如果事先已经求得了以$a[i-1]$为结束点的最大连续子序列和为$x$，那么怎样求以$a[i]$为结束点的最大连续子序列？ 2019年6月13日 未完待续☕","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://chicago01.top/tags/模板/"},{"name":"动态规划","slug":"动态规划","permalink":"http://chicago01.top/tags/动态规划/"},{"name":"DP","slug":"DP","permalink":"http://chicago01.top/tags/DP/"}]},{"title":"和狗子日常","slug":"he-gou-zi-ri-chang","date":"2019-05-17T05:44:44.000Z","updated":"2019-06-08T06:02:50.268Z","comments":true,"path":"2019/05/17/he-gou-zi-ri-chang/","link":"","permalink":"http://chicago01.top/2019/05/17/he-gou-zi-ri-chang/","excerpt":"蒹葭苍苍，白露为霜。所谓伊人，在水一方。","text":"蒹葭苍苍，白露为霜。所谓伊人，在水一方。 猪子的由来 狗子自杀 作死现场 被。。。 植物人 红烧猪肉 炸猪 闪现 梗。。。 没完成任务怕被训，先认错😀 然后过了一天 日常晚安 吃啥？ 日常 互撩 哈哈哈哈，鸡汤狗 被教导😂","categories":[],"tags":[]},{"title":"Kruskal 最小生成树算法","slug":"kruskal-zui-xiao-sheng-cheng-shu-suan-fa","date":"2019-05-14T14:12:08.000Z","updated":"2019-05-14T14:14:23.271Z","comments":true,"path":"2019/05/14/kruskal-zui-xiao-sheng-cheng-shu-suan-fa/","link":"","permalink":"http://chicago01.top/2019/05/14/kruskal-zui-xiao-sheng-cheng-shu-suan-fa/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_N = 100000; // 最大顶点数const int MAX_M = 100000; // 最大边数struct edge &#123; int u, v, w;&#125;e[MAX_M];int fa[MAX_N], n, m; // fa 数组记录了并查集中结点的父亲bool cmp(edge a,edge b) &#123; return a.w &lt; b.w;&#125;// 并查集相关代码int ancestor(int x) &#123; // 在并查集森林中找到 x 的祖先，也是所在连通块的标识 if(fa[x] == x) return fa[x]; else return fa[x] = ancestor(fa[x]);&#125;int same(int x, int y) &#123; // 判断两个点是否在一个连通块（集合）内 return ancestor(x) == ancestor(y);&#125;void merge(int x, int y) &#123; // 合并两个连通块（集合） int fax = ancestor(x), fay = ancestor(y); fa[fax] = fay;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); // n 为点数，m 为边数 for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].w); // 用边集数组存放边，方便排序和调用 &#125; sort(e + 1, e + m + 1, cmp); // 对边按边权进行升序排序 for (int i = 1; i &lt;= n; i++) &#123; fa[i] = i; &#125; int rst = n, ans = 0; // rst 表示还剩多少个集合，ans 保存最小生成树上的总边权 for (int i = 1; i &lt;= m &amp;&amp; rst &gt; 1; i++) &#123; int x = e[i].u, y = e[i].v; if (same(x, y)) &#123; continue; // same 函数是查询两个点是否在同一集合中 &#125; else &#123; merge(x, y); // merge 函数用来将两个点合并到同一集合中 rst--; // 每次将两个不同集合中的点合并，都将使 rst 值减 1 ans += e[i].w; // 这条边是最小生成树中的边，将答案加上边权 &#125; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://chicago01.top/tags/模板/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://chicago01.top/tags/最小生成树/"}]},{"title":"P3955 图书管理员","slug":"p3955-tu-shu-guan-li-yuan","date":"2019-05-14T12:33:34.000Z","updated":"2019-05-14T12:34:33.815Z","comments":true,"path":"2019/05/14/p3955-tu-shu-guan-li-yuan/","link":"","permalink":"http://chicago01.top/2019/05/14/p3955-tu-shu-guan-li-yuan/","excerpt":"","text":"https://www.luogu.org/problemnew/show/P3955 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;#define maxn 10005using namespace std;int n,q,l,code;int a[maxn];int mod[9]=&#123;0,10,100,1000,10000,100000,1000000,10000000,100000000&#125;;int change()&#123; for(int i=1;i&lt;=n;i++)&#123; if(a[i]%mod[l]==code) return a[i]; &#125; return -1;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;q; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+1+n); for(int i=1;i&lt;=q;i++)&#123; cin&gt;&gt;l&gt;&gt;code; cout&lt;&lt;change()&lt;&lt;endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://chicago01.top/tags/模拟/"}]},{"title":"P1097 统计数字","slug":"p1097-tong-ji-shu-zi","date":"2019-05-14T12:31:59.000Z","updated":"2019-05-14T12:33:24.479Z","comments":true,"path":"2019/05/14/p1097-tong-ji-shu-zi/","link":"","permalink":"http://chicago01.top/2019/05/14/p1097-tong-ji-shu-zi/","excerpt":"","text":"https://www.luogu.org/problemnew/show/P1097 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;int,int&gt; num;set&lt;int&gt; qwq;int n,in;int main(void)&#123; cin &gt;&gt; n; for(int i = 1;i &lt;= n;++i) &#123; cin &gt;&gt; in; num[in]++; qwq.insert(in); &#125; for(set&lt;int&gt;::iterator it = qwq.begin();it != qwq.end();++it) cout &lt;&lt; *it &lt;&lt; \" \" &lt;&lt; num[*it] &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://chicago01.top/tags/模拟/"},{"name":"STL","slug":"STL","permalink":"http://chicago01.top/tags/STL/"}]},{"title":"P2347 砝码称重","slug":"p2347-fa-ma-cheng-chong","date":"2019-05-14T12:30:20.000Z","updated":"2019-05-14T12:31:32.673Z","comments":true,"path":"2019/05/14/p2347-fa-ma-cheng-chong/","link":"","permalink":"http://chicago01.top/2019/05/14/p2347-fa-ma-cheng-chong/","excerpt":"","text":"https://www.luogu.org/problemnew/show/P2347 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int num[] = &#123;0,1,2,3,5,10,20&#125;;int n[7],ans;bool tong[1001];int main(void)&#123; for(int i = 1;i &lt;= 6;++i) cin &gt;&gt; n[i]; tong[0] = 1; for(int i = 1;i &lt;= 6;++i) for(int j = 1;j &lt;= n[i];++j) for(int q = 1000;q &gt;= 0;--q) &#123; if(tong[q]) tong[q + num[i]] = 1; &#125; for(int i = 1;i &lt;= 1000;++i) if(tong[i]) ans++; cout &lt;&lt; \"Total=\" &lt;&lt; ans; return 0;&#125;","categories":[],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://chicago01.top/tags/模拟/"}]},{"title":"P1029 最大公约数和最小公倍数问题","slug":"p1029-zui-da-gong-yue-shu-he-zui-xiao-gong-bei-shu-wen-ti","date":"2019-05-14T12:29:01.000Z","updated":"2019-05-14T12:30:16.968Z","comments":true,"path":"2019/05/14/p1029-zui-da-gong-yue-shu-he-zui-xiao-gong-bei-shu-wen-ti/","link":"","permalink":"http://chicago01.top/2019/05/14/p1029-zui-da-gong-yue-shu-he-zui-xiao-gong-bei-shu-wen-ti/","excerpt":"","text":"https://www.luogu.org/problemnew/show/P1029 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;inline int gcd(int x,int y)&#123; if(y == 0) return x; else gcd(y,x%y);&#125;int ans;int main(void)&#123; int n,m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1;i &lt;= sqrt(m*n);++i) if((n*m)%i == 0 &amp;&amp; gcd(i,(n*m)/i) == n) ans++; cout &lt;&lt; ans*2; return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://chicago01.top/tags/数学/"}]},{"title":"P1094 纪念品分组","slug":"p1094-ji-nian-pin-fen-zu","date":"2019-05-14T12:27:28.000Z","updated":"2019-05-14T12:28:52.590Z","comments":true,"path":"2019/05/14/p1094-ji-nian-pin-fen-zu/","link":"","permalink":"http://chicago01.top/2019/05/14/p1094-ji-nian-pin-fen-zu/","excerpt":"","text":"https://www.luogu.org/problemnew/show/P1094 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int num[1000010],n,w;int main(void)&#123; cin &gt;&gt; w &gt;&gt; n; for(int i = 1;i &lt;= n;++i) cin &gt;&gt; num[i]; sort(num+1,num+n+1); int ans = 0; int l = 1,r = n; while(l &lt;= r) &#123; if(num[l] + num[r] &lt;= w) ans++,l++,r--; else ans++,r--; &#125; cout &lt;&lt; ans; return 0;&#125;","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://chicago01.top/tags/贪心/"},{"name":"模拟","slug":"模拟","permalink":"http://chicago01.top/tags/模拟/"}]},{"title":"P2626 斐波那契数列（升级版）","slug":"p2626-fei-bo-na-qi-shu-lie-sheng-ji-ban","date":"2019-05-14T12:25:47.000Z","updated":"2019-05-14T12:27:26.699Z","comments":true,"path":"2019/05/14/p2626-fei-bo-na-qi-shu-lie-sheng-ji-ban/","link":"","permalink":"http://chicago01.top/2019/05/14/p2626-fei-bo-na-qi-shu-lie-sheng-ji-ban/","excerpt":"","text":"https://www.luogu.org/problemnew/show/P2626 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const long long mod = pow(2,31);int f[50],n;int main(void)&#123; f[1] = 1; f[2] = 1; cin &gt;&gt; n; for(int i = 3;i &lt;= n;++i) f[i] = (f[i-1] + f[i-2])%mod; cout &lt;&lt; f[n] &lt;&lt; '='; bool x = 1; for(int i = 2;i &lt;= f[n];++i) for(;f[n]%i==0;) &#123; if(x) &#123; x = 0; cout &lt;&lt; i; &#125; else cout &lt;&lt; '*' &lt;&lt; i; f[n]/=i; &#125; return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://chicago01.top/tags/数学/"},{"name":"模板","slug":"模板","permalink":"http://chicago01.top/tags/模板/"}]},{"title":"CF719B Anatoly and Cockroaches","slug":"cf719b-anatoly-and-cockroaches","date":"2019-05-13T10:13:43.000Z","updated":"2019-05-13T10:15:19.281Z","comments":true,"path":"2019/05/13/cf719b-anatoly-and-cockroaches/","link":"","permalink":"http://chicago01.top/2019/05/13/cf719b-anatoly-and-cockroaches/","excerpt":"","text":"https://www.luogu.org/problemnew/show/CF719B 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int n;string s;int a,b,c,d,ans;int main(void)&#123; cin &gt;&gt; n &gt;&gt; s; for(int i = 0;i &lt; n;++i) &#123; if(i % 2 == 0) &#123; if(s[i] == 'r') a++; if(s[i] == 'b') b++; &#125; else &#123; if(s[i] == 'r') c++; if(s[i] == 'b') d++; &#125; &#125; ans = min(max(b,c),max(a,d)); cout &lt;&lt; ans; return 0;&#125;","categories":[],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://chicago01.top/tags/字符串/"},{"name":"模板","slug":"模板","permalink":"http://chicago01.top/tags/模板/"}]},{"title":"计数原理","slug":"ji-shu-yuan-li","date":"2019-05-13T04:44:48.000Z","updated":"2019-05-13T04:46:01.388Z","comments":true,"path":"2019/05/13/ji-shu-yuan-li/","link":"","permalink":"http://chicago01.top/2019/05/13/ji-shu-yuan-li/","excerpt":"计数原理是数学中的重要研究对象之一，分类加法计数原理、分步乘法计数原理是解决计数问题的最基本、最重要的方法，也称为基本计数原理，它们为解决很多实际问题提供了思想和工具。","text":"计数原理是数学中的重要研究对象之一，分类加法计数原理、分步乘法计数原理是解决计数问题的最基本、最重要的方法，也称为基本计数原理，它们为解决很多实际问题提供了思想和工具。 基本定义加法原理分类计数原理：做一件事情，完成它有n类方式，第一类方式有M1种方法，第二类方式有M2种方法，……，第n类方式有Mn种方法，那么完成这件事情共有M1+M2+……+Mn种方法。 类类独立。 例：从武汉到上海有乘火车、飞机、轮船3种交通方式可供选择，而火车、飞机、轮船分别有k1，k2，k3个班次，那么从武汉到上海共有 k1+k2+k3种方式可以到达。 乘法原理分步计数原理：做一件事情，完成它有$n$个步骤，第一步方式有$M_1$种方法，第二步方式有$M_2$种方法，……，第$n$步方式有$M_n$种方法，那么完成这件事情共有$M_1M_2……*M_n$种方法。 步步相关。 例：百位数有5种选择；十位数有4种选择；个位数有3种选择．所以共有5×4×3=60个数字不重复的三位数． 排列排列（英语：Permutation）是将相异对象或符号根据确定的顺序重排。每个顺序都称作一个排列。例如，从一到六的数字有720种排列，对应于由这些数字组成的所有不重复亦不阙漏的序列，例如”4, 5, 6, 1, 2, 3” 与1, 3, 5, 2, 4, 6。 排列数：从$n$个相异的元素中取出$m$个元素，$m$个元素的排列数量为：$A^m_n=n!/(n-m)!$ 全排列排列数：$A^n_n=n!$ 例：以赛马为例，有8匹马参加比赛，玩家需要在彩票上填入前三胜出的马匹的号码，从8匹马中取出3匹马来排前3名，排列数量为： $A^3_8 = 8!/(8-3)!$ 组合一个集的元素的组合（英语：Combination）是一个子集。S的一个k-组合是S的一个有k个元素的子集。若两个子集的元素完全相同并顺序相异，它仍视为同一个组合，这是组合和排列不同之处。 从n个不同元素中每次取出m个不同元素（0≤m≤n），不管其顺序合成一组，称为从n个元素中不重复地选取m个元素的一个组合。所有这样的组合的总数称为组合数，这个组合数的计算公式为:$C^m_n=P^m_n/P^m_m=n!/m!(n-m)!$ 从不同元素中抽取部分元素的问题 。 模型总结排列组合也不过是几多模型，在来回套用罢了，只需要区分好这几个模型，并且拿到题，能联想到是哪个模型，进而套用就可以解出题目了。 基础综合 加法原理是情况与情况之间，类与类之间的关系。 乘法原理是步骤与步骤之间的关系，前后是相关的。 排列$A^m_n$是从$n$给中选取$m$个进行排列的数目。 组合$C^m_n$是从$n$给中选取$m$个进行组合的数目。 如果真的不知道排列和组合到底是什么，你可以再去看看课本。 例 （1988·全国·14·J）假设在200件产品中有3件次品，现在从中任意抽取5件，其中至少有2件次品的抽法种数为（）. 解析看到至少，要想到分类，如果要分类，呢么就要用到加法原理。 5个里面抽到了2个次品：$C^2_3$，其余3个是正常的：$C^3_{197}$，因为抽到次品和抽到正常的两个步骤是相关的，所以 $C^2_3C^3_{197}$。 5个里面抽到了3个次品：$C^3_3$，其余2个是正常的：$C^2_{197}$，因为抽到次品和抽到正常的两个步骤是相关的，所以 $C^3_3C^2_{197}$。 加法原理：$C^2_3C^3_{197}+C^3_3C^2_{197}$ 例 （2007·全国一·5·J）甲、乙、丙3位同学选修课程，从4门课程中，甲选修2门，乙、丙各选修3门，则不同的选修方案共有（）. 解析甲乙丙选课是相关关系，用乘法原理：$C^2_4C^3_4C^3_4$。 例 （2010·湖北·6·J）现有6名同学去听同时进行的5个课外知识讲座，每名同学可自由选择其中的一个讲座，不同选法的种数是（）. 解析每个人都有5个选择，根据乘法原理可以很容易得到$5^6$。 例 （2011·全国·9·JJ）4位同学每人从甲、乙、丙3门课程中选修1门，则恰有2人选修课程甲的不同选总共有（） 解析 恰有两人选择甲课程，也就是只有两个人选择甲课程：$C^2_4$。 剩余两个人只能选择剩余的课程，不能再选择甲，所以每个人剩两个选择：$2^2$。 根据乘法原理可得：$C^2_4*2^2$。 例 （2006·江苏·13·JJ）今有2个红球、3个黄球、4个白球，同色球不加以区分，将这9个球排成一列有（）种不同的方法（用数字作答）. 解析九个排成一列，可以用填坑法，一共有9个坑，分别选择红黄白三种颜色球往里面填充：$C^2_9C^3_7C^4_4$。 例 （2000·全国旧课程·13·JJ）乒乓球队的10名队员中有3名主力队员，派5名参加比赛.3名主力队员要安排在第一、三、五位置，其余7名队员选2名安排在第二、四位置，那么不同的出场安排共有（）种（用数字作答）. 解析 有3个位置上填哪几个人是已经确定的，所以直接排列$A^3_3$。 剩余2个人中要从7个人中选择出来，并排列：$A^2_7$。 乘法原理可得：$A^3_3A^2_7$。 例 （2003·北京·9·J）从黄瓜、白菜、油菜、扁豆4种蔬菜品种中选出3种，分别种在不同土质的三块土地上，其中黄瓜必须种植，不同的种植方法共有（）. 解析 黄瓜必须选择，所以就从三种菜里选出2种，$C^2_3$。 又要把这三种选好的作物上排列在不同土质的三块土地，$A^3_3$。 乘法原理可得，$C^2_3$ $A^3_3$。 例 （2007·北京·5·J）某城市的汽车牌照号码由2个英文字母后接4个数字组成，其中4个数字互不相同的牌照号码共有（）. 解析 从26个字母中选择一个字母，$C^1_{26}$ 在从26个字母中选择一个字母，$C^1_{26}$ 选择四个不同数字，10个数字里面选择4个的排列数，$A^4_10$ 乘法原理，$C^1_{26}$$C^1_{26}$$A^4_10$ 分组模型 题目关键字：从XX中选出X，做YYY。 一种是确定性分配，比如：6个人平均去3个不同的地方，于是我们很确定每个地方都要2个人去，此时直接$C^6_2C^4_2C^2_2$ 即可。 一种是不确定性分配，比如：4个人去3个不同的地方，每地至少一个，也即1+1+2，这时每个地方不确定自己是几人（1或者2），所以要充分考虑各种可能性，列表格有助于周全地考虑各种可能性。 例 （2009·宁夏海南·15·j）7名志愿者中安排6人在周六、周日两天参加社区公益活动。若每天安排3人，则不同的安排方案共有（）种（用数字作答）。 解析确定性分组，很明显可得$C^7_3C^3_4$。 例 （2009·湖北·4·j）从5名志愿者中选派4人在星期五、星期六、星期日参加公益活动，每人一天，要求星期五有一人参加，星期六有两人参加，星期日有一人参加，则不同的选派方法共有（） 解析确定性分组，很容易确定$C^1_5C^4_2C^1_2$。 例 （2017·新课标全国二·6·JJ）安排3名志愿者完成4项工作，每人至少完成1项，每一项工作由1人完成，则不同的安排方式共有（）。 解析每个人完成工作的数目是不确定的，所以要进行分类。 第一个人 第二个人 第三个人 组合 2 1 1 $C^2_5C^2_3C^1_1$ 1 2 1 $C^2_5C^3_1C^2_2$ 1 1 2 $C^1_5C^4_2C^2_2$ 加法原理可得：$C^2_5C^2_3C^1_1$$+C^2_5C^3_1C^2_2+$$C^1_5C^4_2C^2_2$ 例 （1995·全国·20·JJ）四个不同的小球放入编号为1，2，3，4的四个盒子中，则恰有一个空盒子的放法共有（）种。 解析这时候不仅要对空盒子进行分类，如果有一个空盒子，呢么必然还存在一个盒子放2个球。 第一个盒子 第二个盒子 第三个盒子 第四个盒子 组合 0 1 1 2 ………… 0 1 2 1 ………… 0 2 1 1 ………… 1 1 2 0 ………… ………… ………… ………… ………… ………… 懒癌症患者，懒得打了，你看不懂再问我吧。 捆绑法和插孔法 ①出现XX必须和YY在一起，呢就把XX和YY捆绑到一起，然后对XX和YY进行一个全排列，因为XX可能在YY左边，也可能在右边。 ②出现XX必须不和YY在一起，呢就把XX和YY插缝到其它人中间。 例 （1996·全国·5·J）6名同学排成一排，其中甲、乙两人必须在一起的不同排法有（）。 解析呢就把甲乙排在一起吧，因为甲乙的位置没有被限定，所以甲乙内部的顺序也要进行一个全排列：$A^5_5A^2_2$ 。 例 （1990·全国·12·J）A，B，B，D，E五人并排站在一排，如果A，B必须相邻且B在A的右边，呢么不同的排法公有（）。 解析A，B的内部位置是被确定好的，直接当成一个整体进行排列，所以最终结果是：$A^4_4$ 。 例 （2007·北京·5·J）记者要为5名志愿者和他们帮助的2位老人拍照，要求排成一排，2位老人相邻但不排在两端，不同的排法共有（）. 解析第一步，排两端∵从5名志愿者中选2名有$A_5^2$=20种排法 第二步，∵2位老人相邻，把2个老人看成整体，与剩下的3名志愿者全排列，有$A_4^4$=24种排法 第三步，2名老人之间的排列，有$A_2^2$=2种排法 最后，三步方法数相乘，共有$20×24×2=960$种排法故填写960. 例 （2010·北京·4·j）8名学生和2位老师站成一排合影，2位老师不相邻的排法种数为（）. 解析这时候就要考虑插孔了，不相邻，就让她俩插在别人中间呗。 将所有学生先排列，有$A_8^8$ 种排法， 然后将两位老师插入9个空中， 共有$A_9^2$ 种排法， ∴一共有$A_8^8A_9^2$种排法． 例 （1984·全国·11·j）要排一张有6个歌唱节目和4个舞蹈节目的演出节目单，任何两个舞蹈节目不得相邻，问有多少种不同的排法(). 解析有七个孔可插，有四个元素要插进去，综上可得：$A^6_6A^4_7$。 练习 （2005·辽宁·15·jjj）用1，2，3，4，5，6，7，8组成没有重复数字的八位数，要求1和2相邻、3与4相邻，5与6相邻，而7与8不相邻，这样的八位数共有( )个（$A_4^2A_3^3A_2^2A_2^2A_2^2$）。 练习 （2008·安徽·12·JJJ）12名同学合影，站成前排4人后排8人，现摄影师要从后排8人中抽2人调整到前排，若其他人的相对顺序不变，则不同调整方法的总数是（）($C_8^2A_6^2$). 堵孔法所谓“堵孔”法，举个例子一听就懂，8瓶不同饮料8个人平分，本来是$A_8^8$.但现在小明不喝可乐，于是要从其他7人中选一人堵住可乐这个孔，再将剩下的7人（包括小明）$A_7^7$。 例 （1995·全国·15·j）由数字1，2，3，4，5组成的无重复数字的四位偶数的个数为（）. 解析 因为决定是否偶数的决定性因素是个位，先找个数把个位堵住$C_2^1$。 再从剩余的4个数中选择3个数$A_4^3$。 练习 （2009·陕西·9·j）从1，2，3，4，5，6，7这七个数字中任取两个奇数和两个偶数，组成没有重复数字的四位数，其中奇数的个数为（）. 练习 （2005·福建·10·j）从6人中选4人分别到巴黎、伦敦、悉尼、莫斯科四个城市游览，要求每个城市有一人游览，每人只游览一个城市，且这6人中甲、乙两人不去巴黎游览，则不同的选择方案共有（）. END其实还剩下两个模型，一个对立面，另一个染色，但是我觉得如果上面这些模型都会了，剩余这两个随便查查资料也很简单的。","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://chicago01.top/tags/杂项/"},{"name":"数学","slug":"数学","permalink":"http://chicago01.top/tags/数学/"}]},{"title":"CF714A Meeting of Old Friends","slug":"cf714a-meeting-of-old-friends","date":"2019-05-10T23:17:20.000Z","updated":"2019-05-10T23:18:57.129Z","comments":true,"path":"2019/05/11/cf714a-meeting-of-old-friends/","link":"","permalink":"http://chicago01.top/2019/05/11/cf714a-meeting-of-old-friends/","excerpt":"","text":"https://www.luogu.org/problemnew/show/CF714A 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;long long l1,r1,l2,r2,k;int main(void)&#123; cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2 &gt;&gt; k; bool TNT = 0; long long minn = min(r1,r2); long long maxn = max(l1,l2); long long ans = minn - maxn + 1; if(maxn &gt; minn) &#123; cout &lt;&lt; 0 &lt;&lt; endl; TNT = 1; &#125; else if(k &gt;= maxn &amp;&amp; k &lt;= minn) ans -= 1; if(!TNT) cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://chicago01.top/tags/贪心/"},{"name":"模拟","slug":"模拟","permalink":"http://chicago01.top/tags/模拟/"},{"name":"数学","slug":"数学","permalink":"http://chicago01.top/tags/数学/"}]},{"title":"CF719A Vitya in the Countryside","slug":"cf719a-vitya-in-the-countryside","date":"2019-05-10T06:01:08.000Z","updated":"2019-05-10T06:03:38.815Z","comments":true,"path":"2019/05/10/cf719a-vitya-in-the-countryside/","link":"","permalink":"http://chicago01.top/2019/05/10/cf719a-vitya-in-the-countryside/","excerpt":"","text":"https://www.luogu.org/problemnew/show/CF719A 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int num[100],n;int main(void)&#123; cin &gt;&gt; n; for(int i = 1;i &lt;= n;++i) cin &gt;&gt; num[i]; if(n == 1 &amp;&amp; num[n] != 15 &amp;&amp; num[n] != 0) cout &lt;&lt; \"-1\"; else if(num[n] == 15) cout &lt;&lt; \"DOWN\"; else if(num[n] == 0) cout &lt;&lt; \"UP\"; else if(num[n] &lt; 15 &amp;&amp; num[n] &gt; num[n-1]) cout &lt;&lt; \"UP\"; else if(num[n] &lt; 15 &amp;&amp; num[n] &lt; num[n-1]) cout &lt;&lt; \"DOWN\"; return 0;&#125;","categories":[],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://chicago01.top/tags/模拟/"},{"name":"数学","slug":"数学","permalink":"http://chicago01.top/tags/数学/"}]},{"title":"模板：树状数组","slug":"mo-ban-shu-zhuang-shu-zu","date":"2019-05-10T06:00:21.000Z","updated":"2019-05-10T06:01:06.185Z","comments":true,"path":"2019/05/10/mo-ban-shu-zhuang-shu-zu/","link":"","permalink":"http://chicago01.top/2019/05/10/mo-ban-shu-zhuang-shu-zu/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int num[1000010],N = 0,q = 0;inline int lowbit(int x)&#123; return (x) &amp; (-x); &#125;inline void add(int x,int k)&#123; while(x&lt;=N) &#123; num[x]+=k; x+=lowbit(x); &#125;&#125;inline long long sum(int x)&#123; long long ans = 0; for(;x;x-=lowbit(x)) ans+=num[x]; return ans;&#125;int main(void)&#123; cin &gt;&gt; N &gt;&gt; q; while(q--) &#123; char qwq; cin &gt;&gt; qwq; if(qwq == 'x') &#123; int x,y; cin &gt;&gt; x &gt;&gt; y; add(x,y); &#125; if(qwq == 'y') &#123; int x,y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; sum(y) - sum(x-1) &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://chicago01.top/tags/数据结构/"},{"name":"模板","slug":"模板","permalink":"http://chicago01.top/tags/模板/"},{"name":"树状数组","slug":"树状数组","permalink":"http://chicago01.top/tags/树状数组/"}]},{"title":"树状数组","slug":"shu-zhuang-shu-zu","date":"2019-05-09T13:13:46.000Z","updated":"2019-05-09T13:16:14.190Z","comments":true,"path":"2019/05/09/shu-zhuang-shu-zu/","link":"","permalink":"http://chicago01.top/2019/05/09/shu-zhuang-shu-zu/","excerpt":"例1：给出一个长度为n的序到，有m个询问，每次形如l，r，求[l，r]的区间和。 法1： 暴力 每次询问都扫一遍。 法2： 前缀和 预处理O(n),每询问次O(1)时间复杂度。 法3： 线段树 &amp; 树状数组 弱智。。。","text":"例1：给出一个长度为n的序到，有m个询问，每次形如l，r，求[l，r]的区间和。 法1： 暴力 每次询问都扫一遍。 法2： 前缀和 预处理O(n),每询问次O(1)时间复杂度。 法3： 线段树 &amp; 树状数组 弱智。。。 例2：给出一个长度为n的序到，有m个操作，分别为询问[l，r]的区间和，和将x位置上的值增加c。 暴力前缀和行不通，每次修改都需要重新计算前缀和，这时候正解就是树状数组了。 lowbit(x) : 等于x在二进制下最右边呢个1代表的多少。 1234567891011121314151 对应的二进制是 -&gt; 1 最右边呢个1对应的10进制 -&gt; 12 对应的二进制是 -&gt; 10 最右边呢个1对应的10进制 -&gt; 23 对应的二进制是 -&gt; 11 最右边呢个1对应的10进制 -&gt; 14 对应的二进制是 -&gt; 100 最右边呢个1对应的10进制 -&gt; 45 对应的二进制是 -&gt; 101 最右边呢个1对应的10进制 -&gt; 16 对应的二进制是 -&gt; 110 最右边呢个1对应的10进制 -&gt; 2······lowbit(1) = 1lowbit(2) = 2lowbit(3) = 1lowbit(4) = 4lowbit(5) = 1lowbit(6) = 2······lowbit(x) = (x) &amp; (-x) 先感受一下这个lowbit有什么用： $-x$ 代表 $x$ 的负数，计算机中负数使用对应的正数的补码来表示。 例如： $x = 88_{(10)} = 1011000_{(2)}$ $-x = -88_{(10)} = (0100111_{(2)} + 1_{(2)}) = 101000_{(2)}$ $x &amp; (-x) = 1000_{(2)} = 8_{(10)}$ lowbit(x)代码实现： 1234inline int lowbit(int x)&#123; return x &amp; -x;&#125; 那么C[]如何求得？ 下面利用C[i]数组，求A数组中前i项的和 举个例子 $i=7$ sum[7]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7] C[4]=A[1]+A[2]+A[3]+A[4]; C[6]=A[5]+A[6]; C[7]=A[7]; 可以推出: sum[7]=C[4]+C[6]+C[7]; 序号写为二进制: sum[(111)]=C[(100)]+C[(110)]+C[(111)]; 再举个例子 $i=5$ sum[5]=A[1]+A[2]+A[3]+A[4]+A[5] C[4]=A[1]+A[2]+A[3]+A[4]; C[5]=A[5]; 可以推出: sum[5]=C[4]+C[5]; 序号写为二进制: sum[(101)]=C[(100)]+C[(101)]; 12345678C[1]=A[1];C[2]=A[1]+A[2];C[3]=A[3];C[4]=A[1]+A[2]+A[3]+A[4];C[5]=A[5];C[6]=A[5]+A[6];C[7]=A[7];C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]; 结论： lowbit(x) 的值为纵轴，x轴为A数组下标。$C[i] = A[i-lowbit(i)+1] + … + A[i]$ 后缀和更新代码： 123456789101112131415inline void init()&#123; for(int i = 1;i &lt;= n;++i) &#123; int w; cin &gt;&gt; w; add(i,w); &#125;&#125;inline void add(int x,int w)&#123; for(int i = x;i &lt;= n;i += lowbit(i)) c[i] += w;&#125; 求区间 $0 — x$ 的和代码： 123456789inline int getsum(int x)&#123; int ans = 0; for(int i = x;i &gt; 0;i -= lowbit(i)) &#123; ans += C[i]; &#125; return 0;&#125; 例2：https://www.luogu.org/problemnew/show/P2068代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;int C[1000100],N = 0,q = 0;int lowbit(int x)&#123; return x &amp; (-x);&#125;void add(int x,int k)&#123; while(x&lt;=N) &#123; C[x]+=k; x+=lowbit(x); &#125;&#125;inline long long sum(int x)&#123; long long ans = 0; for(;x;x-=lowbit(x)) &#123; ans += C[x]; &#125; return ans;&#125;int main(int argc, char const *argv[])&#123; cin &gt;&gt; N &gt;&gt; q; while(q--) &#123; char qwq; cin &gt;&gt; qwq; if(qwq == 'x') &#123; int x,y; cin &gt;&gt; x &gt;&gt; y; add(x,y); &#125; if(qwq == 'y') &#123; int x,y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; sum(y) - sum(x-1) &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://chicago01.top/tags/数据结构/"},{"name":"树状数组","slug":"树状数组","permalink":"http://chicago01.top/tags/树状数组/"}]},{"title":"CF712C Memory and De-Evolution","slug":"cf712c-memory-and-de-evolution","date":"2019-05-09T12:53:29.000Z","updated":"2019-05-09T12:53:56.682Z","comments":true,"path":"2019/05/09/cf712c-memory-and-de-evolution/","link":"","permalink":"http://chicago01.top/2019/05/09/cf712c-memory-and-de-evolution/","excerpt":"","text":"https://www.luogu.org/problemnew/show/CF712C 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;int num[3];int x,y,ans;int main(void)&#123; cin &gt;&gt; x &gt;&gt; y; num[0] = num[1] = num[2] = y; while(num[0] != x || num[1] != x || num[2] != x) &#123; sort(num,num+3); num[0] = min(num[1] + num[2] -1,x); ans++; &#125; cout &lt;&lt; ans; return 0;&#125;","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://chicago01.top/tags/贪心/"},{"name":"递推","slug":"递推","permalink":"http://chicago01.top/tags/递推/"},{"name":"数学","slug":"数学","permalink":"http://chicago01.top/tags/数学/"}]},{"title":"CF712B Memory and Trident","slug":"cf712b-memory-and-trident","date":"2019-05-09T11:44:03.000Z","updated":"2019-05-09T12:08:07.140Z","comments":true,"path":"2019/05/09/cf712b-memory-and-trident/","link":"","permalink":"http://chicago01.top/2019/05/09/cf712b-memory-and-trident/","excerpt":"","text":"https://www.luogu.org/problemnew/show/CF712B 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;string s;int R,L,U,D;inline bool what(int num)&#123; if(num % 2 == 0) return 1; else return 0;&#125;int main(void)&#123; cin &gt;&gt; s; for(int i = 0;i &lt; s.length();++i) &#123; if(s[i] == 'R') R++; if(s[i] == 'L') L++; if(s[i] == 'U') U++; if(s[i] == 'D') D++; &#125; if(what(s.length()- 1)) cout &lt;&lt; \"-1\"; else cout &lt;&lt; (abs(R-L) + abs(U-D))/2; return 0;&#125;","categories":[],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://chicago01.top/tags/模拟/"},{"name":"数学","slug":"数学","permalink":"http://chicago01.top/tags/数学/"},{"name":"字符串","slug":"字符串","permalink":"http://chicago01.top/tags/字符串/"}]},{"title":"CF708A Letters Cyclic Shift","slug":"cf708a-letters-cyclic-shift","date":"2019-05-09T11:43:29.000Z","updated":"2019-05-09T11:44:01.477Z","comments":true,"path":"2019/05/09/cf708a-letters-cyclic-shift/","link":"","permalink":"http://chicago01.top/2019/05/09/cf708a-letters-cyclic-shift/","excerpt":"","text":"https://www.luogu.org/problemnew/show/CF708A 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;string s;int main(void)&#123; int i = 0,cnt = 0; cin &gt;&gt; s; int len = s.length(); for(;i &lt; len;++i) if(s[i] != 'a') break; for(;i &lt; len;++i) &#123; if(s[i] == 'a') break; s[i]--; cnt++; &#125; if(!cnt) s[len-1] = 'z'; cout &lt;&lt; s; return 0;&#125;","categories":[],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://chicago01.top/tags/模拟/"},{"name":"字符串","slug":"字符串","permalink":"http://chicago01.top/tags/字符串/"}]},{"title":"CF712A Memory and Crow","slug":"cf712a-memory-and-crow","date":"2019-05-09T11:18:24.000Z","updated":"2019-05-09T11:22:19.347Z","comments":true,"path":"2019/05/09/cf712a-memory-and-crow/","link":"","permalink":"http://chicago01.top/2019/05/09/cf712a-memory-and-crow/","excerpt":"水题。。。","text":"水题。。。 https://www.luogu.org/problemnew/show/CF712A 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int n;int number[100010];int main(void)&#123; cin &gt;&gt; n; for(int i = 1;i &lt;= n;++i) cin &gt;&gt; number[i]; for(int i = 1;i &lt; n;++i) cout &lt;&lt; number[i] + number[i+1] &lt;&lt; \" \"; cout &lt;&lt; number[n]; return 0;&#125;","categories":[],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://chicago01.top/tags/模拟/"},{"name":"递推","slug":"递推","permalink":"http://chicago01.top/tags/递推/"},{"name":"数学","slug":"数学","permalink":"http://chicago01.top/tags/数学/"}]},{"title":"P5019 铺设道路 && P1969 积木大赛 && P3078 扑克牌型","slug":"p5019-pu-she-dao-lu-and-p1969-ji-mu-da-sai-and-p3078-bu-ke-pai-xing","date":"2019-05-08T10:09:44.000Z","updated":"2019-05-08T10:13:31.581Z","comments":true,"path":"2019/05/08/p5019-pu-she-dao-lu-and-p1969-ji-mu-da-sai-and-p3078-bu-ke-pai-xing/","link":"","permalink":"http://chicago01.top/2019/05/08/p5019-pu-she-dao-lu-and-p1969-ji-mu-da-sai-and-p3078-bu-ke-pai-xing/","excerpt":"","text":"题目描述春春是一名道路工程师，负责铺设一条长度为n的道路。铺设道路的主要工作是填平下陷的地表。整段道路可以看作是n块首尾相连的区域，一开始，第i块区域下陷的深度为di。春春每天可以选择一段连续区间[L，R]，填充这段区间中的每块区域，让其下陷深度减少1。在选择区间时，需要保证，区间内的每块区域在填充前下陷深度均不为0。春春希望你能帮他设计一种方案，可以在最短的时间内将整段道路的下陷深度都变为0。 输入输出格式输入格式：输入文件包含两行，第一行包含一个整数n，表示道路的长度。第二行包含n个整数，相邻两数间用一个空格隔开，第i个整数为di。 输出格式：输出文件仅包含一个整数，即最少需要多少天才能完成任务。 输入输出样例输入样例#1： 126 4 3 2 5 3 5 输出样例#1： 19 说明【样例解释】一种可行的最佳方案是，依次选择：[1，6]、[1，6]、[1，2]、[1，1]、[4，6]、[4，4]、[4，4、[6，6]、[6，6]。【数据规模与约定】对于30%的数据，1≤n≤10；对于70%的数据，1≤n≤1000；对于100%的数据，1≤n≤100000，0≤di≤10000。 代码1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int n,num[1000000];long long ans;int main(void)&#123; cin &gt;&gt; n; for(int i = 1;i &lt;= n;++i) cin &gt;&gt; num[i]; for(int i = 1;i &lt;= n;++i) if(num[i] &gt; num[i-1]) ans += num[i] - num[i-1]; cout &lt;&lt; ans; return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://chicago01.top/tags/数据结构/"},{"name":"贪心","slug":"贪心","permalink":"http://chicago01.top/tags/贪心/"},{"name":"递推","slug":"递推","permalink":"http://chicago01.top/tags/递推/"}]},{"title":"P5020 货币系统","slug":"p5020-huo-bi-xi-tong","date":"2019-05-07T12:28:44.000Z","updated":"2019-05-07T13:41:50.628Z","comments":true,"path":"2019/05/07/p5020-huo-bi-xi-tong/","link":"","permalink":"http://chicago01.top/2019/05/07/p5020-huo-bi-xi-tong/","excerpt":"题目描述在网友的国度中共有 n种不同面额的货币，第 i 种货币的面额为 a[i]，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 n、面额数组为 a[1..n]的货币系统记作 (n,a)。","text":"题目描述在网友的国度中共有 n种不同面额的货币，第 i 种货币的面额为 a[i]，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 n、面额数组为 a[1..n]的货币系统记作 (n,a)。 在一个完善的货币系统中，每一个非负整数的金额 x 都应该可以被表示出，即对每一个非负整数 x，都存在 n 个非负整数 t[i] 满足 a[i]×t[i] 的和为 x。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 x不能被该货币系统表示出。例如在货币系统 n=3, a=[2,5,9] 中，金额 1,3 就无法被表示出来。 两个货币系统 (n,a) 和 (m,b) 是等价的，当且仅当对于任意非负整数 x，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 现在网友们打算简化一下货币系统。他们希望找到一个货币系统 (m,b)，满足 (m,b) 与原来的货币系统 (n,a)等价，且 m 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 m。 输入输出格式输入格式： 输入文件的第一行包含一个整数 T，表示数据的组数。 接下来按照如下格式分别给出 T组数据。 每组数据的第一行包含一个正整数 n。接下来一行包含 n 个由空格隔开的正整数 a[i]。 输出格式： 输出文件共有 T 行，对于每组数据，输出一行一个正整数，表示所有与 (n,a) 等价的货币系统 (m,b) 中，最小的 m。 输入输出样例输入样例#1： 123452 4 3 19 10 6 5 11 29 13 19 17 输出样例#1： 122 5 说明在第一组数据中，货币系统 (2, [3,10]) 和给出的货币系统 (n, a) 等价，并可以验证不存在 m &lt; 2 的等价的货币系统，因此答案为 2。 在第二组数据中，可以验证不存在 m &lt; n 的等价的货币系统，因此答案为 5。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;inline void search()&#123; long long ans = 0; int n,num[25010],s[110]; memset(num,0,sizeof(num)); cin &gt;&gt; n; for(int i = 1;i &lt;= n;++i) &#123; cin &gt;&gt; s[i]; num[s[i]] = 2; &#125; sort(s+1,s+n+1); for(int i = 1;i &lt;= s[n];++i) &#123; if(num[i] &gt; 0) &#123; for(int j = 1;j &lt;= n;++j) &#123; if(i+s[j] &lt;= s[n]) num[i+s[j]] = 1; else break; &#125; &#125; &#125; for(int i = 1;i &lt;= s[n];++i) if(num[i] == 2) ans++; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main(void)&#123; int T; cin &gt;&gt; T; while(T--) search(); return 0;&#125;","categories":[],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://chicago01.top/tags/搜索/"},{"name":"排序","slug":"排序","permalink":"http://chicago01.top/tags/排序/"}]},{"title":"BZOJ刷题表","slug":"bzoj-shua-ti-biao","date":"2019-05-07T11:14:41.000Z","updated":"2019-05-14T10:31:52.383Z","comments":true,"path":"2019/05/07/bzoj-shua-ti-biao/","link":"","permalink":"http://chicago01.top/2019/05/07/bzoj-shua-ti-biao/","excerpt":"HZWer BZOJ 做题记录BZOJ 刷题量 by hzwer (合计 740+): 以下是各季度的刷题顺序 (按时间先后)。","text":"HZWer BZOJ 做题记录BZOJ 刷题量 by hzwer (合计 740+): 以下是各季度的刷题顺序 (按时间先后)。 刷题顺序 (Q1 2014，题目数量 110+):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111BZOJ 1050 [HAOI 2006] 旅行BZOJ 1012 [JSOI 2008] 最大数BZOJ 1008 [HNOI 2008] 越狱BZOJ 1601 [USACO 2008 Oct] 灌水BZOJ 1002 [FJOI 2007] 轮状病毒BZOJ 1003 [ZJOI 2006] 物流运输BZOJ 1192 [HNOI 2006] 鬼谷子的钱袋BZOJ 1191 [HNOI 2006] 超级英雄BZOJ 1303 [CQOI 2009] 中位数图BZOJ 1270 [Beijing WC 2008] 雷涛的小猫BZOJ 3039 [玉蟾宫]BZOJ 1059 [ZJOI 2007] 矩阵游戏BZOJ 1202 [HNOI 2005] 狡猾的商人BZOJ 1051 [HAOI 2006] 受欢迎的牛BZOJ 1001 [Beijing 2006] 狼抓兔子BZOJ 1083 [SCOI 2005] 繁忙的都市BZOJ 1588 [HNOI 2002] 营业额统计BZOJ 1208 [HNOI 2004] 宠物收养所BZOJ 1491 [NOI 2007] 社交网络BZOJ 1295 [SCOI 2009] 最长距离BZOJ 1084 [SCOI 2005] 最大子矩阵BZOJ 3109 [CQOI 2013] 新数独BZOJ 3038 上帝造题的七分钟2BZOJ 1821 [JSOI 2010] 部落划分BZOJ 1041 [HAOI 2008] 圆上的整点BZOJ 1087 [SCOI 2005] 互不侵犯BZOJ 1076 [SCOI 2008] 奖励关BZOJ 2761 [JLOI 2011] 不重复数字BZOJ 1085 [SCOI 2005] 骑士精神BZOJ 1503 [NOI 2004] 郁闷的出纳员BZOJ 1067 [SCOI 2007] 降雨量BZOJ 2321 [Beijing 2011 集训] 星器BZOJ 1834 [ZJOI 2010] 网络扩容BZOJ 1798 [AHOI 2009] 维护序列BZOJ 1934 [SHOI 2007] 善意的投票BZOJ 1066 [SCOI 2007] 蜥蜴BZOJ 1015 [JSOI 2008] 星球大战BZOJ 1877 [SDOI 2009] 晨跑BZOJ 1007 [HNOI 2008] 水平可见直线BZOJ 1497 [NOI 2006] 最大获利BZOJ 3041 水叮当的舞步BZOJ 3224 [TYVJ 1728] 普通平衡树BZOJ 1862 [ZJOI 2006] 游戏排名系统BZOJ 1056 [HAOI 2008] 排名系统BZOJ 1040 [ZJOI 2008] 骑士BZOJ 1054 [HAOI 2008] 移动玩具BZOJ 1208 [HNOI 2004] 宠物收养所BZOJ 2875 [NOI 2012] 随机数生成器BZOJ 2330 [SCOI 2011] 糖果BZOJ 1818 [CQOI 2010] 内部白点BZOJ 3098 Hash Killer IIBZOJ 1189 [HNOI 2007] 紧急疏散BZOJ 1079 [SCOI 2008] 着色方案BZOJ 1068 [SCOI 2007] 压缩BZOJ 1090 [SCOI 2003] 字符串折叠BZOJ 3245 最快路线BZOJ 1227 [SDOI 2009] 虔诚的墓主人BZOJ 1022 [SHOI 2008] 小约翰的游戏BZOJ 1188 [HNOI 2007] 分裂游戏BZOJ 1088 [SCOI 2005] 扫雷BZOJ 1013 [JSOI 2008] 球形空间产生器BZOJ 1305 [CQOI 2009] 跳舞BZOJ 2064 分裂BZOJ 1263 [SCOI 2006] 整数划分BZOJ 1221 [HNOI 2001] 软件开发BZOJ 1412 [ZJOI 2009] 狼和羊的故事BZOJ 2424 [HAOI 2010] 订货BZOJ 3211 花神游历各国BZOJ 3171 [TJOI 2013] 循环格BZOJ 2190 [SDOI 2008] 仪仗队BZOJ 1010 [HNOI 2008] 玩具装箱BZOJ 1982 [SPOJ 2021] Moving PebblesBZOJ 1345 [Baltic 2007] 序列问题BZOJ 1477 青蛙的约会BZOJ 2178 圆的面积并BZOJ 1299 [LLH 邀请赛] 巧克力棒BZOJ 1385 [Baltic 2000] Division ExpressionBZOJ 1614 [USACO 2007 Jan] Telephone Lines 架设电话线BZOJ 1230 [USACO 2008 Nov] Light Switching 开关灯BZOJ 3407 [USACO 2009 Oct] Bessie&apos;s Weight Problem 贝茜的体重问题BZOJ 1613 [USACO 2007 Jan] Running 贝茜的晨练计划BZOJ 1726 [USACO 2006 Nov] Roadblocks 第二短路BZOJ 3406 [USACO 2009 Oct] Invasion of the Milkweed 乳草的入侵BZOJ 3408 [USACO 2009 Oct] Heat Wave 热浪BZOJ 1475 方格取数BZOJ 1030 [JSOI 2007] 文本生成器BZOJ 1606 [USACO 2008 Dec] Hay for Sale 出售干草BZOJ 1222 [HNOI 2001] 产品加工BZOJ 2060 [USACO 2010 Nov] Visiting Cows 拜访奶牛BZOJ 2763 [JLOI 2011] 飞行路线BZOJ 1703 [USACO 2007 Mar] Ranking the Cows 奶牛排名BZOJ 1725 [USACO 2006 Nov] Corn Fields 牧场的安排BZOJ 1709 [USACO 2007 Oct] Super Paintball 超级弹珠BZOJ 1696 [USACO 2007 Feb] Building A New Barn 新牛舍BZOJ 2241 [SDOI 2011] 打地鼠BZOJ 1433 [ZJOI 2009] 假期的宿舍BZOJ 2456 modeBZOJ 1113 [POI 2008] 海报BZOJ 3409 [USACO 2009 Oct] Barn Echoes 牛棚回声BZOJ 1618 [USACO 2008 Nov] Buying Hay 购买干草BZOJ 1625 [USACO 2007 Dec] 宝石手镯BZOJ 1724 [USACO 2006 Nov] Fence Repair 切割木板BZOJ 1756 [Vijos 1083] 小白逛公园BZOJ 1609 [USACO 2008 Feb] Eating Together 麻烦的聚餐BZOJ 1699 [USACO 2007 Jan] Balanced Lineup 排队BZOJ 1666 [USACO 2006 Oct] Another Cow Number Game 牛奶的数字游戏BZOJ 1708 [USACO 2007 Oct] Money 奶牛的硬币BZOJ 1572 [USACO 2009 Open] 工作安排BZOJ 1571 [USACO 2009 Open] 滑雪课BZOJ 2132 圈地计划BZOJ 2127 Happiness 刷题顺序 (Q2 2014，题目数量 170+):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178BZOJ 1468 TreeBZOJ 2292 [POJ Challenge] 永远挑战BZOJ 2287 [POJ Challenge] 消失之物BZOJ 1430 小猴打架BZOJ 2252 [Beijing 2010 WC] 矩阵距离BZOJ 1968 [AHOI 2005] 约数研究BZOJ 1691 [USACO 2007 Dec] 挑剔的美食家BZOJ 1635 [USACO 2007 Jan] Tallest Cow 最高的奶牛BZOJ 1616 [USACO 2008 Mar] Cow Travelling 游荡的奶牛BZOJ 1624 [USACO 2008 Open] Clear and Present Danger 寻宝之路BZOJ 1648 [USACO 2006 Dec] Cow Picnic 奶牛野餐BZOJ 1620 [USACO 2008 Nov] Time Management 时间管理BZOJ 1232 [USACO 2008 Nov] 安慰奶牛BZOJ 1121 [POI 2008] 激光发射器BZOJ 1599 [USACO 2008 Oct] 笨重的石子BZOJ 1660 [USACO 2006 Nov] Bad Hair Day 乱发节BZOJ 1669 [USACO 2006 Oct] Hungry Cows 饥饿的奶牛BZOJ 1611 [USACO 2008 Feb] Meteor Shower 流星雨BZOJ 1602 [USACO 2008 Oct] 牧场行走BZOJ 1036 [ZJOI 2008] 树的统计BZOJ 2243 [SDOI 2011] 染色BZOJ 1455 罗马游戏BZOJ 1677 [USACO 2005 Jan] Sumsets 求和BZOJ 1251 序列终结者BZOJ 1657 [USACO 2006 Mar] Mooo 奶牛的歌声BZOJ 1579 [USACO 2009 Feb] Revamping Trails 道路升级BZOJ 1610 [USACO 2008 Feb] Line 连线游戏BZOJ 1646 [USACO 2007 Open] Catch that Cow 抓住那只牛BZOJ 1687 [USACO 2005 Open] Navigating the City 城市交通BZOJ 3170 [TJOI 2013] 松鼠聚会BZOJ 3390 [USACO 2004 Dec] Bad Cowtractors 牛的报复BZOJ 2463 [中山市选 2009] 谁能赢呢BZOJ 1621 [USACO 2008 Open] Roads Around the Farm 分叉路口BZOJ 1441 MinBZOJ 1816 [CQOI 2010] 扑克牌BZOJ 1465 糖果传递BZOJ 1641 [USACO 2007 Nov] Cow Hurdles 奶牛跨栏BZOJ 1639 [USACO 2007 Mar] Monthly Expense 月度开支BZOJ 1739 [USACO 2005 Mar] Space Elevator 太空电梯BZOJ 1652 [USACO 2006 Feb] Treats for the CowsBZOJ 1689 [USACO 2005 Open] Muddy Roads 泥泞的路BZOJ 1671 [USACO 2005 Dec] Knights of Ni 骑士BZOJ 1045 [HAOI 2008] 糖果传递BZOJ 3524 [POI 2014] CouriersBZOJ 3196 [TYVJ 1730] 二逼平衡树BZOJ 1033 [ZJOI 2008] 杀蚂蚁BZOJ 3223 [TYVJ 1729] 文艺平衡树BZOJ 1874 [Beijing 2009 WC] 取石子游戏BZOJ 1972 [SDOI 2010] 猪国杀BZOJ 1901 [ZJU 2112] Dynamic RankingsBZOJ 1482 可以看到的树BZOJ 2038 [国家集训队 2009] 小 Z 的袜子BZOJ 2396 神奇的矩阵BZOJ 1858 [SCOI 2010] 序列操作BZOJ 2768 [JLOI 2010] 冠军调查BZOJ 1500 [NOI 2005] 维修数列BZOJ 2748 [HAOI 2012] 音量调节BZOJ 3212 [PKU 3468] A Simple Problem with IntegersBZOJ 1483 [HNOI 2009] 梦幻布丁BZOJ 1426 收集邮票BZOJ 3275 NumberBZOJ 1863 [ZJOI 2006] 皇帝的烦恼BZOJ 1070 [SCOI 2007] 修车BZOJ 2879 [NOI 2012] 美食节BZOJ 1207 [HNOI 2004] 打鼹鼠BZOJ 1432 [ZJOI 2009] FunctionBZOJ 1031 [JSOI 2007] 字符加密BZOJ 1593 [USACO 2008 Feb] Hotel 旅馆BZOJ 1037 [ZJOI 2008] 生日聚会BZOJ 2288 [POJ Challenge] 生日礼物BZOJ 1150 [CTSC 2007] 数据备份BZOJ 1787 [AHOI 2008] 紧急集合BZOJ 2697 特技飞行BZOJ 3293 [CQOI 2011] 分金币BZOJ 3280 小 R 的烦恼BZOJ 1800 [AHOI 2009] 飞行棋BZOJ 1854 [SCOI 2010] 游戏BZOJ 1009 [HNOI 2008] GT 考试BZOJ 1458 士兵占领BZOJ 1293 [SCOI 2009] 生日礼物BZOJ 1016 [JSOI 2008] 最小生成树计数BZOJ 1878 [SDOI 2009] HH 的项链BZOJ 1116 [POI 2008] CLOBZOJ 1115 [POI 2009] 石子游戏BZOJ 1755 [USACO 2005 Qua] Bank InterestBZOJ 2743 [HEOI 2012] 采花BZOJ 2208 [JSOI 2010] 连通数BZOJ 3505 [CQOI 2014] 数三角形BZOJ 1876 [SDOI 2009] SuperGCDBZOJ 2318 [SPOJ 4060] Game with Probability ProblemBZOJ 1603 [USACO 2008 Oct] 打谷机BZOJ 3339 RMQ ProblemBZOJ 1898 [ZJOI 2005] 沼泽鳄鱼BZOJ 1529 [POI 2005] Piggy BanksBZOJ 1597 [USACO 2008 Mar] 土地购买BZOJ 1911 [APIO 2010] 特别行动队BZOJ 1096 [ZJOI 2007] 仓库建设BZOJ 2429 [HAOI 2006] 聪明的猴子BZOJ 3585 MexBZOJ 1782 [USACO 2010 Feb] Slowdown 慢慢游BZOJ 1231 [USACO 2008 Nov] Mixup2 混乱的奶牛BZOJ 1827 [USACO 2010 Mar] Gather 奶牛大集会BZOJ 1690 [USACO 2007 Dec] 奶牛的旅行BZOJ 1717 [USACO 2006 Dec] Milk Patterns 产奶的模式BZOJ 1668 [USACO 2006 Oct] Cow Pie Treasures 馅饼里的财富BZOJ 1711 [USACO 2007 Open] Dining 吃饭BZOJ 1233 [USACO 2009 Open] 干草堆BZOJ 1296 [SCOI 2009] 粉刷匠BZOJ 1337 最小圆覆盖BZOJ 1336 [Balkan 2002] Alien 最小圆覆盖BZOJ 1260 [CQOI 2007] 涂色BZOJ 1053 [HAOI 2007] 反素数BZOJ 1600 [USACO 2008 Oct] 建造栅栏BZOJ 1617 [USACO 2008 Mar] River Crossing 渡河问题BZOJ 1612 [USACO 2008 Jan] Cow Contest 奶牛的比赛BZOJ 1607 [USACO 2008 Dec] Patting Heads 轻拍牛头BZOJ 1626 [USACO 2007 Dec] Building Roads 修建道路BZOJ 1679 [USACO 2005 Jan] Moo Volume 奶牛的呼声BZOJ 1631 [USACO 2007 Feb] Cow Party 奶牛聚会BZOJ 1636 [USACO 2007 Jan] Balanced LineupBZOJ 1642 [USACO 2007 Nov] Milking Time 挤奶时间BZOJ 1627 [USACO 2007 Dec] 穿越泥地BZOJ 1629 [USACO 2007 Demo] Cow AcrobatsBZOJ 1634 [USACO 2007 Jan] Protecting the Flowers 护花BZOJ 2442 [USACO 2011 Open] 修剪草坪BZOJ 1715 [USACO 2006 Dec] Wormholes 虫洞BZOJ 1797 [AHOI 2009] Mincut 最小割BZOJ 1004 [HNOI 2008] CardsBZOJ 1898 [ZJOI 2005] Swamp 沼泽鳄鱼BZOJ 1028 [JSOI 2007] 麻将BZOJ 1196 [HNOI 2006] 公路修建问题BZOJ 1112 [POI 2008] 砖块BZOJ 1828 [USACO 2010 Mar] 农场分配BZOJ 1707 [USACO 2007 Nov] Tanning 分配防晒霜BZOJ 1651 [USACO 2006 Feb] Stall Reservations 专用牛棚BZOJ 2506 CalcBZOJ 1537 [POI 2005] The BusBZOJ 1452 [JSOI 2009] CountBZOJ 3155 Preprefix SumBZOJ 2388 旅行规划BZOJ 1592 [USACO 2008 Feb] Making the Grade 路面修整BZOJ 1211 [HNOI 2004] 树的计数BZOJ 1005 [HNOI 2008] 明明的烦恼BZOJ 1061 [NOI 2008] 志愿者招募BZOJ 1407 [NOI 2002] SavageBZOJ 1408 [NOI 2002] RobotBZOJ 1726 [USACO 2006 Nov] Roadblocks 次短路BZOJ 1589 [USACO 2008 Dec] Trick or Treat on the Farm 采集糖果BZOJ 2661 [Beijing 2012 WC] 连连看BZOJ 1359 [Baltic 209] CandyBZOJ 3056 升降梯口BZOJ 2510 弱题BZOJ 1801 [AHOI 2009] 中国象棋BZOJ 2391 Cirno 的忧郁BZOJ 3531 [SDOI 2014] 旅行BZOJ 1146 [CTSC 2008] 网络管理BZOJ 3262 陌上花开BZOJ 1468 TreeBZOJ 1103 [POI 2007] 大都市BZOJ 2818 GCDBZOJ 1532 [POI 2005] DicingBZOJ 1705 [SDOI 2012] Longge 的问题BZOJ 3156 防御准备BZOJ 1179 [APIO 2009] ATMBZOJ 3632 外太空旅行BZOJ 2005 [NOI 2010] 能量采集BZOJ 2588 [SPOJ 10628] Count on a treeBZOJ 3295 [CQOI 2011] 动态逆序对BZOJ 2055 80 人环游世界BZOJ 2502 清理雪道BZOJ 1006 [HNOI 2008] 神奇的国度BZOJ 1026 [SCOI 2009] Windy 数BZOJ 1381 [Baltic 2001] KnightsBZOJ 2002 [HNOI 2010] Bounce 弹飞绵羊BZOJ 1492 [NOI 2007] 货币兑换BZOJ 2430 [POI 2003] ChocolateBZOJ 3504 [CQOI 2014] 危桥BZOJ 3538 [USACO 2014 Open] Dueling GPS 刷题顺序 (Q3 2014，题目数量 190+):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194BZOJ 1408 [NOI 2002] RobotBZOJ 1726 [USACO 2006 Nov] Roadblocks 第二短路BZOJ 1589 [USACO 2008 Dec] Trick or Treat on the Farm 采集糖果BZOJ 2661 [Beijing WC 2012] 连连看BZOJ 1359 [Baltic 209] CandyBZOJ 3056 升降梯口BZOJ 2510 弱题BZOJ 1801 [AHOI 2009] Chess 中国象棋BZOJ 2391 Cirno 的忧郁BZOJ 3531 [SDOI 2014] 旅行BZOJ 1146 [CTSC 2008] 网络管理 NetworkBZOJ 2396 神奇的矩阵BZOJ 3262 陌上花开BZOJ 1468 TreeBZOJ 1103 [POI 2007] 大都市 megBZOJ 2818 GcdBZOJ 1532 [POI 2005] Kos-DicingBZOJ 2705 [SDOI 2012] Longge 的问题BZOJ 3156 防御准备BZOJ 1179 [APIO 2009] AtmBZOJ 3632 外太空旅行BZOJ 2005 [NOI 2010] 能量采集BZOJ 2588 [SPOJ 10628] Count on a treeBZOJ 3295 [CQOI 2011] 动态逆序对BZOJ 2055 八十人环游世界BZOJ 2502 清理雪道BZOJ 1006 [HNOI 2008] 神奇的国度BZOJ 1026 [SCOI 2009] Windy 数BZOJ 1381 [Baltic 2001] KnightsBZOJ 2002 [HNOI 2010] Bounce 弹飞绵羊BZOJ 1492 [NOI 2007] 货币兑换 CashBZOJ 2430 [POI 2003] ChocolateBZOJ 3504 [CQOI 2014] 危桥BZOJ 3538 [USACO 2014 Open] Dueling GPSBZOJ 1656 [USACO 2006 Jan] The Grove 树木BZOJ 1619 [USACO 2008 Nov] Guarding the Farm 保卫牧场BZOJ 3399 [USACO 2009 Mar] Sand Castle 城堡BZOJ 2724 [Violet 6] 蒲公英BZOJ 1640 [USACO 2007 Nov] Best Cow Line 队列变换BZOJ 1692 [USACO 2007 Dec] 队列变换BZOJ 1596 [USACO 2008 Jan] 电话网络BZOJ 1574 [USACO 2009 Jan] 地震损坏 DamageBZOJ 1754 [USACO 2005 Qua] Bull MathBZOJ 1753 [USACO 2005 Qua] Who&apos;s in the MiddleBZOJ 3396 [USACO 2009 Jan] Total flow 水流BZOJ 1806 [IOI 2007] Miners 矿工配餐BZOJ 2821 作诗 PoetizeBZOJ 2561 最小生成树BZOJ 2179 FFT 快速傅立叶BZOJ 1925 [SDOI 2010] 地精部落BZOJ 2173 整数的 LQP 拆分BZOJ 1251 序列终结者BZOJ 1500 [NOI 2005] 维修数列BZOJ 1682 [USACO 2005 Mar] Out of Hay 干草危机BZOJ 1688 [USACO 2005 Open] Disease Manangement 疾病管理BZOJ 1637 [USACO 2007 Mar] Balanced LineupBZOJ 1615 [USACO 2008 Mar] The Loathesome Hay Baler 麻烦的干草打包机BZOJ 1628 [USACO 2007 Demo] City skylineBZOJ 1650 [USACO 2006 Dec] River Hopscotch 跳石子BZOJ 1643 [USACO 2007 Oct] Bessie&apos;s Secret Pasture 贝茜的秘密草坪BZOJ 1653 [USACO 2006 Feb] Backward Digit SumsBZOJ 1011 [HNOI 2008] 遥远的行星BZOJ 1633 [USACO 2007 Feb] The Cow Lexicon 牛的词典BZOJ 1649 [USACO 2006 Dec] Cow Roller CoasterBZOJ 2201 彩色圆环BZOJ 2141 排队BZOJ 2325 [ZJOI 2011] 道馆之战BZOJ 1638 [USACO 2007 Mar] Cow Traffic 奶牛交通BZOJ 1623 [USACO 2008 Open] Cow Cars 奶牛飞车BZOJ 1644 [USACO 2007 Oct] Obstacle Course 障碍训练课BZOJ 3668 [NOI 2014] 起床困难综合症BZOJ 3626 [LNOI2014] LCABZOJ 3671 [NOI 2014] 随机数生成器BZOJ 1500 [NOI 2005] 维修数列BZOJ 2002 [HNOI 2010] Bounce 弹飞绵羊BZOJ 1507 [NOI 2003] EditorBZOJ 1493 [NOI 2007] 项链工厂BZOJ 3669 [NOI 2014] 魔法森林BZOJ 3671 [NOI 2014] 随机数生成器BZOJ 3278 ⑨ (Nine)BZOJ 1751 [USACO 2005 Qua] Lake CountingBZOJ 1752 [USACO 2005 Qua] Til the Cows Come HomeBZOJ 3545 [ONTAK 2010] PeaksBZOJ 3299 [USACO 2011 Open] Corn Maze 玉米迷宫BZOJ 1683 [USACO 2005 Nov] City skyline 城市天际线BZOJ 1664 [USACO 2006 Open] County Fair Events 参加节日庆祝BZOJ 1672 [USACO 2005 Dec] Cleaning Shifts 清理牛棚BZOJ 1645 [USACO 2007 Open] City Horizon 城市地平线BZOJ 1622 [USACO 2008 Open] Word Power 名字的能量BZOJ 2020 [USACO 2010 Jan] Buying Feed, IIBZOJ 2101 [USACO 2010 Dec] Treasure Chest 藏宝箱BZOJ 1349 [Baltic 2006] SquintBZOJ 1684 [USACO 2005 Oct] Close EncounterBZOJ 3626 [LNOI 2014] LCABZOJ 2015 [USACO 2010 Feb] Chocolate GivingBZOJ 1673 [USACO 2005 Dec] Scales 天平BZOJ 2100 [USACO 2010 Dec] Apple DeliveryBZOJ 1697 [USACO 2007 Feb] Cow Sorting 牛排序BZOJ 1710 [USACO 2007 Open] Cheappal 廉价回文BZOJ 1584 [USACO 2009 Mar] Cleaning Up 打扫卫生BZOJ 2049 [SDOI 2008] Cave 洞穴勘测BZOJ 2733 [HNOI 2012] 永无乡BZOJ 3673 可持久化并查集 by zkyBZOJ 1864 [ZJOI 2006] 三色二叉树BZOJ 1861 [ZJOI 2006] Book 书架BZOJ 1674 [USACO 2005] Part AcquisitionBZOJ 1685 [USACO 2005 Oct] Allowance 津贴BZOJ 1269 [AHOI 2006] 文本编辑器 EditorBZOJ 2304 [APIO 2011] 寻路BZOJ 2346 [Baltic 2011] LampBZOJ 2548 [CTSC 2002] 灭鼠行动BZOJ 1935 [SHOI 2007] Tree 园丁的烦恼BZOJ 1576 [USACO 2009 Jan] 安全路经 TravelBZOJ 2631 TreeBZOJ 1014 [JSOI 2008] 火星人 PrefixBZOJ 3000 Big NumberBZOJ 2594 [WC 2006] 水管局长数据加强版BZOJ 1029 [JSOI 2007] 建筑抢修BZOJ 3040 最短路 (Road)BZOJ 1907 树的路径覆盖BZOJ 3192 [JLOI 2013] 删除物品BZOJ 2662 [Beijing WC 2012] 冻结BZOJ 1058 [ZJOI 2007] 报表统计BZOJ 3629 [JLOI 2014] 聪明的燕姿BZOJ 1046 [HAOI 2007] 上升序列BZOJ 3032 七夕祭BZOJ 3033 太鼓达人BZOJ 3680 吊打 XXXBZOJ 2212 [POI 2011] Tree RotationsBZOJ 2982 CombinationBZOJ 1324 Exca王者之剑BZOJ 3551 [ONTAK 2010] Peaks 加强版BZOJ 1024 [SCOI 2009] 生日快乐BZOJ 1257 [CQOI 2007] 余数之和 SumBZOJ 1047 [HAOI 2007] 理想的正方形BZOJ 2301 [HAOI 2011] Problem BBZOJ 1101 [POI 2007] ZapBZOJ 1034 [ZJOI 2008] 泡泡堂 BNBBZOJ 1044 [HAOI 2008] 木棍分割BZOJ 1069 [SCOI 2007] 最大土地面积BZOJ 3693 圆桌会议BZOJ 3694 最短路BZOJ 3688 折线统计BZOJ 3689 异或之BZOJ 2783 [JLOI 2012] 树BZOJ 3695 滑行BZOJ 2251 [Beijing 2010 WC] 外星联络BZOJ 1647 [USACO 2007 Open] Fliptile 翻格子游戏BZOJ 3704 昊昊的机油之 GRSTBZOJ 3702 二叉树BZOJ 3698 XWW 的难题BZOJ 1655 [USACO 2006 Jan] Dollar Dayz 奶牛商店BZOJ 2719 [Violet 4] 银河之星BZOJ 3707 圈地BZOJ 1468 TreeBZOJ 2152 聪聪可可BZOJ 2599 [IOI 2011] RaceBZOJ 3479 [USACO 2014 Mar] Watering the FieldsBZOJ 3685 普通 van Emde Boas 树BZOJ 1123 [POI 2008] BLOBZOJ 1307 玩具BZOJ 1318 [SPOJ 744] Longest PermutationBZOJ 3029 守卫者的挑战BZOJ 1552 [CERC 2007] Robotic SortBZOJ 3506 [CQOI 2014] 排序机械臂BZOJ 3391 [USACO 2004 Dec] Tree Cutting 网络破坏BZOJ 3401 [USACO 2009 Mar] Look Up 仰望BZOJ 3403 [USACO 2009 Open] Cow Line 直线上的牛BZOJ 3514 [Codechef MAR 14] GERALD07 加强版BZOJ 1604 [USACO 2008 Open] Cow Neighborhoods 奶牛的邻居BZOJ 2364 城市美化BZOJ 1025 [SCOI 2009] 游戏BZOJ 3713 [PA 2014] IloczynBZOJ 1670 [USACO 2006 Oct] Building the Moat 护城河的挖掘BZOJ 3709 [PA 2014] BohaterBZOJ 3715 [PA 2014] LustraBZOJ 1951 [SDOI 2010] 古代猪文BZOJ 3687 简单题BZOJ 1271 [Beijing WC 2008] 秦腾与教学评估BZOJ 3282 TreeBZOJ 2102 [USACO 2010 Dec] The Trough GameBZOJ 1057 [ZJOI 2007] 棋盘制作BZOJ 1927 [SDOI 2010] 星际竞速BZOJ 3706 反色刷BZOJ 2555 SubStringBZOJ 3631 [JLOI 2014] 松鼠的新家BZOJ 3402 [USACO 2009 Open] Hide and Seek 捉迷藏BZOJ 3697 采药人的路径BZOJ 3540 [USACO 2014 Open] Fair PhotographyBZOJ 3714 [PA 2014] KuglarzBZOJ 2006 [NOI 2010] 超级钢琴BZOJ 3410 [USACO 2009 Dec] Selfish Grazing 自私的食草者BZOJ 3412 [USACO 2009 Dec] Music Notes 乐谱BZOJ 3065 带插入区间 K 小值 刷题顺序 (Q4 2014，题目数量 180+):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181BZOJ 3398 [USACO 2009 Feb] Bullcow 牡牛和牝牛BZOJ 3389 [USACO 2004 Dec] Cleaning Shifts 安排值班BZOJ 3297 [USACO 2011 Open] ForgotBZOJ 1391 [CEOI 2008] OrderBZOJ 1598 [USACO 2008 Mar] 牛跑步BZOJ 1770 [USACO 2009 Nov] Lights 灯BZOJ 1857 [SCOI 2010] 传送带BZOJ 3433 [USACO 2014 Jan] Recording the MoolympicsBZOJ 1630 [USACO 2007 Demo] Ant CountingBZOJ 2023 [USACO 2005 Nov] Ant Counting 数蚂蚁BZOJ 1632 [USACO 2007 Feb] Lilypad PondBZOJ 1098 [POI 2007] 办公楼 BiuBZOJ 1093 [ZJOI 2007] 最大半连通子图BZOJ 3110 [ZJOI 2013] K 大数查询BZOJ 1833 [ZJOI 2010] Count 数字计数BZOJ 2324 [ZJOI 2011] 营救皮卡丘BZOJ 1072 [SCOI 2007] 排列 PermutationBZOJ 1023 [SHOI 2008] Cactus 仙人掌图BZOJ 1108 [POI 2007] 天然气管道 GazBZOJ 1106 [POI 2007] 立方体大作战 TetBZOJ 1132 [POI 2008] TroBZOJ 1131 [POI 2008] StaBZOJ 1119 [POI 2009] SLOBZOJ 1135 [POI 2009] LyzBZOJ 1038 [ZJOI 2008] 瞭望塔BZOJ 2618 [CQOI 2006] 凸多边形BZOJ 1102 [POI 2007] 山峰和山谷 GrzBZOJ 1097 [POI 2007] 旅游景点 AtrBZOJ 2079 [POI 2010] GuildsBZOJ 2091 [POI 2010] The Minima GameBZOJ 1110 [POI 2007] 砝码 OdwBZOJ 1520 [POI 2006] Szk-SchoolsBZOJ 2014 [USACO 2010 Feb] Chocolate BuyingBZOJ 2016 [USACO 2010] Chocolate EatingBZOJ 2144 跳跳棋BZOJ 2143 飞飞侠BZOJ 2145 悄悄话BZOJ 2708 [Violet 1] 木偶BZOJ 2709 [Violet 1] 迷宫花园BZOJ 1914 [USACO 2010 Open] Triangle Counting 数三角形BZOJ 1705 [USACO 2007 Nov] Telephone Wire 架设电话线BZOJ 1665 [USACO 2006 Open] The Climbing Wall 攀岩BZOJ 3251 树上三角形BZOJ 3417 [POI 2013] Tales of SeafaringBZOJ 3431 [USACO 2014 Jan] Bessie Slows DownBZOJ 3721 [PA 2014] Final BazarekBZOJ 2789 [POI 2012] LettersBZOJ 3555 [CTSC 2014] 企鹅 QQBZOJ 3436 小 K 的农场BZOJ 1978 [Beijing 2010] 取数游戏 GameBZOJ 2659 [Beijing WC 2012] 算不出的算式BZOJ 1193 [HNOI 2006] 马步距离BZOJ 2734 [HNOI 2012] 集合选数BZOJ 2730 [HNOI 2012] 矿场搭建BZOJ 1567 [JSOI 2008] Blue Mary 的战役地图BZOJ 1086 [SCOI 2005] 王室联邦BZOJ 1089 [SCOI 2003] 严格 n 元树BZOJ 1555 KD 之死BZOJ 1556 墓地秘密BZOJ 3751 [NOIP 2014] 解方程BZOJ 3427 [POI 2013] Byte ComputerBZOJ 1017 [JSOI 2008] 魔兽地图 DotRBZOJ 3043 IncDec SequenceBZOJ 3252 攻略BZOJ 3226 [SDOI 2008] 校门外的区间BZOJ 2259 [OIBH] 新型计算机BZOJ 3437 小 P 的牧场BZOJ 2405 数字BZOJ 2216 [POI 2011] Lightning ConductorBZOJ 1563 [NOI 2009] 诗人小 GBZOJ 2793 [POI 2012] VouchersBZOJ 2096 [POI 2010] PilotsBZOJ 3781 小 B 的询问BZOJ 2407 探险BZOJ 2276 [POI 2011] TemperatureBZOJ 1095 [ZJOI 2007] Hide 捉迷藏BZOJ 3757 苹果树BZOJ 3052 [WC 2013] 糖果公园BZOJ 1042 [HAOI 2008] 硬币购物BZOJ 1043 [HAOI 2008] 下落的圆盘BZOJ 1060 [ZJOI 2007] 时态同步BZOJ 1048 [HAOI 2007] 分割矩阵BZOJ 1049 [HAOI 2006] 数字序列BZOJ 1052 [HAOI 2007] 覆盖问题BZOJ 1055 [HAOI 2008] 玩具取名BZOJ 2298 [HAOI 2011] Problem ABZOJ 2300 [HAOI 2011] 防线修建BZOJ 2428 [HAOI 2006] 均分数据BZOJ 1145 [CTSC 2008] 图腾 TotemBZOJ 3100 排列BZOJ 1758 [WC 2010] 重建计划BZOJ 3289 Mato的文件管理BZOJ 3761 ZhenhuanBZOJ 1398 [Vijos 1382] 寻找主人 NecklaceBZOJ 2223 [COCI 2009] PATULJCIBZOJ 3769 [SPOJ 8549] BST againBZOJ 2342 [SHOI 2011] 双倍回文BZOJ 2732 [HNOI 2012] 射箭BZOJ 1216 [HNOI 2003] 操作系统BZOJ 1528 [POI 2005] Sam-Toy CarsBZOJ 2938 [POI 2000] 病毒BZOJ 2434 [NOI 2011] 阿狸的打字机BZOJ 2802 [POI 2012] Warehouse StoreBZOJ 3784 树上的路径BZOJ 3770 疯狂的限制BZOJ 3653 谈笑风生BZOJ 2819 NimBZOJ 2656 [ZJOI 2012] 数列 (Sequence)BZOJ 2751 [HAOI 2012] 容易题 (Easy)BZOJ 3174 [TJOI 2013] 拯救小矮人BZOJ 1027 [JSOI 2007] 合金BZOJ 2929 [POI 1999] 洞穴攀行BZOJ 3172 [TJOI 2013] 单词BZOJ 2165 大楼BZOJ 2716 [Violet 3] 天使玩偶BZOJ 2648 SJY 摆棋子BZOJ 2435 [NOI 2011] 道路修建BZOJ 3306 树BZOJ 3790 神奇项链BZOJ 2929 [POI 1999] 洞穴攀行BZOJ 2165 大楼BZOJ 1036 [ZJOI 2008] 树的统计 CountBZOJ 2115 [WC 2011] XorBZOJ 2006 [NOI 2010] 超级钢琴BZOJ 1487 [HNOI 2009] 无归岛BZOJ 2427 [HAOI 2010] 软件安装BZOJ 1226 [SDOI 2009] 学校食堂 DiningBZOJ 1355 [Baltic 2009] Radio TransmissionBZOJ 1823 [JSOI 2010] 满汉全席BZOJ 2348 [Baltic 2011] PlagiarismBZOJ 1822 [JSOI 2010] Frozen Nova 冷冻波BZOJ 2882 工艺BZOJ 3158 千钧一发BZOJ 3791 作业BZOJ 1954 [POJ 3764] The Xor-Longest PathBZOJ 3261 最大异或和BZOJ 2763 [JLOI 2011] 飞行路线BZOJ 1923 [SDOI 2010] 外星千足虫BZOJ 2431 [HAOI 2009] 逆序对数列BZOJ 1334 [Baltic 2008] ElectBZOJ 3767 A+B Problem 加强版BZOJ 3732 NetworkBZOJ 2893 征服王BZOJ 2007 [NOI 2010] 海拔BZOJ 2299 [HAOI 2011] 向量BZOJ 1565 [NOI 2009] 植物大战僵尸BZOJ 1566 [NOI 2009] 管道取珠BZOJ 1367 [Baltic 2004] SequenceBZOJ 2809 [APIO 2012] DispatchingBZOJ 1924 [SDOI 2010] 所驼门王的宝藏BZOJ 3166 [HEOI 2013] AloBZOJ 3674 可持久化并查集加强版BZOJ 2199 [USACO 2011 Jan] 奶牛议会BZOJ 3750 [POI 2015] PieczęćBZOJ 3747 [POI 2015] KinomanBZOJ 2595 [WC 2008] 游览计划BZOJ 3105 [CQOI 2013] 新 Nim 游戏BZOJ 1449 [JSOI 2009] 球队收益BZOJ 2895 球队预算BZOJ 3809 Gty 的傻妹子序列BZOJ 2721 [Violet 5] 樱花BZOJ 2282 [SDOI 2011] 消防BZOJ 2718 [Violet 4] 毕业旅行BZOJ 1143 [CTSC 2008] 祭祀 RiverBZOJ 2281 [SDOI 2011] 黑白棋BZOJ 1922 [SDOI 2010] 大陆争霸BZOJ 1486 [HNOI 2009] 最小圈BZOJ 1485 [HNOI 2009] 有趣的数列BZOJ 2822 [AHOI 2012] 树屋阶梯BZOJ 2333 [SCOI 2011] 棘手的操作BZOJ 1078 [SCOI 2008] 斜堆BZOJ 1082 [SCOI 2005] 栅栏BZOJ 1185 [HNOI 2007] 最小矩形覆盖BZOJ 3190 [JLOI 2013] 赛车BZOJ 2400 [SPOJ 839] Optimal MarksBZOJ 2282 [SDOI 2011] 消防BZOJ 2186 [SDOI 2008] 沙拉公主的困惑BZOJ 2242 [SDOI 2011] 计算器BZOJ 2823 [AHOI 2012] 信号塔BZOJ 2438 [中山市选 2011] 杀人游戏BZOJ 1965 [AHOI 2005] SHUFFLE 洗牌 刷题顺序 (Q1 2015，题目数量 50+):1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556BZOJ 2756 [SCOI 2012] 奇怪的游戏BZOJ 1176 [Balkan 2007] MokiaBZOJ 3696 化合物BZOJ 1367 [Baltic 2004] SequenceBZOJ 1468 TreeBZOJ 3648 寝室管理BZOJ 2527 [POI 2011] MeteorsBZOJ 2738 矩阵乘法BZOJ 3105 [CQOI 2013] 新 Nim 游戏BZOJ 2460 [Beijing 2011] 元素BZOJ 2151 种树BZOJ 2389 XY 的赛车场BZOJ 2956 模积和BZOJ 3239 Discrete LoggingBZOJ 2820 YY 的 GCDBZOJ 3529 [SDOI 2014] 数表BZOJ 2754 [SCOI 2012] 喵星球上的点名BZOJ 2286 [SDOI 2011] 消耗战BZOJ 3856 MonsterBZOJ 3611 [HEOI 2014] 大工程BZOJ 1370 [Baltic 2003] Gang 团伙BZOJ 2073 [POI 2004] PRZBZOJ 3813 奇数国BZOJ 3876 [AHOI &amp; JSOI 2014] 支线剧情BZOJ 3772 精神污染BZOJ 3162 独钓寒江雪BZOJ 2229 [ZJOI 2011] 最小割BZOJ 3173 [TJOI 2013] 最长上升子序列BZOJ 1997 [HNOI 2010] PlanarBZOJ 2004 [HNOI 2010] Bus 公交线路BZOJ 1998 [HNOI 2010] Fsk 物品调度BZOJ 2815 [ZJOI 2012] 灾难BZOJ 3144 [HNOI 2013] 切糕BZOJ 1036 [ZJOI 2008] 树的统计 CountBZOJ 2829 信用卡凸包BZOJ 3270 博物馆BZOJ 2157 旅游BZOJ 1406 [AHOI 2007] 密码箱BZOJ 3667 Rabin-Miller 算法BZOJ 1369 [Baltic 2003] GemBZOJ 3036 绿豆蛙的归宿BZOJ 3884 上帝与集合的正确用法BZOJ 3544 [ONTAK 2010] Creative AccountingBZOJ 3728 [PA 2014] Final ZarowkiBZOJ 1318 [SPOJ 744] Longest PermutationBZOJ 3100 排列BZOJ 2796 [POI 2012] Fibonacci RepresentationBZOJ 3907 网格BZOJ 2590 [USACO 2012 Feb] Cow CouponsBZOJ 2086 [POI 2010] BlocksBZOJ 3850 ZCC Loves CodefiresBZOJ 1283 序列BZOJ 3894 文理分科BZOJ 3208 花神的秒题计划ⅠBZOJ 1962 模型王子BZOJ 1875 [SDOI 2009] HH 去散步 刷题顺序 (Q2 2015，题目数量 110+):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110BZOJ 4048 [CERC 2014] Outer space invadersBZOJ 1706 [USACO 2007 Nov] relays 奶牛接力跑BZOJ 3955 [WF 2013] Surely You CongestBZOJ 3953 [WF 2013] Self-AssemblyBZOJ 3971 [WF 2013] МатрёшкаBZOJ 3928 [CERC 2014] Outer space invadersBZOJ 3967 [WF 2013] FactorsBZOJ 2210 [POJ 1379] Run AwayBZOJ 1844 [CERC 1999] Run AwayBZOJ 2258 [POJ 2758] Checking the Text 文本校对BZOJ 1417 [POJ 3156] InterconnectBZOJ 1908 [POJ 2054] Color a TreeBZOJ 2022 [POJ 1837] BalanceBZOJ 1338 [POJ 1981] Circle and Points 单位圆覆盖BZOJ 4057 [CERC 2012] KingdomsBZOJ 4052 [CERC 2013] Magical GCDBZOJ 4080 [WF 2014] Sensor NetworkBZOJ 4063 [CERC 2012] DartsBZOJ 3169 [CERC 2012] ConservationBZOJ 4082 [WF 2014] SurveillanceBZOJ 3972 [WF 2013] Pirate ChestBZOJ 1662 [USACO 2006 Nov] Round Numbers 圆环数BZOJ 2017 [USACO 2009 Nov] 硬币游戏BZOJ 1675 [USACO 2005 Feb] Rigging the Bovine Election 竞选划区BZOJ 1661 [USACO 2006 Nov] Big Square 巨大正方形BZOJ 1654 [USACO 2006 Jan] The Cow Prom 奶牛舞会BZOJ 4077 [WF 2014] MessengerBZOJ 3308 九月的咖啡店BZOJ 2661 [Beijing WC 2012] 连连看BZOJ 4135 [FJOI 2015] 世界树BZOJ 4137 [FJOI 2015] 火星商店问题BZOJ 1562 [NOI 2009] 变换序列BZOJ 1499 [NOI 2005] 瑰丽华尔兹BZOJ 1064 [NOI 2008] 假面舞会BZOJ 2876 [NOI 2012] 骑行川藏BZOJ 3240 [NOI 2013] 矩阵游戏BZOJ 3522 [POI 2014] HotelBZOJ 2084 [POI 2010] AntisymmetryBZOJ 2083 [POI 2010] Intelligence testBZOJ 2095 [POI 2010] BridgesBZOJ 2081 [POI 2010] BeadsBZOJ 1797 [AHOI 2009] Mincut 最小割BZOJ 3931 [CQOI 2015] 网络吞吐量BZOJ 3932 [CQOI 2015] 任务查询系统BZOJ 1177 [APIO 2009] OilBZOJ 1912 [APIO 2010] Patrol 巡逻BZOJ 1500 [NOI 2005] 维修数列BZOJ 2303 [APIO 2011] 方格染色BZOJ 3638 [CF-172] k-Maximum Subsequence SumBZOJ 3272 Zgg 吃东西BZOJ 2770 YY 的 TreapBZOJ 1913 [APIO 2010] Signaling 信号覆盖BZOJ 2957 楼房重建BZOJ 3991 [SDOI 2015] 寻宝游戏BZOJ 3675 [APIO 2014] 序列分割BZOJ 2555 SubStringBZOJ 4016 [FJOI 2014] 最短路径树问题BZOJ 2946 [POI 2000] 公共串BZOJ 3573 [HNOI 2014] 米特运输BZOJ 3572 [HNOI 2014] 世界树BZOJ 3998 [TJOI 2015] 弦论BZOJ 3997 [TJOI 2015] 组合数学BZOJ 3996 [TJOI 2015] 线性代数BZOJ 4010 [HNOI 2015] 菜肴制作BZOJ 4008 [HNOI 2015] 亚瑟王BZOJ 3207 花神的嘲讽计划ⅠBZOJ 3210 花神的浇花集会BZOJ 3990 [SDOI 2015] 排序BZOJ 4002 [JLOI 2015] 有意义的字符串BZOJ 3676 [APIO 2014] 回文串BZOJ 2811 [APIO 2012] GuardBZOJ 3624 [APIO 2008] 免费道路BZOJ 2154 Crash 的数字表格BZOJ 1478 [SGU 282] IsomorphismBZOJ 3700 发展城市BZOJ 1906 树上的蚂蚁BZOJ 3207 花神的嘲讽计划ⅠBZOJ 4027 [HEOI 2015] 兔子与樱花BZOJ 3206 [APIO 2013] 道路费用BZOJ 1513 [POI 2006] Tet-Tetris 3DBZOJ 1194 [HNOI 2006] 潘多拉的盒子BZOJ 4029 [HEOI 2015] 定价BZOJ 2179 FFT 快速傅立叶BZOJ 2194 快速傅立叶之二BZOJ 3527 [ZJOI 2014] 力BZOJ 2631 TreeBZOJ 1036 [ZJOI 2008] 树的统计 CountBZOJ 2282 [SDOI 2011] 消防BZOJ 4031 [HEOI2015] 小 Z 的房间BZOJ 4034 [HAOI2015] 树上操作BZOJ 3926 [ZJOI 2015] 诸神眷顾的幻想乡BZOJ 3924 [ZJOI 2015] 幻想乡战略游戏BZOJ 3160 万径人踪灭BZOJ 1941 [SDOI 2010] Hide and SeekBZOJ 2850 巧克力王国BZOJ 3122 [SDOI 2013] 随机数生成器BZOJ 2179 FFT 快速傅立叶BZOJ 4011 [HNOI 2015] 落忆枫音BZOJ 4067 [CTSC 2015] GenderBZOJ 4042 [CERC 2014] ParadesBZOJ 4050 [CERC 2014] WheelsBZOJ 4045 [CERC 2014] BricksBZOJ 4070 [APIO 2015] 雅加达的摩天楼BZOJ 1312 [NEERC 2006] Hard LifeBZOJ 2632 [NEERC 2011] Gcd guessing gameBZOJ 3969 [WF 2013] Low PowerBZOJ 3927 [NEERC 2014] ImprovementsBZOJ 3802: VocabularyBZOJ 4043 [CERC 2014] VocabularyBZOJ 4047 [CERC 2014] The Imp 刷题顺序 (Q3 2015 至今，题目数量 20+):123456789101112131415161718192021222324252627BZOJ 1180 [CROATIAN 2009] OTOCIBZOJ 2683 简单题BZOJ 4066 简单题BZOJ 3729 Gty 的游戏BZOJ 2118 墨墨的等式BZOJ 2510 弱题BZOJ 3483 [SGU 505] Prefixes and Suffixes 询问在线版BZOJ 3230 相似子串BZOJ 1229 [USACO 2008 Nov] Toy 玩具BZOJ 3600 没有人的算术BZOJ 3065 带插入区间 K 小值BZOJ 3535 [USACO 2014 Open] Fair PhotographyBZOJ 4173 数学BZOJ 1010 [HNOI 2008] 玩具装箱 ToyBZOJ 3669 [NOI 2014] 魔法森林BZOJ 4195 [NOI 2015] 程序自动分析BZOJ 4196 [NOI 2015] 软件包管理器BZOJ 4199 [NOI 2015] 品酒大会BZOJ 3990 [SDOI 2015] 排序BZOJ 2661 [Beijing WC 2012] 连连看BZOJ 3576 [HNOI 2014] 江南乐BZOJ 2756 [SCOI 2012] 奇怪的游戏BZOJ 1036 [ZJOI 2008] 树的统计 CountBZOJ 4698 [SDOI 2008] Sandy 的卡片BZOJ 2458 [Beijing 2011] 最小三角形BZOJ 1017 [JSOI 2008] 魔兽地图 DotRBZOJ 3720 Gty 的妹子树 转载自 这里基础（65） 巨水无比（4）：1214、3816:2B题；1000A+B；2462：输出10个1 模拟/枚举/暴力（15）：4063傻子模拟；1968小学生暴力；1218前缀和暴力；3856读英文；4106直接算；1800暴力判断；2208暴力判断（要会邻接表）；1028枚举；1789&amp;1830高能暴力；2241暴力；2120神奇的暴力；4145子集暴力；4029模拟处理；1086DFS树；1224暴力；3444暴力判 人类智慧题（17）：2463输出0或1；1192找规律；1413奥数；1432找规律；4001数学；1022简单博弈；2005暴力数学；2659数学；2173找规律；4147手推博弈；1228SG函数打表找规律；1045&amp;3293中位数；2222纯手算；2467找规律打表；3505组合数；3858处理小范围 高精度Python（11）：1213高精度开根；2656回溯高精度；2822递推高精度；2729组合数高精；1002递推高精；1089各种高精运算；1263贪心+高精度；1876高精度求最大公约数；1416&amp;1498高精算概率；1970暴力+高精 排序/贪心/二分（10）：4143排序后判断；3850排序后贪心；1034贪心；2563转化思想后排序；3170排序后处理；1816二分后判断；3969二分+贪心；1082排序后二分判断；3671贪心+暴力 其它水（7）：3098卡哈希；3214字符串处理；2456特殊方法；2751去重；2048小范围暴力大范围乱算；3668按位处理；2660递归计算 然后大家会发现小学生在BZOJ其实也能做50题，真的是题目难度最低的一个网站 图论（91） 搜索（8）：1054BFS；1024DFS；1295暴力+BFS；1053搜索（数学证明）；1306剪枝；3680模拟退火裸题；1085A*；2428模拟退火 最小生成树（7）：1083模板题；1821、2429裸题；1196二分+最小生成树；1050；3732+树上倍增；3624最小生成树+贪心 最短路（14）：1491Floyd+统计；1003DP+最短路；4152排序后最短路；2435DFS找负环；1486DFS找负环；1001网络流-&gt;最短路；2763、2662分层图+Dijstra+堆；1880最短路+拓扑；2118转化后最短路；2165倍增Floyd；3875SPFA维护DP；2330差分约束；3436差分约束+判负环；4144Dijkstra建树处理 二分图（9)：1854、1191裸题；1059、1433SB题；3175、2150最大独立点集；1562二分图求DFS序；1143Floyd+二分图；2539KM 网络流（33）：这部分比较重要，每道题写出连边方法，方便以后看 1412：源点向所有羊连无穷边，羊向狼连流量为1的边，所有狼向汇点连无穷边跑最大流 1066：源点向每只蜥蜴连1的边，蜥蜴向每个能到的石柱连边，如果蜥蜴能到边界，向汇点连无穷边跑最大流 1497：裸最小割，源点向所有客户连流量为收益的边，客户向选择的中转站连边，中转站向汇点连流量为花费的边，答案即为总收益减去流量 2561：加入的边为u,v长度L，则所有长度大于L的边不能使得u，v连通，求个最小割即可，小于同理 2768、1934：源点向所有资磁切尔西的连流量为1的边，所有不资磁切尔西的向汇点连流量为1的边，然后每一对朋友互相连流量为1的边，跑最大流即可 4177：源点向所有i连一条流量为ai的边，表示养牛；所有i向汇点连一条流量为bi的边，表示养羊；对于每条规则(i,j,k)，i和j之间互连流量为k的边；对于每个(S,a,b)，新建一个节点，如果a表示养牛，源点向该节点连流量为b的点，该节点向S中所有点连流量无穷的边；如果a表示养羊，该节点向汇点连流量为b的点，S所有点向该点连流量无穷的点，答案即为Σa[i]+b[i]-流量 3504：正向跑一遍，反方向再跑一遍最大流，判断即可 2007：懒得看了、、似乎网络流的话要姿势比较好，应该是最短路 3931、1266：最短路判断每条边是否可能在最短路上，若可能则加入，变成最小割模型，跑最大流即可 1565：如果A保护B，那么就连一条A–&gt;B的边，然后对这个图做拓扑序，把环给去掉，然后对剩下的点建图，如果A保护B则连一条B–&gt;A流量为无穷大的边，如果A的点权&gt;0则连一条S–&gt;A流量为A的点权的边，如果A得点权&lt;0则连一条A–&gt;T流量为A的点权的绝对值的边，就变成了最小割模型，用sum-流量即可 2039：源点向每个员工连流量为收益的边，每两个员工之间连Ei,j*2的边，每个员工i再向汇点连ΣEi,j的边，得到最小割模型，答案即为sum-流量 1797：首先求一个最大流。有可能在某个最小割中的边(u,v)：满流，删掉之后在残余网络中找不到u到v的路径。一定在所有最小割中的边(u,v)：满流，s出发沿残余网络能到u，v出发沿残余网络能到t。在残余网络中tarjan求强连通分量。(u,v)两点在同一SCC中说明残余网络中存在u到v路径。s和u在同一scc说明s能到u，t和v同一scc说明v能到t。 1305：二分答案ans，每个男孩拆成两个点ai和ai’，每个女孩拆成两个点bi和bi’，源点向每个ai连一条流量为ans的边，每个bi向汇点连一条流量为ans的边，如果男孩i喜欢女孩j，ai向bi连一条流量为1的边，否则ai’向bi’连一条流量为1的边，每个ai向ai’连一条流量为k的边，表示最多和k个不喜欢的女孩跳舞；每个bi’向bi连一条流量为k的边，如果流量=ans*n则可行，l=mid+1,否则r=mid 1189：二分答案time，源点向每个人连流量为1的边，把门拆成若干个点，表示在t时刻可以通过1人，每个点向汇点连流量为1的边，人向每个time时间内能到达的门连边，跑最大流判断是否能让所有人通过即可 3993：二分答案ans，源点向每个B连ans*b[i]的边，B向每个能打到的A连无穷边，A向汇点连a[i]的边，若流量等于Σa[i]则符合条件，向下面找，否则向上面找 3158&amp;3275：发现两两关系只会发生在奇数特征值和偶数特征值的点之间，源点向所有偶数特征值的点连流量为价值的边，所有奇数特征值的点向汇点连流量为价值的边，所有偶数特征值的点向有冲突的奇数特征值的点连流量无穷的边，就变成最小割模型，答案为所有收益-流量 1061：神奇的建图，用单纯形做简单点、 2245：源点向每类产品连流量为Ci的边，每类产品向能生产该产品的员工连无穷边，每个员工在每一段上向汇点连t[i]-t[i-1]流量w[i]费用的边，跑费用流即可 1927：拆点，源点向i连一条流量为1，费用为0的边，向i’连一条流量为1，费用为ai的边，i’向汇点连一条流量为1，费用为0的边；对于每条通道x,y,z，假设x&lt;y，从x向y’连一条流量为1，费用为z的边，然后跑费用流 3171：拆点，如果相邻两点可以通达，i向i’连一条流量为1，费用为0的边，否则连一条流量为1，费用为1的边，源点向每个i连一条流量为1的边，所有i’向汇点连流量为1的边，然后跑费用流 2424：拆点，源点向i连一条流量无穷，费用di的边，表示订货，i向i’连一条流量无穷费用为0的边，所有i’向汇点连流量ui费用0的边表示卖出，所有i向i+1连一条流量S费用m的边表示存储费用，然后跑费用流 3130：第一问裸流，第二问二分答案，每条边的流量为min(z[i],now)，如果仍然能满足最大流等于原来值，那么r=mid，否则l=mid+1 1834：第一问裸流，第二问直接在剩余网络上做费用流 3876：对于每一条边权为z的边x-&gt;y：从S到y连一条费用为z，流量为1的边 代表这条边至少走一次，从x到y连一条费用为z，流量为INF的边 代表这条边除了至少走的一次之外还可以随便走。对于每个点x：从x到T连一条费用为0，流量为x的出度的边，从x到1连一条费用为0，流量为INF的边，代替原图上的源和汇 1877：拆点，源点为1’，汇点为n，对于每个i和i’连一条流量为1费用为0的边表示只能走一次，对于每条有向边(x,y,z)从x’向y连一条流量为1，费用为z的边，然后跑费用流即可 1221：拆点，源点向每个i连一条流量无穷费用f的边表示直接买毛巾，每个i向i’连一条流量无穷费用0的边，每个i’向t连一条流量为ni费用0的边，表示需要的毛巾；每个i’向i+a连一条流量无穷费用fa的边，表示快洗；每个i’向i+b连一条流量无穷费用fb的边，表示慢洗 1070：把M个技术人员拆成N个点，第w个点表示给第w个顾客修车时所有顾客需要多等待的时间，每个顾客j向每个技术人员mi连一条流量为1，费用为k*a[j][i]的边，表示每个顾客对后面顾客造成的影响；源点向每个顾客连流量为1的边，每个拆出来的技术人员向汇点连一条流量为1的边 2849：和上题差不多，不过每条边要动态加，否则要T 1449：假设后面M场比赛两方都是输的，对于后面每场比赛，每赢一场的收益增加值add=c[i]-(win[i]+1)^2+d[i]-(lose[i]-1)^2-[c[i]-win[i]^2+d[i]-lose[i]^2=2win[i]c[i]-2lose[i]d[i]+c[i]+d[i]，之后win[i]++,lose[i]–。源点向每场比赛连流量为1，费用为0的边，每场比赛向双方连流量为1，费用为0的边，每支球队按照上述方法连每条边，然后求出费用加上原来收益即可 2668：对于每个点一分为三，分为p0,p1,p2，对于每个点， 如果它是原图中得黑点，连边&lt;p1,p0,c/2,0&gt;，&lt;p0,p2,(c+1)/2&gt;，&lt;st,p0,1,0&gt;； 如果它是新图中得黑点，连边&lt;p1,p0,(c+1)/2&gt;，&lt;p0,p2,c/2,0&gt;，&lt;p0,ed,1,0&gt;； 如果它在两个图中都是白点，那么连边&lt;p1,p0,c/2,0&gt;，&lt;p0,p2,c/2,0&gt;。 这样就可以体现出点容量的差异了。 然后对于原图中可以交换的两个点(i,j)连接&lt;pi2,pj1,inf,1&gt;， 那么这种边每流过1的流量就意味着(i,j)交换了一次，那么费用就是最终的答案了。 拓扑（3）：4010最小拓扑序；2535&amp;2109拓扑逆向加边 tarjan（5）：1051：直接tarjan判断强连通分量个数是否为1；2438：缩点后，ans=入度为0的连通块个数，倘若存在只有一个点的连通块，它无出边或出边指向的点均能被其它点到达则ans-1；1179:缩点后求点权最长路；1093缩点后DP统计方案；1823 2-SAT 树（11）：2783树上DFS+倍增；1509树上最长链；1912两次树上最长链；2657奇怪构图后树上最长链；1787LCA；2152点分治；3991虚树动态统计；2286、3572虚树DP；1005、1211Prufer编码 数据结构（69） 并查集（3）：1015倒着加入并查集；1202维护一个数组记录差值；4195傻逼并查集 基础数据结构（4）：1483链表启发式合并；1007、3190单调栈；1293单调队列 堆/RMQ（7）：1029贪心+堆；1216堆；2006RMQ+堆；1047二维RMQ；2809可并堆；2333可并堆各种操作；4198哈夫曼编码 哈希表（4）：1567二分+哈希判重；3555哈希后排序判断；3916分类哈希；3751HASH解方程 分块（8）：2957傻逼分块；2141、3295动态逆序对；3744在线求逆序对数；2821分块+二分；2038莫队；3289莫队+树状数组;3720块状树 树状数组（5）：1012裸题；1452三维树状数组；1878、2743离线树状数组；1176CDQ分治+树状数组 线段树（3）：1798、3212线段树Lazy；1067线段树判断 平衡树（17）：1588、3224、1208基本操作；1503权值操作；1056、1862Tire+Splay；1661简单区间操作；3223、3506Splay翻转；2733Splay启发式合并；1858、1500Splay各种操作；2752平衡树维护多个信息；1057Set；1269、1507Rope；3673、3674可持久化Rope 可持久化（2）：2588DFS序+可持久化线段树；3123DFS序+可持久化线段树+加边+启发式合并 树套树（2）：3110区间线段树套权值线段树；3196树套树各种基本操作 K-D树（4）：1941、2648基本操作；4066K-D树的重建；3489转化后三维K-D树 树链剖分（3）：3631树剖简单裸题；1036树剖基本操作；2243树剖染色；4196傻逼树剖 LCT（4）：2002、2049LCT裸题；2157LCT复杂操作；3669LCT各种操作；3091LCT各种操作+平衡树维护多个信息 字符串/计算几何/博弈论/其他（19） KMP（2）：3670KMPnext维护；3620暴力+KMP AC自动机（4）：3172模板题；1212AC自动机+DP；1030AC自动机+DP；1444AC自动机+矩乘 后缀数组（2）：1031基本题；3238后缀数组+单调栈 后缀自动机（3）：3998第K小子串；2754广义后缀自动机；3926暴力Tire构建广义 后缀树（1）：4199后缀树裸题 凸包（1）：1027凸包+最短路 随机增量（2）：2823最小圆覆盖；3564转化后最小圆覆盖 博弈论（1）：1188SG函数 三分（3）：3330三分套三分+保留位数输出；1857三分套三分；3874单调性贪心+三分 数论（34） 扩展欧几里得（1）：1407 线性筛/欧拉（6）：1607线性筛因数；3288、2190、2818线性筛欧拉函数；4173、2705logn求欧拉函数 快速幂/矩阵乘法（9）：1008快速幂；1965、2751快速幂+快速乘；1297、1898图上矩乘加速；2875、2426矩阵乘法；1875矩乘拆边构图；1009KMP+矩乘 高斯消元/线性基（9）：1013、1923高斯消元；3143高斯消元求期望；3105、2460、4004拟阵+线性基；2115找环+线性基；2844拟阵+线性基；2337期望高斯 置换群/Poyla（1）：1004置换+背包逆元 裴蜀定理（2）：2257、2299裴蜀定理 BSGS（1）：2242快速幂+逆元+BSGS 卢卡斯定理（1）：1951卢卡斯+孙子；2111排列组合 莫比乌斯反演（2）：2301容斥+莫比乌斯反演+前缀和；3994莫比乌斯反演+前缀和 FFT（1）：3527模板题 DP（71） 基本DP（31）：2748小学题；1088初一题；1207初二题；1037初三题；1296、1260基本区间DP；1025筛DP；1197SB题；1084选择DP；1032错误DP；1055区间DP；1042背包DP+容斥；1806多维DP；1237递推；1925、2431DP+前缀和优化；3174贪心+DP；1566滚数组DP；2423推方案DP；1899递推；1222神奇转化降维；1801状压DP转化；1046DP+贪心；1991区间推DP；1044二分+DP；1786、1831猜想后DP；1057悬线法；2298转化为取区间；1966、3191DP 树形DP（8）：1864树形DP，加0或1记染色方案；1060、4027、1304、4011+朱刘；1040环+外向树；1791基环树找直径；2878基环树判环DP+暴 数位DP（2）：1029基本数位DP；1833较复杂处理；3209二进制数位DP 记忆化（6）：1048、1079、3208记忆化；1090（区间）；1564（区间）；1415（期望）；3810记忆化+卡常 期望DP（4）：1076、4004倒着DP；2134、4008； 状态压缩（4）：1072、2560子集DP；1087状压DP；4197小范围状压 单调性（2）：1499单调队列优化；1563单调性优化 斜率优化（7）：1010、1911、3437模板题；1096两个前缀和；3156；1567排序+斜率；3675多维斜率优化 其它优化（3）：1264、3594树状数组优化；1492CDQ分治优化","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://chicago01.top/tags/杂项/"}]},{"title":"","slug":"20190416","date":"2019-04-16T01:12:40.000Z","updated":"2019-05-30T13:03:06.134Z","comments":true,"path":"2019/04/16/20190416/","link":"","permalink":"http://chicago01.top/2019/04/16/20190416/","excerpt":"","text":"其实真正懂纯音乐、欣赏纯音乐、喜欢听纯音乐的人，很多都是有抑郁症或自卑或真正孤独的人。他们喜欢在纯音乐中独自品味这常人根本无法忍受的孤独，他们喜欢在喜欢的纯音乐中回忆过去种种的美好。不喧哗、不世故、不擅长交际、和善待人、有自己的想法和信念。愿爱听纯音乐的我们会被这个世界温柔相待♥ 博客无限期停更！ ——2019-04-16 09:12:40","categories":[],"tags":[]},{"title":"题解 P1093 奖学金","slug":"题解-P1093-奖学金","date":"2019-04-09T13:22:11.000Z","updated":"2019-04-09T14:10:18.708Z","comments":true,"path":"2019/04/09/题解-P1093-奖学金/","link":"","permalink":"http://chicago01.top/2019/04/09/题解-P1093-奖学金/","excerpt":"题目描述某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前5名学生发奖学金。期末，每个学生都有3门课的成绩:语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学 排在前面，这样，每个学生的排序是唯一确定的。","text":"题目描述某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前5名学生发奖学金。期末，每个学生都有3门课的成绩:语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学 排在前面，这样，每个学生的排序是唯一确定的。 任务：先根据输入的3门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。注意，在前5名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据(每行输出两个数:学号、总分) 是: 7 2795 279 这两行数据的含义是:总分最高的两个同学的学号依次是7号、5号。这两名同学的总分都是 279 (总分等于输入的语文、数学、英语三科成绩之和) ，但学号为7的学生语文成绩更高一些。如果你的前两名的输出数据是: 5 2797 279 则按输出错误处理，不能得分。 输入格式共n+1行。 第11行为一个正整数n(≤300)，表示该校参加评选的学生人数。 第22到n+1行，每行有3个用空格隔开的数字，每个数字都在0到100之间。第j行的3个数字依次表示学号为j-1的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为1~n（恰好是输入数据的行号减1）。 所给的数据都是正确的，不必检验。 输出格式共5行，每行是两个用空格隔开的正整数，依次表示前5名学生的学号和总分。 输入输出样例输入 #1 1234567690 67 8087 66 9178 89 9188 99 7767 89 6478 89 98 输出 #1 123456 2654 2643 2582 2441 237 输入 #2 123456789880 89 8988 98 7890 67 8087 66 9178 89 9188 99 7767 89 6478 89 98 输出 #2 123458 2652 2646 2641 2585 258 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;struct qwq&#123; int wyu,wshu,wying; int sum; int number; bool operator &lt; (const qwq &amp;w) &#123; if(sum &gt; w.sum) return true; if(sum == w.sum) &#123; if(wyu &gt; w.wyu) return true; if(wyu == w.wyu) return number &lt; w.number; &#125; return false; &#125;&#125;num[310];int n;int main(int argc, char const *argv[])&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i) &#123; num[i].number=i; scanf(\"%d%d%d\",&amp;num[i].wyu,&amp;num[i].wshu,&amp;num[i].wying); num[i].sum=num[i].wyu+num[i].wshu+num[i].wying; &#125; sort(num+1,num+n+1); n = n &gt;= 5 ? 5 : n; for(int i=1;i&lt;=n;++i) printf(\"%d %d\\n\",num[i].number,num[i].sum); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://chicago01.top/categories/题解/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://chicago01.top/tags/模拟/"}]},{"title":"题解 蛇形矩阵","slug":"题解-蛇形矩阵","date":"2019-04-09T12:56:33.000Z","updated":"2019-04-09T14:10:08.692Z","comments":true,"path":"2019/04/09/题解-蛇形矩阵/","link":"","permalink":"http://chicago01.top/2019/04/09/题解-蛇形矩阵/","excerpt":"题目在n * n 方阵中填入1,2,3,…., n * n ,要求填成蛇形状。 123410 11 12 19 16 13 28 15 14 37 6 5 4","text":"题目在n * n 方阵中填入1,2,3,…., n * n ,要求填成蛇形状。 123410 11 12 19 16 13 28 15 14 37 6 5 4 代码123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int n,num[10][10];int main()&#123; cin &gt;&gt; n; int ans,x = n-1,y = 0; ans = num[y][x] = 1; while(ans &lt; n*n) &#123; while(y &lt; n-1 &amp;&amp; !num[y+1][x]) num[++y][x] = ++ans; while(x &gt; 0 &amp;&amp; !num[y][x-1]) num[y][--x] = ++ans; while(y &gt; 0 &amp;&amp; !num[y-1][x]) num[--y][x] = ++ans; while(x &lt; n-1 &amp;&amp; !num[y][x+1]) num[y][++x] = ++ans; &#125; for(int i = 0;i &lt; n;++i) &#123; for(int j = 0;j &lt; n;++j) cout &lt;&lt; num[i][j] &lt;&lt; \" \"; cout &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://chicago01.top/categories/题解/"}],"tags":[{"name":"递推","slug":"递推","permalink":"http://chicago01.top/tags/递推/"}]},{"title":"题解 P2807 三角形计数","slug":"题解-P2807-三角形计数","date":"2019-04-09T12:25:08.000Z","updated":"2019-04-09T14:10:02.952Z","comments":true,"path":"2019/04/09/题解-P2807-三角形计数/","link":"","permalink":"http://chicago01.top/2019/04/09/题解-P2807-三角形计数/","excerpt":"题目背景三角形计数(triangle) 递推","text":"题目背景三角形计数(triangle) 递推 题目描述把大三角形的每条边n等分，将对应的等分点连接起来（连接线分别平行于三条边），这样一共会有多少三角形呢？编程来解决这个问题。 输入格式第一行为整数t(≤100)，表示测试数据组数；接下来t行，每行一个正整数n(≤500)。 输出格式对于每个n，输出一个正整数，表示三角形个数。 输入输出样例输入 #1 12343123 输出 #1 1231513 说明/提示n(≤500) t(≤100) 代码12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int t,n,ans[501];int main()&#123; scanf ( \"%d\", &amp;t ); while(t--) &#123; cin &gt;&gt; n; if ( n % 2 == 1 ) cout &lt;&lt; ( n + 1 ) * ( 2 * n * n + 3 * n - 1 ) / 8 &lt;&lt; endl; else cout &lt;&lt; n * ( n + 2 ) * ( 2 * n + 1 ) / 8 &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://chicago01.top/categories/题解/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://chicago01.top/tags/数学/"}]},{"title":"3月月赛题解","slug":"3月月赛题解","date":"2019-03-28T13:38:03.000Z","updated":"2019-03-30T11:54:35.663Z","comments":true,"path":"2019/03/28/3月月赛题解/","link":"","permalink":"http://chicago01.top/2019/03/28/3月月赛题解/","excerpt":"校内比赛题解。","text":"校内比赛题解。 题解1.签到题 2.排列问题 3.因数问题 4.二叉树问题 前置技能： 快速幂 dfs 树 签到题这题其实就是一个裸的快速幂模板。 问自己一个问题，求$n^m$的后四位数字，和n这个数的其它位有关吗？ 显然我们发现万位以上的数字都不会影响结果，那么我们只要取这个数字的前四位即可。 如果数据不足四位怎么办？我们该怎么乘还是怎么乘，只要在最后输出的时候加一点小技巧即可。 输出部分的代码长这个样子（我个人的写法，写法不唯一）： 123456789for(int i=1;i&lt;=4;i++)&#123; c[i] ='0' + (ans % 10); ans /= 10;&#125;for(int i=1;i&lt;=4;i++)&#123; cout &lt;&lt; c[5-i]; &#125; 思路就是拿出最终结果的每一位，如果说不足四位，最后塞进字符数组中的数显然是0，这样就解决了输出前导零的问题了。 接下来浅谈一下快速幂。 关于快速幂，大家还是要A掉洛谷的模板题P1226 【模板】快速幂||取余运算 快速幂是采用了二分的思想，原理就是一个我们大家都懂的式子： $$n^m=n^{m/2}×n^{m/2} \\quad (m为偶数)$$ $$n^m=n^{m/2}×n^{m/2}×n \\quad (m为奇数)$$ 根据这两个式子就可以写出快速幂了。 代码如下： 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int mod = 10000;ll m,n;char c[5];ll pow_mod(ll a,ll b)&#123; if(b==0)return 1; ll x=pow_mod(a,b/2); ll ans = x * x % mod; if(b%2==1)ans = ans * a % mod; return ans; &#125; int main()&#123; cin &gt;&gt; n &gt;&gt; m; n %= mod; ll ans = pow_mod(n,m) % mod; for(int i=1;i&lt;=4;i++) &#123; c[i] ='0' + (ans % 10); ans /= 10; &#125; for(int i=1;i&lt;=4;i++) &#123; cout &lt;&lt; c[5-i]; &#125; return 0;&#125; 排列问题排列问题是dfs解决的一个基础问题。 这道题是一个带有重复元素的全排列问题，和普通的排列问题有一些细微的差别。 但是我们只需要记录一下每个元素出现了多少次即可，这里采取了桶的思想。 dfs的模板其实就是这样： 123456void dfs(int x)&#123; if(x==n) return; dfs(x+1);&#125; 在这个基础上，每次做点什么让你离答案更近，具体做什么要视题目而定，在这里我们当然要做的就是将字母填进去，当所有字母都填完的时候我们就得到了一个合法的排列。 先上代码： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;string s;int n,a[50],f[1010],ans;void dfs(int d)&#123; if(d == n + 1) &#123; ans++; for(int i=1;i&lt;=n;i++) printf(\"%c\",f[i] + 'a'); printf(\"\\n\"); return; &#125; for(int i=0;i&lt;=25;i++) &#123; if(a[i] &gt; 0) &#123; f[d] = i; a[i]--; dfs(d + 1); a[i]++; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n; cin &gt;&gt; s; for(int i=0;i&lt;n;i++) &#123; a[s[i] - 'a']++; &#125; dfs(1); cout &lt;&lt; ans; return 0; &#125; 我们分析一下我的这个dfs函数： 123456789101112131415161718192021222324void dfs(int d)&#123; if(d == n + 1) &#123; ans++; for(int i=1;i&lt;=n;i++) printf(\"%c\",f[i] + 'a'); printf(\"\\n\"); return; &#125; for(int i=0;i&lt;=25;i++) &#123; if(a[i] &gt; 0) &#123; f[d] = i; a[i]--; dfs(d + 1); a[i]++; &#125; &#125;&#125; 和我们上方的模板比照一下，是不是分为了两部分。 翻译成人话就是 1234567891011121314151617181920212223void dfs(int d)&#123; if(字符串用完) &#123; 答案加一; 输出这个字符串; 返回上一层; &#125; 从a到z查找有哪些字符还没用完 &#123; if(这个能用) &#123; f[d] = 这个字符串; 这个字符串的个数减一; dfs(下一层); 这个字符串的个数加一; &#125; &#125;&#125; 因数问题这道题，其实只要用试除法就能拿到80分。 先说80分做法 其实就是挨个除，能够整除就ans++。 十分无脑，直接上代码： 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int n,ans,t;int main()&#123; cin &gt;&gt;t; while(t) &#123; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++) &#123; if(n%i==0)ans++; &#125; cout &lt;&lt;ans&lt;&lt;endl; ans = 0; t--; &#125; return 0;&#125; 然后方法二暂且了解一下即可，反正这个题就是防AK的QAQ（不要打我） 首先,任何一个大于1的整数N，都可以分解成如下形式：$$N=P^{a_1}_1×P^{a_2}_2×P^{a_3}_3×……P^{a_n}_n$$其中每个$P$都是质数。 那么我们只要把一个数分解成为上面的形式，然后将这些$P$的次数乘起来即可。（想一想为什么） 关于如何筛素数，可以参考P3383 【模板】线性筛素数代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn =1000000;bool vis[maxn + 10];int t,n,a[100010];void prime()&#123; int m = sqrt(maxn+0.5); for(int i=2;i&lt;=m;i++) if(!vis[i]) for(int j=i*i;j&lt;=maxn;j+=i) vis[j] = true; int cnt = 1; for(int i=2;i&lt;=maxn;i++) &#123; if(!vis[i]) &#123; a[cnt] = i; cnt++; &#125; &#125;&#125;void fc(int n)&#123; int ans = 1,i = 1; while(n!=1) &#123; int cnt = 1; while(n%a[i] == 0) &#123; cnt++; n/=a[i]; &#125; i++; ans *= cnt; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; cin &gt;&gt; t; prime(); for(int i=1;i&lt;=t;i++) &#123; cin &gt;&gt; n; fc(n); &#125; return 0;&#125; 二叉树问题二叉树是基础的数据结构，这道题只是考察了它的一个简单的概念。 首先明确三个概念，先序遍历，中序遍历，后序遍历。 可以简记如下： 先序遍历，根左右 中序遍历，左根右 后序遍历，左右根 我们只关注根和它的左右节点即可，不需要在意左右节点又连着什么。 每次按照上面的顺序进入到指定节点，如果是根则直接输出。 这样寻找是因为二叉树是递归定义的。 观察到先序遍历的最开始一定是根，后序遍历的末尾一定是根，而中序遍历将左右子树以根为中心分开。 于是我们就设计dfs函数，从后序遍历中找到根，然后在中序遍历中将左右子树分开，每找到一个根，就输出。 代码如下： 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;void dfs(string s1,string s2)&#123; if(s1.size() &gt; 0) &#123; char gen = s2[s2.size() - 1]; cout &lt;&lt; gen; int num = s1.find(gen); dfs(s1.substr(0,num),s2.substr(0,num)); dfs(s1.substr(num + 1),s2.substr(num,s1.size() - num - 1)); &#125;&#125;int main()&#123; string s1,s2; cin&gt;&gt; s1 &gt;&gt; s2; dfs(s1,s2); return 0; &#125;","categories":[],"tags":[]},{"title":"题解P1002 过河卒","slug":"题解P1002-过河卒","date":"2019-03-28T13:14:48.000Z","updated":"2019-03-28T13:38:11.304Z","comments":true,"path":"2019/03/28/题解P1002-过河卒/","link":"","permalink":"http://chicago01.top/2019/03/28/题解P1002-过河卒/","excerpt":"","text":"题目描述棋盘上A点有一个过河卒，需要走到目标B点。卒行走的规则：可以向下、或者向右。同时在模盘上C点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。棋盘用坐标表示，A点（0，0）、B点（n，m）（n，m为不超过20的整数），同样马的位置坐标是需要给出的。现在要求你计算出卒从A点能够到达B点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。 输入输出格式输入格式：一行四个数据，分别表示B点坐标和马的坐标。 输出格式：一个数据，表示所有的路径条数。 输入输出样例###输入样例#1： 16 6 3 3 输出样例#1：16 说明结果可能很大！ 题解这涉及到高中所学的加法原理。 然后易得DP转移方程：$dp[i][j] = dp[i-1][j] + dp[i][j-1]$ 前提是马够不到的距离下是这样。","categories":[{"name":"题解","slug":"题解","permalink":"http://chicago01.top/categories/题解/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://chicago01.top/tags/DP/"}]},{"title":"题解P1308 统计单词数","slug":"题解P1308-统计单词数","date":"2019-03-28T12:59:04.000Z","updated":"2019-03-28T13:07:45.538Z","comments":true,"path":"2019/03/28/题解P1308-统计单词数/","link":"","permalink":"http://chicago01.top/2019/03/28/题解P1308-统计单词数/","excerpt":"题目描述一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。 现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章 中的某一独立单词在不区分大小写的情况下完全相同（参见样例1 ），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例2 ）。","text":"题目描述一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。 现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章 中的某一独立单词在不区分大小写的情况下完全相同（参见样例1 ），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例2 ）。 输入输出格式输入格式：共2行。 第11行为一个字符串，其中只含字母，表示给定单词； 第22行为一个字符串，其中只可能包含字母和空格，表示给定的文章。 输出格式：一行，如果在文章中找到给定单词则输出两个整数，两个整数之间用一个空格隔开，分别是单词在文章中出现的次数和第一次出现的位置（即在文章中第一次出现时，单词首字母在文章中的位置，位置从00 开始）；如果单词在文章中没有出现，则直接输出一个整数-1−1。 输入输出样例输入样例#1：12Toto be or not to be is a question 输出样例#1：12 0 输入样例#2：12toDid the Ottoman Empire lose its power at that time 输出样例#2：1-1 说明数据范围 $1≤单词长度≤10$。 $1≤文章长度≤1,000,00$。 noip2011普及组第2题 题解 全部变成小写 逐个判断开头字母，判断前一位是不是空格或是首位，找搜索起点 完全匹配后，判断下一位是不是空格 统计结果 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;string s1,s2; int ans,s1len,s2len;int main(void)&#123; getline(cin,s1); getline(cin,s2); s1len = s1.length(); s2len = s2.length(); for(int i = 0;i &lt; s1len;++i) &#123; if(s1[i] &gt;= 'A' &amp;&amp; s1[i] &lt;= 'Z') s1[i] += -'A'+'a'; &#125; for(int i = 0;i &lt; s2len;++i) &#123; if(s2[i] &gt;= 'A' &amp;&amp; s2[i] &lt;= 'Z') s2[i] += -'A'+'a'; &#125; int tong = 0,v = -1; for(int i = 0;i &lt;= s2len - s1len;++i) &#123; if(s2[i] == s1[0]) if(i == 0 || s2[i-1] == ' ') &#123; for(int j = 1;j &lt; s1len;++j) if(s1[j] != s2[i+j]) &#123; tong = 1; break; &#125; if(tong == 0) &#123; if(i+s1len == s2len || s2[i+s1len] == ' ') &#123; ans++; if(v == -1) v = i; &#125; &#125; tong = 0; &#125; &#125; if(ans == 0) cout &lt;&lt; \"-1\"; else cout &lt;&lt; ans &lt;&lt; \" \" &lt;&lt; v; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://chicago01.top/categories/题解/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://chicago01.top/tags/字符串/"}]},{"title":"计数原理","slug":"计数原理","date":"2019-03-26T11:12:52.000Z","updated":"2019-03-26T11:54:37.386Z","comments":true,"path":"2019/03/26/计数原理/","link":"","permalink":"http://chicago01.top/2019/03/26/计数原理/","excerpt":"谨以此篇，献给呢个每天陪我倾诉，督促我背单词的女孩。比起呢装满零食的礼物盒子，或是撩人心弦的甜言蜜语，这篇文章显得力不从心😂。但是这可是我一个字一个字手打的啊！只是因为你的一句：","text":"谨以此篇，献给呢个每天陪我倾诉，督促我背单词的女孩。比起呢装满零食的礼物盒子，或是撩人心弦的甜言蜜语，这篇文章显得力不从心😂。但是这可是我一个字一个字手打的啊！只是因为你的一句： 计数原理是数学中的重要研究对象之一，分类加法计数原理、分步乘法计数原理是解决计数问题的最基本、最重要的方法，也称为基本计数原理，它们为解决很多实际问题提供了思想和工具。 基本定义加法原理分类计数原理：做一件事情，完成它有n类方式，第一类方式有M1种方法，第二类方式有M2种方法，……，第n类方式有Mn种方法，那么完成这件事情共有M1+M2+……+Mn种方法。 类类独立。 例：从武汉到上海有乘火车、飞机、轮船3种交通方式可供选择，而火车、飞机、轮船分别有k1，k2，k3个班次，那么从武汉到上海共有 k1+k2+k3种方式可以到达。 乘法原理分步计数原理：做一件事情，完成它有$n$个步骤，第一步方式有$M_1$种方法，第二步方式有$M_2$种方法，……，第$n$步方式有$M_n$种方法，那么完成这件事情共有$M_1M_2……*M_n$种方法。 步步相关。 例：百位数有5种选择；十位数有4种选择；个位数有3种选择．所以共有5×4×3=60个数字不重复的三位数． 排列排列（英语：Permutation）是将相异对象或符号根据确定的顺序重排。每个顺序都称作一个排列。例如，从一到六的数字有720种排列，对应于由这些数字组成的所有不重复亦不阙漏的序列，例如”4, 5, 6, 1, 2, 3” 与1, 3, 5, 2, 4, 6。 排列数：从$n$个相异的元素中取出$m$个元素，$m$个元素的排列数量为：$A^m_n=n!/(n-m)!$ 全排列排列数：$A^n_n=n!$ 例：以赛马为例，有8匹马参加比赛，玩家需要在彩票上填入前三胜出的马匹的号码，从8匹马中取出3匹马来排前3名，排列数量为： $A^3_8 = 8!/(8-3)!$ 组合一个集的元素的组合（英语：Combination）是一个子集。S的一个k-组合是S的一个有k个元素的子集。若两个子集的元素完全相同并顺序相异，它仍视为同一个组合，这是组合和排列不同之处。 从n个不同元素中每次取出m个不同元素（0≤m≤n），不管其顺序合成一组，称为从n个元素中不重复地选取m个元素的一个组合。所有这样的组合的总数称为组合数，这个组合数的计算公式为:$C^m_n=P^m_n/P^m_m=n!/m!(n-m)!$ 从不同元素中抽取部分元素的问题 。 模型总结排列组合也不过是几多模型，在来回套用罢了，只需要区分好这几个模型，并且拿到题，能联想到是哪个模型，进而套用就可以解出题目了。 基础综合 加法原理是情况与情况之间，类与类之间的关系。 乘法原理是步骤与步骤之间的关系，前后是相关的。 排列$A^m_n$是从$n$给中选取$m$个进行排列的数目。 组合$C^m_n$是从$n$给中选取$m$个进行组合的数目。 如果真的不知道排列和组合到底是什么，你可以再去看看课本。 例 （1988·全国·14·J）假设在200件产品中有3件次品，现在从中任意抽取5件，其中至少有2件次品的抽法种数为（）. 解析看到至少，要想到分类，如果要分类，呢么就要用到加法原理。 5个里面抽到了2个次品：$C^2_3$，其余3个是正常的：$C^3_{197}$，因为抽到次品和抽到正常的两个步骤是相关的，所以 $C^2_3C^3_{197}$。 5个里面抽到了3个次品：$C^3_3$，其余2个是正常的：$C^2_{197}$，因为抽到次品和抽到正常的两个步骤是相关的，所以 $C^3_3C^2_{197}$。 加法原理：$C^2_3C^3_{197}+C^3_3C^2_{197}$ 例 （2007·全国一·5·J）甲、乙、丙3位同学选修课程，从4门课程中，甲选修2门，乙、丙各选修3门，则不同的选修方案共有（）. 解析甲乙丙选课是相关关系，用乘法原理：$C^2_4C^3_4C^3_4$。 例 （2010·湖北·6·J）现有6名同学去听同时进行的5个课外知识讲座，每名同学可自由选择其中的一个讲座，不同选法的种数是（）. 解析每个人都有5个选择，根据乘法原理可以很容易得到$5^6$。 例 （2011·全国·9·JJ）4位同学每人从甲、乙、丙3门课程中选修1门，则恰有2人选修课程甲的不同选总共有（） 解析 恰有两人选择甲课程，也就是只有两个人选择甲课程：$C^2_4$。 剩余两个人只能选择剩余的课程，不能再选择甲，所以每个人剩两个选择：$2^2$。 根据乘法原理可得：$C^2_4*2^2$。 例 （2006·江苏·13·JJ）今有2个红球、3个黄球、4个白球，同色球不加以区分，将这9个球排成一列有（）种不同的方法（用数字作答）. 解析九个排成一列，可以用填坑法，一共有9个坑，分别选择红黄白三种颜色球往里面填充：$C^2_9C^3_7C^4_4$。 例 （2000·全国旧课程·13·JJ）乒乓球队的10名队员中有3名主力队员，派5名参加比赛.3名主力队员要安排在第一、三、五位置，其余7名队员选2名安排在第二、四位置，那么不同的出场安排共有（）种（用数字作答）. 解析 有3个位置上填哪几个人是已经确定的，所以直接排列$A^3_3$。 剩余2个人中要从7个人中选择出来，并排列：$A^2_7$。 乘法原理可得：$A^3_3A^2_7$。 例 （2003·北京·9·J）从黄瓜、白菜、油菜、扁豆4种蔬菜品种中选出3种，分别种在不同土质的三块土地上，其中黄瓜必须种植，不同的种植方法共有（）. 解析 黄瓜必须选择，所以就从三种菜里选出2种，$C^2_3$。 又要把这三种选好的作物上排列在不同土质的三块土地，$A^3_3$。 乘法原理可得，$C^2_3$ $A^3_3$。 例 （2007·北京·5·J）某城市的汽车牌照号码由2个英文字母后接4个数字组成，其中4个数字互不相同的牌照号码共有（）. 解析 从26个字母中选择一个字母，$C^1_{26}$ 在从26个字母中选择一个字母，$C^1_{26}$ 选择四个不同数字，10个数字里面选择4个的排列数，$A^4_10$ 乘法原理，$C^1_{26}$$C^1_{26}$$A^4_10$ 分组模型 题目关键字：从XX中选出X，做YYY。 一种是确定性分配，比如：6个人平均去3个不同的地方，于是我们很确定每个地方都要2个人去，此时直接$C^6_2C^4_2C^2_2$ 即可。 一种是不确定性分配，比如：4个人去3个不同的地方，每地至少一个，也即1+1+2，这时每个地方不确定自己是几人（1或者2），所以要充分考虑各种可能性，列表格有助于周全地考虑各种可能性。 例 （2009·宁夏海南·15·j）7名志愿者中安排6人在周六、周日两天参加社区公益活动。若每天安排3人，则不同的安排方案共有（）种（用数字作答）。 解析确定性分组，很明显可得$C^7_3C^3_4$。 例 （2009·湖北·4·j）从5名志愿者中选派4人在星期五、星期六、星期日参加公益活动，每人一天，要求星期五有一人参加，星期六有两人参加，星期日有一人参加，则不同的选派方法共有（） 解析确定性分组，很容易确定$C^1_5C^4_2C^1_2$。 例 （2017·新课标全国二·6·JJ）安排3名志愿者完成4项工作，每人至少完成1项，每一项工作由1人完成，则不同的安排方式共有（）。 解析每个人完成工作的数目是不确定的，所以要进行分类。 第一个人 第二个人 第三个人 组合 2 1 1 $C^2_5C^2_3C^1_1$ 1 2 1 $C^2_5C^3_1C^2_2$ 1 1 2 $C^1_5C^4_2C^2_2$ 加法原理可得：$C^2_5C^2_3C^1_1$$+C^2_5C^3_1C^2_2+$$C^1_5C^4_2C^2_2$ 例 （1995·全国·20·JJ）四个不同的小球放入编号为1，2，3，4的四个盒子中，则恰有一个空盒子的放法共有（）种。 解析这时候不仅要对空盒子进行分类，如果有一个空盒子，呢么必然还存在一个盒子放2个球。 第一个盒子 第二个盒子 第三个盒子 第四个盒子 组合 0 1 1 2 ………… 0 1 2 1 ………… 0 2 1 1 ………… 1 1 2 0 ………… ………… ………… ………… ………… ………… 懒癌症患者，懒得打了，你看不懂再问我吧。 捆绑法和插孔法 ①出现XX必须和YY在一起，呢就把XX和YY捆绑到一起，然后对XX和YY进行一个全排列，因为XX可能在YY左边，也可能在右边。 ②出现XX必须不和YY在一起，呢就把XX和YY插缝到其它人中间。 例 （1996·全国·5·J）6名同学排成一排，其中甲、乙两人必须在一起的不同排法有（）。 解析呢就把甲乙排在一起吧，因为甲乙的位置没有被限定，所以甲乙内部的顺序也要进行一个全排列：$A^5_5A^2_2$ 。 例 （1990·全国·12·J）A，B，B，D，E五人并排站在一排，如果A，B必须相邻且B在A的右边，呢么不同的排法公有（）。 解析A，B的内部位置是被确定好的，直接当成一个整体进行排列，所以最终结果是：$A^4_4$ 。 例 （2007·北京·5·J）记者要为5名志愿者和他们帮助的2位老人拍照，要求排成一排，2位老人相邻但不排在两端，不同的排法共有（）. 解析第一步，排两端∵从5名志愿者中选2名有$A_5^2$=20种排法 第二步，∵2位老人相邻，把2个老人看成整体，与剩下的3名志愿者全排列，有$A_4^4$=24种排法 第三步，2名老人之间的排列，有$A_2^2$=2种排法 最后，三步方法数相乘，共有$20×24×2=960$种排法故填写960. 例 （2010·北京·4·j）8名学生和2位老师站成一排合影，2位老师不相邻的排法种数为（）. 解析这时候就要考虑插孔了，不相邻，就让她俩插在别人中间呗。 将所有学生先排列，有$A_8^8$ 种排法， 然后将两位老师插入9个空中， 共有$A_9^2$ 种排法， ∴一共有$A_8^8A_9^2$种排法． 例 （1984·全国·11·j）要排一张有6个歌唱节目和4个舞蹈节目的演出节目单，任何两个舞蹈节目不得相邻，问有多少种不同的排法(). 解析有七个孔可插，有四个元素要插进去，综上可得：$A^6_6A^4_7$。 练习 （2005·辽宁·15·jjj）用1，2，3，4，5，6，7，8组成没有重复数字的八位数，要求1和2相邻、3与4相邻，5与6相邻，而7与8不相邻，这样的八位数共有( )个（$A_4^2A_3^3A_2^2A_2^2A_2^2$）。 练习 （2008·安徽·12·JJJ）12名同学合影，站成前排4人后排8人，现摄影师要从后排8人中抽2人调整到前排，若其他人的相对顺序不变，则不同调整方法的总数是（）($C_8^2A_6^2$). 堵孔法所谓“堵孔”法，举个例子一听就懂，8瓶不同饮料8个人平分，本来是$A_8^8$.但现在小明不喝可乐，于是要从其他7人中选一人堵住可乐这个孔，再将剩下的7人（包括小明）$A_7^7$。 例 （1995·全国·15·j）由数字1，2，3，4，5组成的无重复数字的四位偶数的个数为（）. 解析 因为决定是否偶数的决定性因素是个位，先找个数把个位堵住$C_2^1$。 再从剩余的4个数中选择3个数$A_4^3$。 练习 （2009·陕西·9·j）从1，2，3，4，5，6，7这七个数字中任取两个奇数和两个偶数，组成没有重复数字的四位数，其中奇数的个数为（）. 练习 （2005·福建·10·j）从6人中选4人分别到巴黎、伦敦、悉尼、莫斯科四个城市游览，要求每个城市有一人游览，每人只游览一个城市，且这6人中甲、乙两人不去巴黎游览，则不同的选择方案共有（）. END其实还剩下两个模型，一个对立面，另一个染色，但是我觉得如果上面这些模型都会了，剩余这两个随便查查资料也很简单的。 从一个人找题，做题 近40年的有关排列组合的高考真题 四节自习课 啊啊啊啊啊啊啊？ 我好久没有这么认直的做过一件事情了。。。","categories":[{"name":"数学","slug":"数学","permalink":"http://chicago01.top/categories/数学/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://chicago01.top/tags/杂项/"}]},{"title":"BZOJ 刷题表","slug":"BZOJ-刷题表","date":"2019-03-19T12:15:15.000Z","updated":"2019-03-21T13:43:49.109Z","comments":true,"path":"2019/03/19/BZOJ-刷题表/","link":"","permalink":"http://chicago01.top/2019/03/19/BZOJ-刷题表/","excerpt":"转载自 这里基础（65） 巨水无比（4）：1214、3816:2B题；1000A+B；2462：输出10个1 模拟/枚举/暴力（15）：4063傻子模拟；1968小学生暴力；1218前缀和暴力；3856读英文；4106直接算；1800暴力判断；2208暴力判断（要会邻接表）；1028枚举；1789&amp;1830高能暴力；2241暴力；2120神奇的暴力；4145子集暴力；4029模拟处理；1086DFS树；1224暴力；3444暴力判","text":"转载自 这里基础（65） 巨水无比（4）：1214、3816:2B题；1000A+B；2462：输出10个1 模拟/枚举/暴力（15）：4063傻子模拟；1968小学生暴力；1218前缀和暴力；3856读英文；4106直接算；1800暴力判断；2208暴力判断（要会邻接表）；1028枚举；1789&amp;1830高能暴力；2241暴力；2120神奇的暴力；4145子集暴力；4029模拟处理；1086DFS树；1224暴力；3444暴力判 人类智慧题（17）：2463输出0或1；1192找规律；1413奥数；1432找规律；4001数学；1022简单博弈；2005暴力数学；2659数学；2173找规律；4147手推博弈；1228SG函数打表找规律；1045&amp;3293中位数；2222纯手算；2467找规律打表；3505组合数；3858处理小范围 高精度Python（11）：1213高精度开根；2656回溯高精度；2822递推高精度；2729组合数高精；1002递推高精；1089各种高精运算；1263贪心+高精度；1876高精度求最大公约数；1416&amp;1498高精算概率；1970暴力+高精 排序/贪心/二分（10）：4143排序后判断；3850排序后贪心；1034贪心；2563转化思想后排序；3170排序后处理；1816二分后判断；3969二分+贪心；1082排序后二分判断；3671贪心+暴力 其它水（7）：3098卡哈希；3214字符串处理；2456特殊方法；2751去重；2048小范围暴力大范围乱算；3668按位处理；2660递归计算 然后大家会发现小学生在BZOJ其实也能做50题，真的是题目难度最低的一个网站 图论（91） 搜索（8）：1054BFS；1024DFS；1295暴力+BFS；1053搜索（数学证明）；1306剪枝；3680模拟退火裸题；1085A*；2428模拟退火 最小生成树（7）：1083模板题；1821、2429裸题；1196二分+最小生成树；1050；3732+树上倍增；3624最小生成树+贪心 最短路（14）：1491Floyd+统计；1003DP+最短路；4152排序后最短路；2435DFS找负环；1486DFS找负环；1001网络流-&gt;最短路；2763、2662分层图+Dijstra+堆；1880最短路+拓扑；2118转化后最短路；2165倍增Floyd；3875SPFA维护DP；2330差分约束；3436差分约束+判负环；4144Dijkstra建树处理 二分图（9)：1854、1191裸题；1059、1433SB题；3175、2150最大独立点集；1562二分图求DFS序；1143Floyd+二分图；2539KM 网络流（33）：这部分比较重要，每道题写出连边方法，方便以后看 1412：源点向所有羊连无穷边，羊向狼连流量为1的边，所有狼向汇点连无穷边跑最大流 1066：源点向每只蜥蜴连1的边，蜥蜴向每个能到的石柱连边，如果蜥蜴能到边界，向汇点连无穷边跑最大流 1497：裸最小割，源点向所有客户连流量为收益的边，客户向选择的中转站连边，中转站向汇点连流量为花费的边，答案即为总收益减去流量 2561：加入的边为u,v长度L，则所有长度大于L的边不能使得u，v连通，求个最小割即可，小于同理 2768、1934：源点向所有资磁切尔西的连流量为1的边，所有不资磁切尔西的向汇点连流量为1的边，然后每一对朋友互相连流量为1的边，跑最大流即可 4177：源点向所有i连一条流量为ai的边，表示养牛；所有i向汇点连一条流量为bi的边，表示养羊；对于每条规则(i,j,k)，i和j之间互连流量为k的边；对于每个(S,a,b)，新建一个节点，如果a表示养牛，源点向该节点连流量为b的点，该节点向S中所有点连流量无穷的边；如果a表示养羊，该节点向汇点连流量为b的点，S所有点向该点连流量无穷的点，答案即为Σa[i]+b[i]-流量 3504：正向跑一遍，反方向再跑一遍最大流，判断即可 2007：懒得看了、、似乎网络流的话要姿势比较好，应该是最短路 3931、1266：最短路判断每条边是否可能在最短路上，若可能则加入，变成最小割模型，跑最大流即可 1565：如果A保护B，那么就连一条A–&gt;B的边，然后对这个图做拓扑序，把环给去掉，然后对剩下的点建图，如果A保护B则连一条B–&gt;A流量为无穷大的边，如果A的点权&gt;0则连一条S–&gt;A流量为A的点权的边，如果A得点权&lt;0则连一条A–&gt;T流量为A的点权的绝对值的边，就变成了最小割模型，用sum-流量即可 2039：源点向每个员工连流量为收益的边，每两个员工之间连Ei,j*2的边，每个员工i再向汇点连ΣEi,j的边，得到最小割模型，答案即为sum-流量 1797：首先求一个最大流。有可能在某个最小割中的边(u,v)：满流，删掉之后在残余网络中找不到u到v的路径。一定在所有最小割中的边(u,v)：满流，s出发沿残余网络能到u，v出发沿残余网络能到t。在残余网络中tarjan求强连通分量。(u,v)两点在同一SCC中说明残余网络中存在u到v路径。s和u在同一scc说明s能到u，t和v同一scc说明v能到t。 1305：二分答案ans，每个男孩拆成两个点ai和ai’，每个女孩拆成两个点bi和bi’，源点向每个ai连一条流量为ans的边，每个bi向汇点连一条流量为ans的边，如果男孩i喜欢女孩j，ai向bi连一条流量为1的边，否则ai’向bi’连一条流量为1的边，每个ai向ai’连一条流量为k的边，表示最多和k个不喜欢的女孩跳舞；每个bi’向bi连一条流量为k的边，如果流量=ans*n则可行，l=mid+1,否则r=mid 1189：二分答案time，源点向每个人连流量为1的边，把门拆成若干个点，表示在t时刻可以通过1人，每个点向汇点连流量为1的边，人向每个time时间内能到达的门连边，跑最大流判断是否能让所有人通过即可 3993：二分答案ans，源点向每个B连ans*b[i]的边，B向每个能打到的A连无穷边，A向汇点连a[i]的边，若流量等于Σa[i]则符合条件，向下面找，否则向上面找 3158&amp;3275：发现两两关系只会发生在奇数特征值和偶数特征值的点之间，源点向所有偶数特征值的点连流量为价值的边，所有奇数特征值的点向汇点连流量为价值的边，所有偶数特征值的点向有冲突的奇数特征值的点连流量无穷的边，就变成最小割模型，答案为所有收益-流量 1061：神奇的建图，用单纯形做简单点、 2245：源点向每类产品连流量为Ci的边，每类产品向能生产该产品的员工连无穷边，每个员工在每一段上向汇点连t[i]-t[i-1]流量w[i]费用的边，跑费用流即可 1927：拆点，源点向i连一条流量为1，费用为0的边，向i’连一条流量为1，费用为ai的边，i’向汇点连一条流量为1，费用为0的边；对于每条通道x,y,z，假设x&lt;y，从x向y’连一条流量为1，费用为z的边，然后跑费用流 3171：拆点，如果相邻两点可以通达，i向i’连一条流量为1，费用为0的边，否则连一条流量为1，费用为1的边，源点向每个i连一条流量为1的边，所有i’向汇点连流量为1的边，然后跑费用流 2424：拆点，源点向i连一条流量无穷，费用di的边，表示订货，i向i’连一条流量无穷费用为0的边，所有i’向汇点连流量ui费用0的边表示卖出，所有i向i+1连一条流量S费用m的边表示存储费用，然后跑费用流 3130：第一问裸流，第二问二分答案，每条边的流量为min(z[i],now)，如果仍然能满足最大流等于原来值，那么r=mid，否则l=mid+1 1834：第一问裸流，第二问直接在剩余网络上做费用流 3876：对于每一条边权为z的边x-&gt;y：从S到y连一条费用为z，流量为1的边 代表这条边至少走一次，从x到y连一条费用为z，流量为INF的边 代表这条边除了至少走的一次之外还可以随便走。对于每个点x：从x到T连一条费用为0，流量为x的出度的边，从x到1连一条费用为0，流量为INF的边，代替原图上的源和汇 1877：拆点，源点为1’，汇点为n，对于每个i和i’连一条流量为1费用为0的边表示只能走一次，对于每条有向边(x,y,z)从x’向y连一条流量为1，费用为z的边，然后跑费用流即可 1221：拆点，源点向每个i连一条流量无穷费用f的边表示直接买毛巾，每个i向i’连一条流量无穷费用0的边，每个i’向t连一条流量为ni费用0的边，表示需要的毛巾；每个i’向i+a连一条流量无穷费用fa的边，表示快洗；每个i’向i+b连一条流量无穷费用fb的边，表示慢洗 1070：把M个技术人员拆成N个点，第w个点表示给第w个顾客修车时所有顾客需要多等待的时间，每个顾客j向每个技术人员mi连一条流量为1，费用为k*a[j][i]的边，表示每个顾客对后面顾客造成的影响；源点向每个顾客连流量为1的边，每个拆出来的技术人员向汇点连一条流量为1的边 2849：和上题差不多，不过每条边要动态加，否则要T 1449：假设后面M场比赛两方都是输的，对于后面每场比赛，每赢一场的收益增加值add=c[i]-(win[i]+1)^2+d[i]-(lose[i]-1)^2-[c[i]-win[i]^2+d[i]-lose[i]^2=2win[i]c[i]-2lose[i]d[i]+c[i]+d[i]，之后win[i]++,lose[i]–。源点向每场比赛连流量为1，费用为0的边，每场比赛向双方连流量为1，费用为0的边，每支球队按照上述方法连每条边，然后求出费用加上原来收益即可 2668：对于每个点一分为三，分为p0,p1,p2，对于每个点， 如果它是原图中得黑点，连边&lt;p1,p0,c/2,0&gt;，&lt;p0,p2,(c+1)/2&gt;，&lt;st,p0,1,0&gt;； 如果它是新图中得黑点，连边&lt;p1,p0,(c+1)/2&gt;，&lt;p0,p2,c/2,0&gt;，&lt;p0,ed,1,0&gt;； 如果它在两个图中都是白点，那么连边&lt;p1,p0,c/2,0&gt;，&lt;p0,p2,c/2,0&gt;。 这样就可以体现出点容量的差异了。 然后对于原图中可以交换的两个点(i,j)连接&lt;pi2,pj1,inf,1&gt;， 那么这种边每流过1的流量就意味着(i,j)交换了一次，那么费用就是最终的答案了。 拓扑（3）：4010最小拓扑序；2535&amp;2109拓扑逆向加边 tarjan（5）：1051：直接tarjan判断强连通分量个数是否为1；2438：缩点后，ans=入度为0的连通块个数，倘若存在只有一个点的连通块，它无出边或出边指向的点均能被其它点到达则ans-1；1179:缩点后求点权最长路；1093缩点后DP统计方案；1823 2-SAT 树（11）：2783树上DFS+倍增；1509树上最长链；1912两次树上最长链；2657奇怪构图后树上最长链；1787LCA；2152点分治；3991虚树动态统计；2286、3572虚树DP；1005、1211Prufer编码 数据结构（69） 并查集（3）：1015倒着加入并查集；1202维护一个数组记录差值；4195傻逼并查集 基础数据结构（4）：1483链表启发式合并；1007、3190单调栈；1293单调队列 堆/RMQ（7）：1029贪心+堆；1216堆；2006RMQ+堆；1047二维RMQ；2809可并堆；2333可并堆各种操作；4198哈夫曼编码 哈希表（4）：1567二分+哈希判重；3555哈希后排序判断；3916分类哈希；3751HASH解方程 分块（8）：2957傻逼分块；2141、3295动态逆序对；3744在线求逆序对数；2821分块+二分；2038莫队；3289莫队+树状数组;3720块状树 树状数组（5）：1012裸题；1452三维树状数组；1878、2743离线树状数组；1176CDQ分治+树状数组 线段树（3）：1798、3212线段树Lazy；1067线段树判断 平衡树（17）：1588、3224、1208基本操作；1503权值操作；1056、1862Tire+Splay；1661简单区间操作；3223、3506Splay翻转；2733Splay启发式合并；1858、1500Splay各种操作；2752平衡树维护多个信息；1057Set；1269、1507Rope；3673、3674可持久化Rope 可持久化（2）：2588DFS序+可持久化线段树；3123DFS序+可持久化线段树+加边+启发式合并 树套树（2）：3110区间线段树套权值线段树；3196树套树各种基本操作 K-D树（4）：1941、2648基本操作；4066K-D树的重建；3489转化后三维K-D树 树链剖分（3）：3631树剖简单裸题；1036树剖基本操作；2243树剖染色；4196傻逼树剖 LCT（4）：2002、2049LCT裸题；2157LCT复杂操作；3669LCT各种操作；3091LCT各种操作+平衡树维护多个信息 字符串/计算几何/博弈论/其他（19） KMP（2）：3670KMPnext维护；3620暴力+KMP AC自动机（4）：3172模板题；1212AC自动机+DP；1030AC自动机+DP；1444AC自动机+矩乘 后缀数组（2）：1031基本题；3238后缀数组+单调栈 后缀自动机（3）：3998第K小子串；2754广义后缀自动机；3926暴力Tire构建广义 后缀树（1）：4199后缀树裸题 凸包（1）：1027凸包+最短路 随机增量（2）：2823最小圆覆盖；3564转化后最小圆覆盖 博弈论（1）：1188SG函数 三分（3）：3330三分套三分+保留位数输出；1857三分套三分；3874单调性贪心+三分 数论（34） 扩展欧几里得（1）：1407 线性筛/欧拉（6）：1607线性筛因数；3288、2190、2818线性筛欧拉函数；4173、2705logn求欧拉函数 快速幂/矩阵乘法（9）：1008快速幂；1965、2751快速幂+快速乘；1297、1898图上矩乘加速；2875、2426矩阵乘法；1875矩乘拆边构图；1009KMP+矩乘 高斯消元/线性基（9）：1013、1923高斯消元；3143高斯消元求期望；3105、2460、4004拟阵+线性基；2115找环+线性基；2844拟阵+线性基；2337期望高斯 置换群/Poyla（1）：1004置换+背包逆元 裴蜀定理（2）：2257、2299裴蜀定理 BSGS（1）：2242快速幂+逆元+BSGS 卢卡斯定理（1）：1951卢卡斯+孙子；2111排列组合 莫比乌斯反演（2）：2301容斥+莫比乌斯反演+前缀和；3994莫比乌斯反演+前缀和 FFT（1）：3527模板题 DP（71） 基本DP（31）：2748小学题；1088初一题；1207初二题；1037初三题；1296、1260基本区间DP；1025筛DP；1197SB题；1084选择DP；1032错误DP；1055区间DP；1042背包DP+容斥；1806多维DP；1237递推；1925、2431DP+前缀和优化；3174贪心+DP；1566滚数组DP；2423推方案DP；1899递推；1222神奇转化降维；1801状压DP转化；1046DP+贪心；1991区间推DP；1044二分+DP；1786、1831猜想后DP；1057悬线法；2298转化为取区间；1966、3191DP 树形DP（8）：1864树形DP，加0或1记染色方案；1060、4027、1304、4011+朱刘；1040环+外向树；1791基环树找直径；2878基环树判环DP+暴 数位DP（2）：1029基本数位DP；1833较复杂处理；3209二进制数位DP 记忆化（6）：1048、1079、3208记忆化；1090（区间）；1564（区间）；1415（期望）；3810记忆化+卡常 期望DP（4）：1076、4004倒着DP；2134、4008； 状态压缩（4）：1072、2560子集DP；1087状压DP；4197小范围状压 单调性（2）：1499单调队列优化；1563单调性优化 斜率优化（7）：1010、1911、3437模板题；1096两个前缀和；3156；1567排序+斜率；3675多维斜率优化 其它优化（3）：1264、3594树状数组优化；1492CDQ分治优化 HZWer BZOJ 做题记录BZOJ 刷题量 by hzwer (合计 740+): Q1 2014: 110+ Q2 2014: 170+ Q3 2014: 190+ Q4 2014: 180+ Q1 2015: 50+ Q2 2015: 110+ Q3 2015: 20+ 以下是各季度的刷题顺序 (按时间先后)。 刷题顺序 (Q1 2014，题目数量 110+):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111BZOJ 1050 [HAOI 2006] 旅行BZOJ 1012 [JSOI 2008] 最大数BZOJ 1008 [HNOI 2008] 越狱BZOJ 1601 [USACO 2008 Oct] 灌水BZOJ 1002 [FJOI 2007] 轮状病毒BZOJ 1003 [ZJOI 2006] 物流运输BZOJ 1192 [HNOI 2006] 鬼谷子的钱袋BZOJ 1191 [HNOI 2006] 超级英雄BZOJ 1303 [CQOI 2009] 中位数图BZOJ 1270 [Beijing WC 2008] 雷涛的小猫BZOJ 3039 [玉蟾宫]BZOJ 1059 [ZJOI 2007] 矩阵游戏BZOJ 1202 [HNOI 2005] 狡猾的商人BZOJ 1051 [HAOI 2006] 受欢迎的牛BZOJ 1001 [Beijing 2006] 狼抓兔子BZOJ 1083 [SCOI 2005] 繁忙的都市BZOJ 1588 [HNOI 2002] 营业额统计BZOJ 1208 [HNOI 2004] 宠物收养所BZOJ 1491 [NOI 2007] 社交网络BZOJ 1295 [SCOI 2009] 最长距离BZOJ 1084 [SCOI 2005] 最大子矩阵BZOJ 3109 [CQOI 2013] 新数独BZOJ 3038 上帝造题的七分钟2BZOJ 1821 [JSOI 2010] 部落划分BZOJ 1041 [HAOI 2008] 圆上的整点BZOJ 1087 [SCOI 2005] 互不侵犯BZOJ 1076 [SCOI 2008] 奖励关BZOJ 2761 [JLOI 2011] 不重复数字BZOJ 1085 [SCOI 2005] 骑士精神BZOJ 1503 [NOI 2004] 郁闷的出纳员BZOJ 1067 [SCOI 2007] 降雨量BZOJ 2321 [Beijing 2011 集训] 星器BZOJ 1834 [ZJOI 2010] 网络扩容BZOJ 1798 [AHOI 2009] 维护序列BZOJ 1934 [SHOI 2007] 善意的投票BZOJ 1066 [SCOI 2007] 蜥蜴BZOJ 1015 [JSOI 2008] 星球大战BZOJ 1877 [SDOI 2009] 晨跑BZOJ 1007 [HNOI 2008] 水平可见直线BZOJ 1497 [NOI 2006] 最大获利BZOJ 3041 水叮当的舞步BZOJ 3224 [TYVJ 1728] 普通平衡树BZOJ 1862 [ZJOI 2006] 游戏排名系统BZOJ 1056 [HAOI 2008] 排名系统BZOJ 1040 [ZJOI 2008] 骑士BZOJ 1054 [HAOI 2008] 移动玩具BZOJ 1208 [HNOI 2004] 宠物收养所BZOJ 2875 [NOI 2012] 随机数生成器BZOJ 2330 [SCOI 2011] 糖果BZOJ 1818 [CQOI 2010] 内部白点BZOJ 3098 Hash Killer IIBZOJ 1189 [HNOI 2007] 紧急疏散BZOJ 1079 [SCOI 2008] 着色方案BZOJ 1068 [SCOI 2007] 压缩BZOJ 1090 [SCOI 2003] 字符串折叠BZOJ 3245 最快路线BZOJ 1227 [SDOI 2009] 虔诚的墓主人BZOJ 1022 [SHOI 2008] 小约翰的游戏BZOJ 1188 [HNOI 2007] 分裂游戏BZOJ 1088 [SCOI 2005] 扫雷BZOJ 1013 [JSOI 2008] 球形空间产生器BZOJ 1305 [CQOI 2009] 跳舞BZOJ 2064 分裂BZOJ 1263 [SCOI 2006] 整数划分BZOJ 1221 [HNOI 2001] 软件开发BZOJ 1412 [ZJOI 2009] 狼和羊的故事BZOJ 2424 [HAOI 2010] 订货BZOJ 3211 花神游历各国BZOJ 3171 [TJOI 2013] 循环格BZOJ 2190 [SDOI 2008] 仪仗队BZOJ 1010 [HNOI 2008] 玩具装箱BZOJ 1982 [SPOJ 2021] Moving PebblesBZOJ 1345 [Baltic 2007] 序列问题BZOJ 1477 青蛙的约会BZOJ 2178 圆的面积并BZOJ 1299 [LLH 邀请赛] 巧克力棒BZOJ 1385 [Baltic 2000] Division ExpressionBZOJ 1614 [USACO 2007 Jan] Telephone Lines 架设电话线BZOJ 1230 [USACO 2008 Nov] Light Switching 开关灯BZOJ 3407 [USACO 2009 Oct] Bessie&apos;s Weight Problem 贝茜的体重问题BZOJ 1613 [USACO 2007 Jan] Running 贝茜的晨练计划BZOJ 1726 [USACO 2006 Nov] Roadblocks 第二短路BZOJ 3406 [USACO 2009 Oct] Invasion of the Milkweed 乳草的入侵BZOJ 3408 [USACO 2009 Oct] Heat Wave 热浪BZOJ 1475 方格取数BZOJ 1030 [JSOI 2007] 文本生成器BZOJ 1606 [USACO 2008 Dec] Hay for Sale 出售干草BZOJ 1222 [HNOI 2001] 产品加工BZOJ 2060 [USACO 2010 Nov] Visiting Cows 拜访奶牛BZOJ 2763 [JLOI 2011] 飞行路线BZOJ 1703 [USACO 2007 Mar] Ranking the Cows 奶牛排名BZOJ 1725 [USACO 2006 Nov] Corn Fields 牧场的安排BZOJ 1709 [USACO 2007 Oct] Super Paintball 超级弹珠BZOJ 1696 [USACO 2007 Feb] Building A New Barn 新牛舍BZOJ 2241 [SDOI 2011] 打地鼠BZOJ 1433 [ZJOI 2009] 假期的宿舍BZOJ 2456 modeBZOJ 1113 [POI 2008] 海报BZOJ 3409 [USACO 2009 Oct] Barn Echoes 牛棚回声BZOJ 1618 [USACO 2008 Nov] Buying Hay 购买干草BZOJ 1625 [USACO 2007 Dec] 宝石手镯BZOJ 1724 [USACO 2006 Nov] Fence Repair 切割木板BZOJ 1756 [Vijos 1083] 小白逛公园BZOJ 1609 [USACO 2008 Feb] Eating Together 麻烦的聚餐BZOJ 1699 [USACO 2007 Jan] Balanced Lineup 排队BZOJ 1666 [USACO 2006 Oct] Another Cow Number Game 牛奶的数字游戏BZOJ 1708 [USACO 2007 Oct] Money 奶牛的硬币BZOJ 1572 [USACO 2009 Open] 工作安排BZOJ 1571 [USACO 2009 Open] 滑雪课BZOJ 2132 圈地计划BZOJ 2127 Happiness 刷题顺序 (Q2 2014，题目数量 170+):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178BZOJ 1468 TreeBZOJ 2292 [POJ Challenge] 永远挑战BZOJ 2287 [POJ Challenge] 消失之物BZOJ 1430 小猴打架BZOJ 2252 [Beijing 2010 WC] 矩阵距离BZOJ 1968 [AHOI 2005] 约数研究BZOJ 1691 [USACO 2007 Dec] 挑剔的美食家BZOJ 1635 [USACO 2007 Jan] Tallest Cow 最高的奶牛BZOJ 1616 [USACO 2008 Mar] Cow Travelling 游荡的奶牛BZOJ 1624 [USACO 2008 Open] Clear and Present Danger 寻宝之路BZOJ 1648 [USACO 2006 Dec] Cow Picnic 奶牛野餐BZOJ 1620 [USACO 2008 Nov] Time Management 时间管理BZOJ 1232 [USACO 2008 Nov] 安慰奶牛BZOJ 1121 [POI 2008] 激光发射器BZOJ 1599 [USACO 2008 Oct] 笨重的石子BZOJ 1660 [USACO 2006 Nov] Bad Hair Day 乱发节BZOJ 1669 [USACO 2006 Oct] Hungry Cows 饥饿的奶牛BZOJ 1611 [USACO 2008 Feb] Meteor Shower 流星雨BZOJ 1602 [USACO 2008 Oct] 牧场行走BZOJ 1036 [ZJOI 2008] 树的统计BZOJ 2243 [SDOI 2011] 染色BZOJ 1455 罗马游戏BZOJ 1677 [USACO 2005 Jan] Sumsets 求和BZOJ 1251 序列终结者BZOJ 1657 [USACO 2006 Mar] Mooo 奶牛的歌声BZOJ 1579 [USACO 2009 Feb] Revamping Trails 道路升级BZOJ 1610 [USACO 2008 Feb] Line 连线游戏BZOJ 1646 [USACO 2007 Open] Catch that Cow 抓住那只牛BZOJ 1687 [USACO 2005 Open] Navigating the City 城市交通BZOJ 3170 [TJOI 2013] 松鼠聚会BZOJ 3390 [USACO 2004 Dec] Bad Cowtractors 牛的报复BZOJ 2463 [中山市选 2009] 谁能赢呢BZOJ 1621 [USACO 2008 Open] Roads Around the Farm 分叉路口BZOJ 1441 MinBZOJ 1816 [CQOI 2010] 扑克牌BZOJ 1465 糖果传递BZOJ 1641 [USACO 2007 Nov] Cow Hurdles 奶牛跨栏BZOJ 1639 [USACO 2007 Mar] Monthly Expense 月度开支BZOJ 1739 [USACO 2005 Mar] Space Elevator 太空电梯BZOJ 1652 [USACO 2006 Feb] Treats for the CowsBZOJ 1689 [USACO 2005 Open] Muddy Roads 泥泞的路BZOJ 1671 [USACO 2005 Dec] Knights of Ni 骑士BZOJ 1045 [HAOI 2008] 糖果传递BZOJ 3524 [POI 2014] CouriersBZOJ 3196 [TYVJ 1730] 二逼平衡树BZOJ 1033 [ZJOI 2008] 杀蚂蚁BZOJ 3223 [TYVJ 1729] 文艺平衡树BZOJ 1874 [Beijing 2009 WC] 取石子游戏BZOJ 1972 [SDOI 2010] 猪国杀BZOJ 1901 [ZJU 2112] Dynamic RankingsBZOJ 1482 可以看到的树BZOJ 2038 [国家集训队 2009] 小 Z 的袜子BZOJ 2396 神奇的矩阵BZOJ 1858 [SCOI 2010] 序列操作BZOJ 2768 [JLOI 2010] 冠军调查BZOJ 1500 [NOI 2005] 维修数列BZOJ 2748 [HAOI 2012] 音量调节BZOJ 3212 [PKU 3468] A Simple Problem with IntegersBZOJ 1483 [HNOI 2009] 梦幻布丁BZOJ 1426 收集邮票BZOJ 3275 NumberBZOJ 1863 [ZJOI 2006] 皇帝的烦恼BZOJ 1070 [SCOI 2007] 修车BZOJ 2879 [NOI 2012] 美食节BZOJ 1207 [HNOI 2004] 打鼹鼠BZOJ 1432 [ZJOI 2009] FunctionBZOJ 1031 [JSOI 2007] 字符加密BZOJ 1593 [USACO 2008 Feb] Hotel 旅馆BZOJ 1037 [ZJOI 2008] 生日聚会BZOJ 2288 [POJ Challenge] 生日礼物BZOJ 1150 [CTSC 2007] 数据备份BZOJ 1787 [AHOI 2008] 紧急集合BZOJ 2697 特技飞行BZOJ 3293 [CQOI 2011] 分金币BZOJ 3280 小 R 的烦恼BZOJ 1800 [AHOI 2009] 飞行棋BZOJ 1854 [SCOI 2010] 游戏BZOJ 1009 [HNOI 2008] GT 考试BZOJ 1458 士兵占领BZOJ 1293 [SCOI 2009] 生日礼物BZOJ 1016 [JSOI 2008] 最小生成树计数BZOJ 1878 [SDOI 2009] HH 的项链BZOJ 1116 [POI 2008] CLOBZOJ 1115 [POI 2009] 石子游戏BZOJ 1755 [USACO 2005 Qua] Bank InterestBZOJ 2743 [HEOI 2012] 采花BZOJ 2208 [JSOI 2010] 连通数BZOJ 3505 [CQOI 2014] 数三角形BZOJ 1876 [SDOI 2009] SuperGCDBZOJ 2318 [SPOJ 4060] Game with Probability ProblemBZOJ 1603 [USACO 2008 Oct] 打谷机BZOJ 3339 RMQ ProblemBZOJ 1898 [ZJOI 2005] 沼泽鳄鱼BZOJ 1529 [POI 2005] Piggy BanksBZOJ 1597 [USACO 2008 Mar] 土地购买BZOJ 1911 [APIO 2010] 特别行动队BZOJ 1096 [ZJOI 2007] 仓库建设BZOJ 2429 [HAOI 2006] 聪明的猴子BZOJ 3585 MexBZOJ 1782 [USACO 2010 Feb] Slowdown 慢慢游BZOJ 1231 [USACO 2008 Nov] Mixup2 混乱的奶牛BZOJ 1827 [USACO 2010 Mar] Gather 奶牛大集会BZOJ 1690 [USACO 2007 Dec] 奶牛的旅行BZOJ 1717 [USACO 2006 Dec] Milk Patterns 产奶的模式BZOJ 1668 [USACO 2006 Oct] Cow Pie Treasures 馅饼里的财富BZOJ 1711 [USACO 2007 Open] Dining 吃饭BZOJ 1233 [USACO 2009 Open] 干草堆BZOJ 1296 [SCOI 2009] 粉刷匠BZOJ 1337 最小圆覆盖BZOJ 1336 [Balkan 2002] Alien 最小圆覆盖BZOJ 1260 [CQOI 2007] 涂色BZOJ 1053 [HAOI 2007] 反素数BZOJ 1600 [USACO 2008 Oct] 建造栅栏BZOJ 1617 [USACO 2008 Mar] River Crossing 渡河问题BZOJ 1612 [USACO 2008 Jan] Cow Contest 奶牛的比赛BZOJ 1607 [USACO 2008 Dec] Patting Heads 轻拍牛头BZOJ 1626 [USACO 2007 Dec] Building Roads 修建道路BZOJ 1679 [USACO 2005 Jan] Moo Volume 奶牛的呼声BZOJ 1631 [USACO 2007 Feb] Cow Party 奶牛聚会BZOJ 1636 [USACO 2007 Jan] Balanced LineupBZOJ 1642 [USACO 2007 Nov] Milking Time 挤奶时间BZOJ 1627 [USACO 2007 Dec] 穿越泥地BZOJ 1629 [USACO 2007 Demo] Cow AcrobatsBZOJ 1634 [USACO 2007 Jan] Protecting the Flowers 护花BZOJ 2442 [USACO 2011 Open] 修剪草坪BZOJ 1715 [USACO 2006 Dec] Wormholes 虫洞BZOJ 1797 [AHOI 2009] Mincut 最小割BZOJ 1004 [HNOI 2008] CardsBZOJ 1898 [ZJOI 2005] Swamp 沼泽鳄鱼BZOJ 1028 [JSOI 2007] 麻将BZOJ 1196 [HNOI 2006] 公路修建问题BZOJ 1112 [POI 2008] 砖块BZOJ 1828 [USACO 2010 Mar] 农场分配BZOJ 1707 [USACO 2007 Nov] Tanning 分配防晒霜BZOJ 1651 [USACO 2006 Feb] Stall Reservations 专用牛棚BZOJ 2506 CalcBZOJ 1537 [POI 2005] The BusBZOJ 1452 [JSOI 2009] CountBZOJ 3155 Preprefix SumBZOJ 2388 旅行规划BZOJ 1592 [USACO 2008 Feb] Making the Grade 路面修整BZOJ 1211 [HNOI 2004] 树的计数BZOJ 1005 [HNOI 2008] 明明的烦恼BZOJ 1061 [NOI 2008] 志愿者招募BZOJ 1407 [NOI 2002] SavageBZOJ 1408 [NOI 2002] RobotBZOJ 1726 [USACO 2006 Nov] Roadblocks 次短路BZOJ 1589 [USACO 2008 Dec] Trick or Treat on the Farm 采集糖果BZOJ 2661 [Beijing 2012 WC] 连连看BZOJ 1359 [Baltic 209] CandyBZOJ 3056 升降梯口BZOJ 2510 弱题BZOJ 1801 [AHOI 2009] 中国象棋BZOJ 2391 Cirno 的忧郁BZOJ 3531 [SDOI 2014] 旅行BZOJ 1146 [CTSC 2008] 网络管理BZOJ 3262 陌上花开BZOJ 1468 TreeBZOJ 1103 [POI 2007] 大都市BZOJ 2818 GCDBZOJ 1532 [POI 2005] DicingBZOJ 1705 [SDOI 2012] Longge 的问题BZOJ 3156 防御准备BZOJ 1179 [APIO 2009] ATMBZOJ 3632 外太空旅行BZOJ 2005 [NOI 2010] 能量采集BZOJ 2588 [SPOJ 10628] Count on a treeBZOJ 3295 [CQOI 2011] 动态逆序对BZOJ 2055 80 人环游世界BZOJ 2502 清理雪道BZOJ 1006 [HNOI 2008] 神奇的国度BZOJ 1026 [SCOI 2009] Windy 数BZOJ 1381 [Baltic 2001] KnightsBZOJ 2002 [HNOI 2010] Bounce 弹飞绵羊BZOJ 1492 [NOI 2007] 货币兑换BZOJ 2430 [POI 2003] ChocolateBZOJ 3504 [CQOI 2014] 危桥BZOJ 3538 [USACO 2014 Open] Dueling GPS 刷题顺序 (Q3 2014，题目数量 190+):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194BZOJ 1408 [NOI 2002] RobotBZOJ 1726 [USACO 2006 Nov] Roadblocks 第二短路BZOJ 1589 [USACO 2008 Dec] Trick or Treat on the Farm 采集糖果BZOJ 2661 [Beijing WC 2012] 连连看BZOJ 1359 [Baltic 209] CandyBZOJ 3056 升降梯口BZOJ 2510 弱题BZOJ 1801 [AHOI 2009] Chess 中国象棋BZOJ 2391 Cirno 的忧郁BZOJ 3531 [SDOI 2014] 旅行BZOJ 1146 [CTSC 2008] 网络管理 NetworkBZOJ 2396 神奇的矩阵BZOJ 3262 陌上花开BZOJ 1468 TreeBZOJ 1103 [POI 2007] 大都市 megBZOJ 2818 GcdBZOJ 1532 [POI 2005] Kos-DicingBZOJ 2705 [SDOI 2012] Longge 的问题BZOJ 3156 防御准备BZOJ 1179 [APIO 2009] AtmBZOJ 3632 外太空旅行BZOJ 2005 [NOI 2010] 能量采集BZOJ 2588 [SPOJ 10628] Count on a treeBZOJ 3295 [CQOI 2011] 动态逆序对BZOJ 2055 八十人环游世界BZOJ 2502 清理雪道BZOJ 1006 [HNOI 2008] 神奇的国度BZOJ 1026 [SCOI 2009] Windy 数BZOJ 1381 [Baltic 2001] KnightsBZOJ 2002 [HNOI 2010] Bounce 弹飞绵羊BZOJ 1492 [NOI 2007] 货币兑换 CashBZOJ 2430 [POI 2003] ChocolateBZOJ 3504 [CQOI 2014] 危桥BZOJ 3538 [USACO 2014 Open] Dueling GPSBZOJ 1656 [USACO 2006 Jan] The Grove 树木BZOJ 1619 [USACO 2008 Nov] Guarding the Farm 保卫牧场BZOJ 3399 [USACO 2009 Mar] Sand Castle 城堡BZOJ 2724 [Violet 6] 蒲公英BZOJ 1640 [USACO 2007 Nov] Best Cow Line 队列变换BZOJ 1692 [USACO 2007 Dec] 队列变换BZOJ 1596 [USACO 2008 Jan] 电话网络BZOJ 1574 [USACO 2009 Jan] 地震损坏 DamageBZOJ 1754 [USACO 2005 Qua] Bull MathBZOJ 1753 [USACO 2005 Qua] Who&apos;s in the MiddleBZOJ 3396 [USACO 2009 Jan] Total flow 水流BZOJ 1806 [IOI 2007] Miners 矿工配餐BZOJ 2821 作诗 PoetizeBZOJ 2561 最小生成树BZOJ 2179 FFT 快速傅立叶BZOJ 1925 [SDOI 2010] 地精部落BZOJ 2173 整数的 LQP 拆分BZOJ 1251 序列终结者BZOJ 1500 [NOI 2005] 维修数列BZOJ 1682 [USACO 2005 Mar] Out of Hay 干草危机BZOJ 1688 [USACO 2005 Open] Disease Manangement 疾病管理BZOJ 1637 [USACO 2007 Mar] Balanced LineupBZOJ 1615 [USACO 2008 Mar] The Loathesome Hay Baler 麻烦的干草打包机BZOJ 1628 [USACO 2007 Demo] City skylineBZOJ 1650 [USACO 2006 Dec] River Hopscotch 跳石子BZOJ 1643 [USACO 2007 Oct] Bessie&apos;s Secret Pasture 贝茜的秘密草坪BZOJ 1653 [USACO 2006 Feb] Backward Digit SumsBZOJ 1011 [HNOI 2008] 遥远的行星BZOJ 1633 [USACO 2007 Feb] The Cow Lexicon 牛的词典BZOJ 1649 [USACO 2006 Dec] Cow Roller CoasterBZOJ 2201 彩色圆环BZOJ 2141 排队BZOJ 2325 [ZJOI 2011] 道馆之战BZOJ 1638 [USACO 2007 Mar] Cow Traffic 奶牛交通BZOJ 1623 [USACO 2008 Open] Cow Cars 奶牛飞车BZOJ 1644 [USACO 2007 Oct] Obstacle Course 障碍训练课BZOJ 3668 [NOI 2014] 起床困难综合症BZOJ 3626 [LNOI2014] LCABZOJ 3671 [NOI 2014] 随机数生成器BZOJ 1500 [NOI 2005] 维修数列BZOJ 2002 [HNOI 2010] Bounce 弹飞绵羊BZOJ 1507 [NOI 2003] EditorBZOJ 1493 [NOI 2007] 项链工厂BZOJ 3669 [NOI 2014] 魔法森林BZOJ 3671 [NOI 2014] 随机数生成器BZOJ 3278 ⑨ (Nine)BZOJ 1751 [USACO 2005 Qua] Lake CountingBZOJ 1752 [USACO 2005 Qua] Til the Cows Come HomeBZOJ 3545 [ONTAK 2010] PeaksBZOJ 3299 [USACO 2011 Open] Corn Maze 玉米迷宫BZOJ 1683 [USACO 2005 Nov] City skyline 城市天际线BZOJ 1664 [USACO 2006 Open] County Fair Events 参加节日庆祝BZOJ 1672 [USACO 2005 Dec] Cleaning Shifts 清理牛棚BZOJ 1645 [USACO 2007 Open] City Horizon 城市地平线BZOJ 1622 [USACO 2008 Open] Word Power 名字的能量BZOJ 2020 [USACO 2010 Jan] Buying Feed, IIBZOJ 2101 [USACO 2010 Dec] Treasure Chest 藏宝箱BZOJ 1349 [Baltic 2006] SquintBZOJ 1684 [USACO 2005 Oct] Close EncounterBZOJ 3626 [LNOI 2014] LCABZOJ 2015 [USACO 2010 Feb] Chocolate GivingBZOJ 1673 [USACO 2005 Dec] Scales 天平BZOJ 2100 [USACO 2010 Dec] Apple DeliveryBZOJ 1697 [USACO 2007 Feb] Cow Sorting 牛排序BZOJ 1710 [USACO 2007 Open] Cheappal 廉价回文BZOJ 1584 [USACO 2009 Mar] Cleaning Up 打扫卫生BZOJ 2049 [SDOI 2008] Cave 洞穴勘测BZOJ 2733 [HNOI 2012] 永无乡BZOJ 3673 可持久化并查集 by zkyBZOJ 1864 [ZJOI 2006] 三色二叉树BZOJ 1861 [ZJOI 2006] Book 书架BZOJ 1674 [USACO 2005] Part AcquisitionBZOJ 1685 [USACO 2005 Oct] Allowance 津贴BZOJ 1269 [AHOI 2006] 文本编辑器 EditorBZOJ 2304 [APIO 2011] 寻路BZOJ 2346 [Baltic 2011] LampBZOJ 2548 [CTSC 2002] 灭鼠行动BZOJ 1935 [SHOI 2007] Tree 园丁的烦恼BZOJ 1576 [USACO 2009 Jan] 安全路经 TravelBZOJ 2631 TreeBZOJ 1014 [JSOI 2008] 火星人 PrefixBZOJ 3000 Big NumberBZOJ 2594 [WC 2006] 水管局长数据加强版BZOJ 1029 [JSOI 2007] 建筑抢修BZOJ 3040 最短路 (Road)BZOJ 1907 树的路径覆盖BZOJ 3192 [JLOI 2013] 删除物品BZOJ 2662 [Beijing WC 2012] 冻结BZOJ 1058 [ZJOI 2007] 报表统计BZOJ 3629 [JLOI 2014] 聪明的燕姿BZOJ 1046 [HAOI 2007] 上升序列BZOJ 3032 七夕祭BZOJ 3033 太鼓达人BZOJ 3680 吊打 XXXBZOJ 2212 [POI 2011] Tree RotationsBZOJ 2982 CombinationBZOJ 1324 Exca王者之剑BZOJ 3551 [ONTAK 2010] Peaks 加强版BZOJ 1024 [SCOI 2009] 生日快乐BZOJ 1257 [CQOI 2007] 余数之和 SumBZOJ 1047 [HAOI 2007] 理想的正方形BZOJ 2301 [HAOI 2011] Problem BBZOJ 1101 [POI 2007] ZapBZOJ 1034 [ZJOI 2008] 泡泡堂 BNBBZOJ 1044 [HAOI 2008] 木棍分割BZOJ 1069 [SCOI 2007] 最大土地面积BZOJ 3693 圆桌会议BZOJ 3694 最短路BZOJ 3688 折线统计BZOJ 3689 异或之BZOJ 2783 [JLOI 2012] 树BZOJ 3695 滑行BZOJ 2251 [Beijing 2010 WC] 外星联络BZOJ 1647 [USACO 2007 Open] Fliptile 翻格子游戏BZOJ 3704 昊昊的机油之 GRSTBZOJ 3702 二叉树BZOJ 3698 XWW 的难题BZOJ 1655 [USACO 2006 Jan] Dollar Dayz 奶牛商店BZOJ 2719 [Violet 4] 银河之星BZOJ 3707 圈地BZOJ 1468 TreeBZOJ 2152 聪聪可可BZOJ 2599 [IOI 2011] RaceBZOJ 3479 [USACO 2014 Mar] Watering the FieldsBZOJ 3685 普通 van Emde Boas 树BZOJ 1123 [POI 2008] BLOBZOJ 1307 玩具BZOJ 1318 [SPOJ 744] Longest PermutationBZOJ 3029 守卫者的挑战BZOJ 1552 [CERC 2007] Robotic SortBZOJ 3506 [CQOI 2014] 排序机械臂BZOJ 3391 [USACO 2004 Dec] Tree Cutting 网络破坏BZOJ 3401 [USACO 2009 Mar] Look Up 仰望BZOJ 3403 [USACO 2009 Open] Cow Line 直线上的牛BZOJ 3514 [Codechef MAR 14] GERALD07 加强版BZOJ 1604 [USACO 2008 Open] Cow Neighborhoods 奶牛的邻居BZOJ 2364 城市美化BZOJ 1025 [SCOI 2009] 游戏BZOJ 3713 [PA 2014] IloczynBZOJ 1670 [USACO 2006 Oct] Building the Moat 护城河的挖掘BZOJ 3709 [PA 2014] BohaterBZOJ 3715 [PA 2014] LustraBZOJ 1951 [SDOI 2010] 古代猪文BZOJ 3687 简单题BZOJ 1271 [Beijing WC 2008] 秦腾与教学评估BZOJ 3282 TreeBZOJ 2102 [USACO 2010 Dec] The Trough GameBZOJ 1057 [ZJOI 2007] 棋盘制作BZOJ 1927 [SDOI 2010] 星际竞速BZOJ 3706 反色刷BZOJ 2555 SubStringBZOJ 3631 [JLOI 2014] 松鼠的新家BZOJ 3402 [USACO 2009 Open] Hide and Seek 捉迷藏BZOJ 3697 采药人的路径BZOJ 3540 [USACO 2014 Open] Fair PhotographyBZOJ 3714 [PA 2014] KuglarzBZOJ 2006 [NOI 2010] 超级钢琴BZOJ 3410 [USACO 2009 Dec] Selfish Grazing 自私的食草者BZOJ 3412 [USACO 2009 Dec] Music Notes 乐谱BZOJ 3065 带插入区间 K 小值 刷题顺序 (Q4 2014，题目数量 180+):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181BZOJ 3398 [USACO 2009 Feb] Bullcow 牡牛和牝牛BZOJ 3389 [USACO 2004 Dec] Cleaning Shifts 安排值班BZOJ 3297 [USACO 2011 Open] ForgotBZOJ 1391 [CEOI 2008] OrderBZOJ 1598 [USACO 2008 Mar] 牛跑步BZOJ 1770 [USACO 2009 Nov] Lights 灯BZOJ 1857 [SCOI 2010] 传送带BZOJ 3433 [USACO 2014 Jan] Recording the MoolympicsBZOJ 1630 [USACO 2007 Demo] Ant CountingBZOJ 2023 [USACO 2005 Nov] Ant Counting 数蚂蚁BZOJ 1632 [USACO 2007 Feb] Lilypad PondBZOJ 1098 [POI 2007] 办公楼 BiuBZOJ 1093 [ZJOI 2007] 最大半连通子图BZOJ 3110 [ZJOI 2013] K 大数查询BZOJ 1833 [ZJOI 2010] Count 数字计数BZOJ 2324 [ZJOI 2011] 营救皮卡丘BZOJ 1072 [SCOI 2007] 排列 PermutationBZOJ 1023 [SHOI 2008] Cactus 仙人掌图BZOJ 1108 [POI 2007] 天然气管道 GazBZOJ 1106 [POI 2007] 立方体大作战 TetBZOJ 1132 [POI 2008] TroBZOJ 1131 [POI 2008] StaBZOJ 1119 [POI 2009] SLOBZOJ 1135 [POI 2009] LyzBZOJ 1038 [ZJOI 2008] 瞭望塔BZOJ 2618 [CQOI 2006] 凸多边形BZOJ 1102 [POI 2007] 山峰和山谷 GrzBZOJ 1097 [POI 2007] 旅游景点 AtrBZOJ 2079 [POI 2010] GuildsBZOJ 2091 [POI 2010] The Minima GameBZOJ 1110 [POI 2007] 砝码 OdwBZOJ 1520 [POI 2006] Szk-SchoolsBZOJ 2014 [USACO 2010 Feb] Chocolate BuyingBZOJ 2016 [USACO 2010] Chocolate EatingBZOJ 2144 跳跳棋BZOJ 2143 飞飞侠BZOJ 2145 悄悄话BZOJ 2708 [Violet 1] 木偶BZOJ 2709 [Violet 1] 迷宫花园BZOJ 1914 [USACO 2010 Open] Triangle Counting 数三角形BZOJ 1705 [USACO 2007 Nov] Telephone Wire 架设电话线BZOJ 1665 [USACO 2006 Open] The Climbing Wall 攀岩BZOJ 3251 树上三角形BZOJ 3417 [POI 2013] Tales of SeafaringBZOJ 3431 [USACO 2014 Jan] Bessie Slows DownBZOJ 3721 [PA 2014] Final BazarekBZOJ 2789 [POI 2012] LettersBZOJ 3555 [CTSC 2014] 企鹅 QQBZOJ 3436 小 K 的农场BZOJ 1978 [Beijing 2010] 取数游戏 GameBZOJ 2659 [Beijing WC 2012] 算不出的算式BZOJ 1193 [HNOI 2006] 马步距离BZOJ 2734 [HNOI 2012] 集合选数BZOJ 2730 [HNOI 2012] 矿场搭建BZOJ 1567 [JSOI 2008] Blue Mary 的战役地图BZOJ 1086 [SCOI 2005] 王室联邦BZOJ 1089 [SCOI 2003] 严格 n 元树BZOJ 1555 KD 之死BZOJ 1556 墓地秘密BZOJ 3751 [NOIP 2014] 解方程BZOJ 3427 [POI 2013] Byte ComputerBZOJ 1017 [JSOI 2008] 魔兽地图 DotRBZOJ 3043 IncDec SequenceBZOJ 3252 攻略BZOJ 3226 [SDOI 2008] 校门外的区间BZOJ 2259 [OIBH] 新型计算机BZOJ 3437 小 P 的牧场BZOJ 2405 数字BZOJ 2216 [POI 2011] Lightning ConductorBZOJ 1563 [NOI 2009] 诗人小 GBZOJ 2793 [POI 2012] VouchersBZOJ 2096 [POI 2010] PilotsBZOJ 3781 小 B 的询问BZOJ 2407 探险BZOJ 2276 [POI 2011] TemperatureBZOJ 1095 [ZJOI 2007] Hide 捉迷藏BZOJ 3757 苹果树BZOJ 3052 [WC 2013] 糖果公园BZOJ 1042 [HAOI 2008] 硬币购物BZOJ 1043 [HAOI 2008] 下落的圆盘BZOJ 1060 [ZJOI 2007] 时态同步BZOJ 1048 [HAOI 2007] 分割矩阵BZOJ 1049 [HAOI 2006] 数字序列BZOJ 1052 [HAOI 2007] 覆盖问题BZOJ 1055 [HAOI 2008] 玩具取名BZOJ 2298 [HAOI 2011] Problem ABZOJ 2300 [HAOI 2011] 防线修建BZOJ 2428 [HAOI 2006] 均分数据BZOJ 1145 [CTSC 2008] 图腾 TotemBZOJ 3100 排列BZOJ 1758 [WC 2010] 重建计划BZOJ 3289 Mato的文件管理BZOJ 3761 ZhenhuanBZOJ 1398 [Vijos 1382] 寻找主人 NecklaceBZOJ 2223 [COCI 2009] PATULJCIBZOJ 3769 [SPOJ 8549] BST againBZOJ 2342 [SHOI 2011] 双倍回文BZOJ 2732 [HNOI 2012] 射箭BZOJ 1216 [HNOI 2003] 操作系统BZOJ 1528 [POI 2005] Sam-Toy CarsBZOJ 2938 [POI 2000] 病毒BZOJ 2434 [NOI 2011] 阿狸的打字机BZOJ 2802 [POI 2012] Warehouse StoreBZOJ 3784 树上的路径BZOJ 3770 疯狂的限制BZOJ 3653 谈笑风生BZOJ 2819 NimBZOJ 2656 [ZJOI 2012] 数列 (Sequence)BZOJ 2751 [HAOI 2012] 容易题 (Easy)BZOJ 3174 [TJOI 2013] 拯救小矮人BZOJ 1027 [JSOI 2007] 合金BZOJ 2929 [POI 1999] 洞穴攀行BZOJ 3172 [TJOI 2013] 单词BZOJ 2165 大楼BZOJ 2716 [Violet 3] 天使玩偶BZOJ 2648 SJY 摆棋子BZOJ 2435 [NOI 2011] 道路修建BZOJ 3306 树BZOJ 3790 神奇项链BZOJ 2929 [POI 1999] 洞穴攀行BZOJ 2165 大楼BZOJ 1036 [ZJOI 2008] 树的统计 CountBZOJ 2115 [WC 2011] XorBZOJ 2006 [NOI 2010] 超级钢琴BZOJ 1487 [HNOI 2009] 无归岛BZOJ 2427 [HAOI 2010] 软件安装BZOJ 1226 [SDOI 2009] 学校食堂 DiningBZOJ 1355 [Baltic 2009] Radio TransmissionBZOJ 1823 [JSOI 2010] 满汉全席BZOJ 2348 [Baltic 2011] PlagiarismBZOJ 1822 [JSOI 2010] Frozen Nova 冷冻波BZOJ 2882 工艺BZOJ 3158 千钧一发BZOJ 3791 作业BZOJ 1954 [POJ 3764] The Xor-Longest PathBZOJ 3261 最大异或和BZOJ 2763 [JLOI 2011] 飞行路线BZOJ 1923 [SDOI 2010] 外星千足虫BZOJ 2431 [HAOI 2009] 逆序对数列BZOJ 1334 [Baltic 2008] ElectBZOJ 3767 A+B Problem 加强版BZOJ 3732 NetworkBZOJ 2893 征服王BZOJ 2007 [NOI 2010] 海拔BZOJ 2299 [HAOI 2011] 向量BZOJ 1565 [NOI 2009] 植物大战僵尸BZOJ 1566 [NOI 2009] 管道取珠BZOJ 1367 [Baltic 2004] SequenceBZOJ 2809 [APIO 2012] DispatchingBZOJ 1924 [SDOI 2010] 所驼门王的宝藏BZOJ 3166 [HEOI 2013] AloBZOJ 3674 可持久化并查集加强版BZOJ 2199 [USACO 2011 Jan] 奶牛议会BZOJ 3750 [POI 2015] PieczęćBZOJ 3747 [POI 2015] KinomanBZOJ 2595 [WC 2008] 游览计划BZOJ 3105 [CQOI 2013] 新 Nim 游戏BZOJ 1449 [JSOI 2009] 球队收益BZOJ 2895 球队预算BZOJ 3809 Gty 的傻妹子序列BZOJ 2721 [Violet 5] 樱花BZOJ 2282 [SDOI 2011] 消防BZOJ 2718 [Violet 4] 毕业旅行BZOJ 1143 [CTSC 2008] 祭祀 RiverBZOJ 2281 [SDOI 2011] 黑白棋BZOJ 1922 [SDOI 2010] 大陆争霸BZOJ 1486 [HNOI 2009] 最小圈BZOJ 1485 [HNOI 2009] 有趣的数列BZOJ 2822 [AHOI 2012] 树屋阶梯BZOJ 2333 [SCOI 2011] 棘手的操作BZOJ 1078 [SCOI 2008] 斜堆BZOJ 1082 [SCOI 2005] 栅栏BZOJ 1185 [HNOI 2007] 最小矩形覆盖BZOJ 3190 [JLOI 2013] 赛车BZOJ 2400 [SPOJ 839] Optimal MarksBZOJ 2282 [SDOI 2011] 消防BZOJ 2186 [SDOI 2008] 沙拉公主的困惑BZOJ 2242 [SDOI 2011] 计算器BZOJ 2823 [AHOI 2012] 信号塔BZOJ 2438 [中山市选 2011] 杀人游戏BZOJ 1965 [AHOI 2005] SHUFFLE 洗牌 刷题顺序 (Q1 2015，题目数量 50+):1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556BZOJ 2756 [SCOI 2012] 奇怪的游戏BZOJ 1176 [Balkan 2007] MokiaBZOJ 3696 化合物BZOJ 1367 [Baltic 2004] SequenceBZOJ 1468 TreeBZOJ 3648 寝室管理BZOJ 2527 [POI 2011] MeteorsBZOJ 2738 矩阵乘法BZOJ 3105 [CQOI 2013] 新 Nim 游戏BZOJ 2460 [Beijing 2011] 元素BZOJ 2151 种树BZOJ 2389 XY 的赛车场BZOJ 2956 模积和BZOJ 3239 Discrete LoggingBZOJ 2820 YY 的 GCDBZOJ 3529 [SDOI 2014] 数表BZOJ 2754 [SCOI 2012] 喵星球上的点名BZOJ 2286 [SDOI 2011] 消耗战BZOJ 3856 MonsterBZOJ 3611 [HEOI 2014] 大工程BZOJ 1370 [Baltic 2003] Gang 团伙BZOJ 2073 [POI 2004] PRZBZOJ 3813 奇数国BZOJ 3876 [AHOI &amp; JSOI 2014] 支线剧情BZOJ 3772 精神污染BZOJ 3162 独钓寒江雪BZOJ 2229 [ZJOI 2011] 最小割BZOJ 3173 [TJOI 2013] 最长上升子序列BZOJ 1997 [HNOI 2010] PlanarBZOJ 2004 [HNOI 2010] Bus 公交线路BZOJ 1998 [HNOI 2010] Fsk 物品调度BZOJ 2815 [ZJOI 2012] 灾难BZOJ 3144 [HNOI 2013] 切糕BZOJ 1036 [ZJOI 2008] 树的统计 CountBZOJ 2829 信用卡凸包BZOJ 3270 博物馆BZOJ 2157 旅游BZOJ 1406 [AHOI 2007] 密码箱BZOJ 3667 Rabin-Miller 算法BZOJ 1369 [Baltic 2003] GemBZOJ 3036 绿豆蛙的归宿BZOJ 3884 上帝与集合的正确用法BZOJ 3544 [ONTAK 2010] Creative AccountingBZOJ 3728 [PA 2014] Final ZarowkiBZOJ 1318 [SPOJ 744] Longest PermutationBZOJ 3100 排列BZOJ 2796 [POI 2012] Fibonacci RepresentationBZOJ 3907 网格BZOJ 2590 [USACO 2012 Feb] Cow CouponsBZOJ 2086 [POI 2010] BlocksBZOJ 3850 ZCC Loves CodefiresBZOJ 1283 序列BZOJ 3894 文理分科BZOJ 3208 花神的秒题计划ⅠBZOJ 1962 模型王子BZOJ 1875 [SDOI 2009] HH 去散步 刷题顺序 (Q2 2015，题目数量 110+):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110BZOJ 4048 [CERC 2014] Outer space invadersBZOJ 1706 [USACO 2007 Nov] relays 奶牛接力跑BZOJ 3955 [WF 2013] Surely You CongestBZOJ 3953 [WF 2013] Self-AssemblyBZOJ 3971 [WF 2013] МатрёшкаBZOJ 3928 [CERC 2014] Outer space invadersBZOJ 3967 [WF 2013] FactorsBZOJ 2210 [POJ 1379] Run AwayBZOJ 1844 [CERC 1999] Run AwayBZOJ 2258 [POJ 2758] Checking the Text 文本校对BZOJ 1417 [POJ 3156] InterconnectBZOJ 1908 [POJ 2054] Color a TreeBZOJ 2022 [POJ 1837] BalanceBZOJ 1338 [POJ 1981] Circle and Points 单位圆覆盖BZOJ 4057 [CERC 2012] KingdomsBZOJ 4052 [CERC 2013] Magical GCDBZOJ 4080 [WF 2014] Sensor NetworkBZOJ 4063 [CERC 2012] DartsBZOJ 3169 [CERC 2012] ConservationBZOJ 4082 [WF 2014] SurveillanceBZOJ 3972 [WF 2013] Pirate ChestBZOJ 1662 [USACO 2006 Nov] Round Numbers 圆环数BZOJ 2017 [USACO 2009 Nov] 硬币游戏BZOJ 1675 [USACO 2005 Feb] Rigging the Bovine Election 竞选划区BZOJ 1661 [USACO 2006 Nov] Big Square 巨大正方形BZOJ 1654 [USACO 2006 Jan] The Cow Prom 奶牛舞会BZOJ 4077 [WF 2014] MessengerBZOJ 3308 九月的咖啡店BZOJ 2661 [Beijing WC 2012] 连连看BZOJ 4135 [FJOI 2015] 世界树BZOJ 4137 [FJOI 2015] 火星商店问题BZOJ 1562 [NOI 2009] 变换序列BZOJ 1499 [NOI 2005] 瑰丽华尔兹BZOJ 1064 [NOI 2008] 假面舞会BZOJ 2876 [NOI 2012] 骑行川藏BZOJ 3240 [NOI 2013] 矩阵游戏BZOJ 3522 [POI 2014] HotelBZOJ 2084 [POI 2010] AntisymmetryBZOJ 2083 [POI 2010] Intelligence testBZOJ 2095 [POI 2010] BridgesBZOJ 2081 [POI 2010] BeadsBZOJ 1797 [AHOI 2009] Mincut 最小割BZOJ 3931 [CQOI 2015] 网络吞吐量BZOJ 3932 [CQOI 2015] 任务查询系统BZOJ 1177 [APIO 2009] OilBZOJ 1912 [APIO 2010] Patrol 巡逻BZOJ 1500 [NOI 2005] 维修数列BZOJ 2303 [APIO 2011] 方格染色BZOJ 3638 [CF-172] k-Maximum Subsequence SumBZOJ 3272 Zgg 吃东西BZOJ 2770 YY 的 TreapBZOJ 1913 [APIO 2010] Signaling 信号覆盖BZOJ 2957 楼房重建BZOJ 3991 [SDOI 2015] 寻宝游戏BZOJ 3675 [APIO 2014] 序列分割BZOJ 2555 SubStringBZOJ 4016 [FJOI 2014] 最短路径树问题BZOJ 2946 [POI 2000] 公共串BZOJ 3573 [HNOI 2014] 米特运输BZOJ 3572 [HNOI 2014] 世界树BZOJ 3998 [TJOI 2015] 弦论BZOJ 3997 [TJOI 2015] 组合数学BZOJ 3996 [TJOI 2015] 线性代数BZOJ 4010 [HNOI 2015] 菜肴制作BZOJ 4008 [HNOI 2015] 亚瑟王BZOJ 3207 花神的嘲讽计划ⅠBZOJ 3210 花神的浇花集会BZOJ 3990 [SDOI 2015] 排序BZOJ 4002 [JLOI 2015] 有意义的字符串BZOJ 3676 [APIO 2014] 回文串BZOJ 2811 [APIO 2012] GuardBZOJ 3624 [APIO 2008] 免费道路BZOJ 2154 Crash 的数字表格BZOJ 1478 [SGU 282] IsomorphismBZOJ 3700 发展城市BZOJ 1906 树上的蚂蚁BZOJ 3207 花神的嘲讽计划ⅠBZOJ 4027 [HEOI 2015] 兔子与樱花BZOJ 3206 [APIO 2013] 道路费用BZOJ 1513 [POI 2006] Tet-Tetris 3DBZOJ 1194 [HNOI 2006] 潘多拉的盒子BZOJ 4029 [HEOI 2015] 定价BZOJ 2179 FFT 快速傅立叶BZOJ 2194 快速傅立叶之二BZOJ 3527 [ZJOI 2014] 力BZOJ 2631 TreeBZOJ 1036 [ZJOI 2008] 树的统计 CountBZOJ 2282 [SDOI 2011] 消防BZOJ 4031 [HEOI2015] 小 Z 的房间BZOJ 4034 [HAOI2015] 树上操作BZOJ 3926 [ZJOI 2015] 诸神眷顾的幻想乡BZOJ 3924 [ZJOI 2015] 幻想乡战略游戏BZOJ 3160 万径人踪灭BZOJ 1941 [SDOI 2010] Hide and SeekBZOJ 2850 巧克力王国BZOJ 3122 [SDOI 2013] 随机数生成器BZOJ 2179 FFT 快速傅立叶BZOJ 4011 [HNOI 2015] 落忆枫音BZOJ 4067 [CTSC 2015] GenderBZOJ 4042 [CERC 2014] ParadesBZOJ 4050 [CERC 2014] WheelsBZOJ 4045 [CERC 2014] BricksBZOJ 4070 [APIO 2015] 雅加达的摩天楼BZOJ 1312 [NEERC 2006] Hard LifeBZOJ 2632 [NEERC 2011] Gcd guessing gameBZOJ 3969 [WF 2013] Low PowerBZOJ 3927 [NEERC 2014] ImprovementsBZOJ 3802: VocabularyBZOJ 4043 [CERC 2014] VocabularyBZOJ 4047 [CERC 2014] The Imp 刷题顺序 (Q3 2015 至今，题目数量 20+):123456789101112131415161718192021222324252627BZOJ 1180 [CROATIAN 2009] OTOCIBZOJ 2683 简单题BZOJ 4066 简单题BZOJ 3729 Gty 的游戏BZOJ 2118 墨墨的等式BZOJ 2510 弱题BZOJ 3483 [SGU 505] Prefixes and Suffixes 询问在线版BZOJ 3230 相似子串BZOJ 1229 [USACO 2008 Nov] Toy 玩具BZOJ 3600 没有人的算术BZOJ 3065 带插入区间 K 小值BZOJ 3535 [USACO 2014 Open] Fair PhotographyBZOJ 4173 数学BZOJ 1010 [HNOI 2008] 玩具装箱 ToyBZOJ 3669 [NOI 2014] 魔法森林BZOJ 4195 [NOI 2015] 程序自动分析BZOJ 4196 [NOI 2015] 软件包管理器BZOJ 4199 [NOI 2015] 品酒大会BZOJ 3990 [SDOI 2015] 排序BZOJ 2661 [Beijing WC 2012] 连连看BZOJ 3576 [HNOI 2014] 江南乐BZOJ 2756 [SCOI 2012] 奇怪的游戏BZOJ 1036 [ZJOI 2008] 树的统计 CountBZOJ 4698 [SDOI 2008] Sandy 的卡片BZOJ 2458 [Beijing 2011] 最小三角形BZOJ 1017 [JSOI 2008] 魔兽地图 DotRBZOJ 3720 Gty 的妹子树","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://chicago01.top/categories/算法学习/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://chicago01.top/tags/杂项/"}]},{"title":"0x13 链表","slug":"0x13-链表","date":"2019-03-19T11:15:20.000Z","updated":"2019-03-19T13:18:58.298Z","comments":true,"path":"2019/03/19/0x13-链表/","link":"","permalink":"http://chicago01.top/2019/03/19/0x13-链表/","excerpt":"学习链表前我们得先知道什么是线性表，Wiki Pedia是这样定义线性表的： 线性表（英语：Linear List）是由n（n≥0）个数据元素（结点）a[0]，a[1]，a[2]…，a[n-1]组成的有限序列。 我们由定义可以很容易联想到我们曾经学过的数组就是一个线性表，而现在新学一个线性表链表 。","text":"学习链表前我们得先知道什么是线性表，Wiki Pedia是这样定义线性表的： 线性表（英语：Linear List）是由n（n≥0）个数据元素（结点）a[0]，a[1]，a[2]…，a[n-1]组成的有限序列。 我们由定义可以很容易联想到我们曾经学过的数组就是一个线性表，而现在新学一个线性表链表 。 链表我个人把他翻译成链式存储结构，Wiki Pedia是这样定义线性表的： 链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。 由于不必须按顺序存储，链表在插入的时候可以达到$O(1)$的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要$O(n)$的时间，而顺序表相应的时间复杂度分别是$O(logn)$和$O(1)$。 为什么插入一个数据比顺序表（数组）要快很多呢？(数组是连续的内存) 数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。 我们数组的插入首先要遍历到数组的尾部，得到尾部的下标，然后在尾部后面再插入一个数据。但是链表则是直接在上一个元素后面直接进行插入。 单向链表 链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值。 对于单链表，我个人理解是：单向存储读取的链表。链表最基本的结构是在每个节点保存数据和到下一个节点的地址，在最后一个节点保存一个特殊的结束标记 。 主要运用在图的存储上，图的邻接表，通常都是固定顺序访问的。 双向链表 双向链表也叫双链表。双向链表中不仅有指向后一个节点的指针，还有指向前一个节点的指针。这样可以从任何一个节点访问前一个节点，当然也可以访问后一个节点，以至整个链表。一般是在需要大批量的另外储存数据在链表中的位置的时候用。双向链表也可以配合下面的其他链表的扩展使用。 呢么对于双向链表的理解：双向存储读取的链表。 定义value 用于存储权值，*prev指向上一个节点，*next 指向下一个节点。 123456struct Node&#123; int value; Node *prev,*next;&#125;;Node *head,*tail; 初始化双向链表123456789101112inline void initialize(); //新键链表inline void insert(Node *p,int val); //在 P 后面增加数据val值inline void remove(Node *p); //删除 P inline void recycle(); //链表内存回收 inline void initialize()&#123; head = new Node(); tail = new Node(); head-&gt;next = tail; tail-&gt;prev = head;&#125; 增加一个节点123456789inline void insert(Node *p,int val)&#123; Node *q = new Node(); q-&gt;value = val; p-&gt;next-&gt;prev = q; q-&gt;next = p-&gt;next; p-&gt;next = q; q-&gt;prev = p;&#125; 删除一个节点123456inline void remove(Node *p)&#123; p-&gt;prev-&gt;next = p-&gt;next; p-&gt;next-&gt;prev = p-&gt;prev; delete p;&#125; 链表回收123456789inline void recycle()&#123; while (head != tail) &#123; head = head-&gt;next; delete head-&gt;prev; &#125; delete tail;&#125; 所有代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct Node&#123; int value; Node *prev,*next;&#125;;Node *head,*tail;inline void initialize(); //新键链表inline void insert(Node *p,int val); //在 P 后面增加数据val值inline void remove(Node *p); //删除 P inline void recycle(); //链表内存回收 inline void initialize()&#123; head = new Node(); tail = new Node(); head-&gt;next = tail; tail-&gt;prev = head;&#125;inline void insert(Node *p,int val)&#123; Node *q = new Node(); q-&gt;value = val; p-&gt;next-&gt;prev = q; q-&gt;next = p-&gt;next; p-&gt;next = q; q-&gt;prev = p;&#125;inline void remove(Node *p)&#123; p-&gt;prev-&gt;next = p-&gt;next; p-&gt;next-&gt;prev = p-&gt;prev; delete p;&#125;inline void recycle()&#123; while (head != tail) &#123; head = head-&gt;next; delete head-&gt;prev; &#125; delete tail;&#125;","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://chicago01.top/categories/算法竞赛进阶指南/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://chicago01.top/tags/链表/"}]},{"title":"0x12 队列","slug":"0x12-队列","date":"2019-03-14T10:50:03.000Z","updated":"2019-03-14T13:31:29.491Z","comments":true,"path":"2019/03/14/0x12-队列/","link":"","permalink":"http://chicago01.top/2019/03/14/0x12-队列/","excerpt":"想象着我们在食堂排队，或者在超市，这里我们就假设在食堂吧。之所以要排队就是因为公平性，先来先得。所以数据结构中的队列也是这样，先来的先走。一端进入，一端出。","text":"想象着我们在食堂排队，或者在超市，这里我们就假设在食堂吧。之所以要排队就是因为公平性，先来先得。所以数据结构中的队列也是这样，先来的先走。一端进入，一端出。 实现通常用一个数组模拟一个队列，用两个指针：front 和 rear 分别表示队列头部和尾部。 在入队的时候将 rear 后移，在出队的时候将 front 后移。 STL queue在c++中，已经封装好了的STL库中有队列。其操作如下： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int main(int argc, char const *argv[])&#123; int n=10,num; /* 1. push 【入队插到队尾】 2. pop 【队首元素出队】 3. size 【返回队列中元素的个数】 4. front 【返回队列中第一个元素】 5. back 【返回队列中最后一个元素】 6. empty 【判断队列是否为空】 */ //cout&lt;&lt;\"队列:\"&lt;&lt;endl; queue&lt;int&gt; a; for(int i=1;i&lt;n;i++)&#123; num = rand()%233; a.push(num); &#125; //数列长度 cout&lt;&lt;a.size()&lt;&lt;endl; //数列头元素 cout&lt;&lt;a.front()&lt;&lt;endl; //数列尾元素 cout&lt;&lt;a.back()&lt;&lt;endl; //数列是否为空 while(!a.empty())&#123; cout&lt;&lt;a.front()&lt;&lt;ends; a.pop(); &#125;cout&lt;&lt;endl&lt;&lt;endl; return 0;&#125; 优先队列（priority_queue）顾名思义就是，你排队买饭，正排着队，突然来了一个社会小霸王，很不讲理，非要插队，你又揍不过他，这时候他的优先级比你高，排在你的前面。但是还没有完！突然有一个人拿着军官证，为满足军人优先政策，他的优先级比所有人都高，于是，他排在你和小霸王的前面。 而这样每个元素具有一定优先级的队列就叫做优先队列（但是其本质是一个堆）。 STL priority_queue同样的c++也很贴心的为你内置好了这样一个模块，可以直接声明使用它。 top() : 访问栈顶元素 常数复杂度 empty() : 检查底层的容器是否为空 常数复杂度 size() : 返回底层容器的元素数量 常数复杂度 push() : 插入元素，并对底层容器排序 最坏 $O(n)$ 均摊 $O(log(n))$ pop() : 删除第一个元素 最坏 $O(log(n))$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;struct student&#123; int grade; string name;&#125;;struct cmp&#123; bool operator() (student s1,student s2)&#123; return s1.grade &lt; s2.grade; &#125;&#125;;int main(int argc, char const *argv[])&#123; int n=10,num; priority_queue&lt;int&gt; pq_1; for(int i=1;i&lt;n;i++)&#123; num = rand()%233; pq_1.push(num); &#125; //默认情况下，数值大的在队首位置(降序) while(!pq_1.empty())&#123; //注意这里的访问头元素为.top cout&lt;&lt;pq_1.top()&lt;&lt;ends; pq_1.pop(); &#125;cout&lt;&lt;endl; //以下情况下，数值小的在队首位置(升序) priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; pq_2; for(int i=1;i&lt;n;i++)&#123; num = rand()%233; pq_2.push(num); &#125; while(!pq_2.empty())&#123; //注意这里的访问头元素为.top cout&lt;&lt;pq_2.top()&lt;&lt;ends; pq_2.pop(); &#125;cout&lt;&lt;endl;cout&lt;&lt;endl; //运算符重载 priority_queue&lt;student,vector&lt;student&gt;,cmp&gt; q; student s1,s2,s3; s1.grade = 90; s1.name = \"Tom\"; s2.grade = 80; s2.name = \"Jerry\"; s3.grade = 100; s3.name = \"Kevin\"; q.push(s1); q.push(s2); q.push(s3); while(!q.empty())&#123; cout&lt;&lt;q.top().name&lt;&lt;\":\"&lt;&lt;q.top().grade&lt;&lt;endl; q.pop(); &#125; return 0;&#125; 例题 小组队列有n个小组要排成一个队列，每个小组中有若干人。 当一个人来到队列时，如果队列中已经有了自己小组的成员，他就直接插队排在自己小组成员的后面，否则就站在队伍的最后面。 请你编写一个程序，模拟这种小组队列。 输入格式：输入将包含一个或多个测试用例。 对于每个测试用例，第一行输入团队数量t。 接下来t行，每行输入一个团队描述，每个团队描述由属于团队的元素数量和元素本身组成。 元素是0到999999范围内的整数。 一个团队最多可包含1000个元素。 最后，命令列表如下。 有三种不同的命令： 1、ENQUEUE x - 将元素x输入团队队列 2、DEQUEUE - 处理第一个元素并将其从队列中删除 3、STOP - 测试用例结束 每个命令占一行。 当输入用例t=0时，代表停止输入。 需注意：测试用例最多可包含200000（20万）个命令，因此团队队列的实现应该是高效的： 元素的入队和出队都应该只占用O(1)时间。 输出样例对于每个测试用例，首先输出一行“Scenario #k”，其中k是测试用例的编号。 然后，对于每个DEQUEUE命令，输出出列的那个元素，每个元素占一行。 在每个测试用例（包括最后一个测试用例）输出完成后，输出一个空行。 数据范围$1≤t≤1000$ 输入样例：123456789101112131415161718192021222324252627282930313233343523 101 102 1033 201 202 203ENQUEUE 101ENQUEUE 201ENQUEUE 102ENQUEUE 202ENQUEUE 103ENQUEUE 203DEQUEUEDEQUEUEDEQUEUEDEQUEUEDEQUEUEDEQUEUESTOP25 259001 259002 259003 259004 2590056 260001 260002 260003 260004 260005 260006ENQUEUE 259001ENQUEUE 260001ENQUEUE 259002ENQUEUE 259003ENQUEUE 259004ENQUEUE 259005DEQUEUEDEQUEUEENQUEUE 260002ENQUEUE 260003DEQUEUEDEQUEUEDEQUEUEDEQUEUESTOP0 输出样例：123456789101112131415Scenario #1101102103201202203Scenario #2259001259002259003259004259005260001 题解这道题有两个坑的地方。 输入输出很坑。 语法很坑。 大致思路就是，我们使用一个队列+数组queue&lt;int&gt; team[1000]，用来存储各个小队列，其中里面的team[0]队列用来存储各个小队列的顺序。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243//官方代码#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 1000000, T = 1006;int t, f[N], id = 0;char s[10];queue&lt;int&gt; q[T];void Team_Queue() &#123; q[0] = queue&lt;int&gt;(); for (int i = 1; i &lt;= t; i++) &#123; int n; scanf(\"%d\", &amp;n); while (n--) &#123; int x; scanf(\"%d\", &amp;x); f[x] = i; &#125; q[i] = queue&lt;int&gt;(); &#125; cout &lt;&lt; \"Scenario #\" &lt;&lt; ++id &lt;&lt; endl; while (scanf(\"%s\", s) &amp;&amp; s[0] != 'S') &#123; if (s[0] == 'E') &#123; int x; scanf(\"%d\", &amp;x); if (q[f[x]].empty()) q[0].push(f[x]); q[f[x]].push(x); &#125; else &#123; int x = q[0].front(); printf(\"%d\\n\", q[x].front()); q[x].pop(); if (q[x].empty()) q[0].pop(); &#125; &#125; cout &lt;&lt; endl;&#125;int main() &#123; while (cin &gt;&gt; t &amp;&amp; t) Team_Queue(); return 0;&#125; 双端队列对于普通的队列，我们只能从一端进，另一端出。现在我们又来了一种新的队列，是双端队列，这个队列两端都可以进行删除或插入操作，顾名思义“双端队列”。 STL deque12345678910111213//a) 构造函数deque&lt;int&gt; ideq//b)增加函数 ideq.push_front( x):双端队列头部增加一个元素X ideq.push_back(x):双端队列尾部增加一个元素x//c)删除函数ideq.pop_front():删除双端队列中最前一个元素ideq.pop_back():删除双端队列中最后一个元素ideq.clear():清空双端队列中元素//d)判断函数ideq.empty() :向量是否为空，若true,则向量中无元素//e)大小函数ideq.size():返回向量中元素的个数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;deque&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; deque&lt;int&gt; ideq(20); //Create a deque ideq with 20 elements of default value 0 deque&lt;int&gt;::iterator pos; int i; //使用assign()赋值 assign在计算机中就是赋值的意思 for (i = 0; i &lt; 20; ++i) ideq[i] = i; //输出deque printf(\"输出deque中数据:\\n\"); for (i = 0; i &lt; 20; ++i) printf(\"%d \", ideq[i]); putchar('\\n'); //在头尾加入新数据 printf(\"\\n在头尾加入新数据...\\n\"); ideq.push_back(100); ideq.push_front(i); //输出deque printf(\"\\n输出deque中数据:\\n\"); for (pos = ideq.begin(); pos != ideq.end(); pos++) printf(\"%d \", *pos); putchar('\\n'); //查找 const int FINDNUMBER = 19; printf(\"\\n查找%d\\n\", FINDNUMBER); pos = find(ideq.begin(), ideq.end(), FINDNUMBER); if (pos != ideq.end()) printf(\"find %d success\\n\", *pos); else printf(\"find failed\\n\"); //在头尾删除数据 printf(\"\\n在头尾删除数据...\\n\"); ideq.pop_back(); ideq.pop_front(); //输出deque printf(\"\\n输出deque中数据:\\n\"); for (pos = ideq.begin(); pos != ideq.end(); pos++) printf(\"%d \", *pos); putchar('\\n'); return 0;&#125; 单调队列需要满足两个性质： 队列内具有一定的单调性（优先队列）。 满足普通队列性质，一端进，另一端出，不可以中间插队。 但是这样就会现矛盾了，例如一个单调增的队列：1,5,8,9，我们要插入4，这时如果只能从尾端进去的话就打破了其单调性，呢么这时的做法就是从队尾到队头，把大于4的全部T了，然后插入后的队列就变成了1,4。 应用常用于优化动态规划（DP）问题。 例 最大子序和输入一个长度为n的整数序列，从中找出一段长度不超过m的连续子序列，使得子序列中所有数的和最大。 输入格式第一行输入两个整数n,m。 第二行输入n个数，代表长度为n的整数序列。 同一行数之间用空格隔开。 输出格式输出一个整数，代表该序列的最大子序和。 数据范围$1≤n,m≤300000$ 输入样例：126 41 -3 5 1 -2 3 输出样例：17 题解先占个坑。 代码1234567891011121314151617181920212223242526//官方代码#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 300006, INF = 0x3f3f3f3f;int n, m, s[N], q[N];int main() &#123; cin &gt;&gt; n &gt;&gt; m; s[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;s[i]); s[i] += s[i-1]; &#125; int l = 1, r = 1, ans = -INF; q[1] = 0; for (int i = 1; i &lt;= n; i++) &#123; while (l &lt;= r &amp;&amp; q[l] &lt; i - m) l++; ans = max(ans, s[i] - s[q[l]]); while (l &lt;= r &amp;&amp; s[q[r]] &gt;= s[i]) r--; q[++r] = i; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://chicago01.top/categories/算法竞赛进阶指南/"}],"tags":[{"name":"队列","slug":"队列","permalink":"http://chicago01.top/tags/队列/"}]},{"title":"","slug":"20190312","date":"2019-03-12T13:11:54.000Z","updated":"2019-03-26T12:24:17.144Z","comments":true,"path":"2019/03/12/20190312/","link":"","permalink":"http://chicago01.top/2019/03/12/20190312/","excerpt":"","text":"天哪，神仙姐姐。 ——END","categories":[],"tags":[]},{"title":"0x11 栈","slug":"0x11-栈","date":"2019-03-12T11:17:17.000Z","updated":"2019-03-12T13:08:25.812Z","comments":true,"path":"2019/03/12/0x11-栈/","link":"","permalink":"http://chicago01.top/2019/03/12/0x11-栈/","excerpt":"简单栈 栈是一种“先进先出”的数据结构，栈只有一端可以进出元素，我们称这一端为栈顶。添加和删除元素时我们只能对栈顶进行操作。","text":"简单栈 栈是一种“先进先出”的数据结构，栈只有一端可以进出元素，我们称这一端为栈顶。添加和删除元素时我们只能对栈顶进行操作。 实现方式可以用数组或者STL中的stack。 1234567891011//数组实现栈int stk[N];// 这里使用 stk[0]( 即 *stk ) 代表栈中元素数量，同时也是栈顶下标// 压栈 ：stk[++*stk] = var1;// 取栈顶 ：int u = stk[*stk];// 弹栈 ：注意越界问题, *stk == 0 时不能继续弹出if (*stk) --*stk;// 清空栈*stk = 0; 12345678910111213141516171819202122232425262728//STL中stack#include &lt;stack&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; // 创建堆栈对象 stack&lt;int&gt; s; // 元素入栈 s.push(3); s.push(19); s.push(23); s.push(36); s.push(50); s.push(4); cout &lt;&lt; s.size() &lt;&lt; endl; // 元素依次出栈 while(!s.empty()) &#123; // 打印栈顶元素，打印出：4 50 36 23 19 3 cout &lt;&lt; s.top() &lt;&lt; endl; // 出栈 s.pop(); &#125; return 0;&#125; 【例题】 Push，Pop，GetMin设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈。 题解我们用两个栈来维护，MinStack 和 NumStack。 在入栈时，NumStack正常入栈，而MinStack则入栈当前已知最小数。 当GetMin时，只需要返回MinStack栈顶元素。 出栈时NumStack 和 MinStack 同时出栈。 代码演示 交互题，无样例代码。 【例题】 火车进出栈这里有n列火车将要进站再出站，但是，每列火车只有1节，那就是车头。 这n列火车按1到n的顺序从东方左转进站，这个车站是南北方向的，它虽然无限长，只可惜是一个死胡同，而且站台只有一条股道，火车只能倒着从西方出去，而且每列火车必须进站，先进后出。 也就是说这个火车站其实就相当于一个栈，每次可以让右侧头火车进栈，或者让栈顶火车出站。 车站示意如图： 1234出站&lt;—— &lt;——进站 |车| |站| |__| 现在请你按《字典序》输出前20种可能的出栈方案。 输入格式输入一个整数n，代表火车数量。 输出格式按照《字典序》输出前20种答案，每行一种，不要空格。 数据范围$1≤n≤20$ 输入样例：13 输出样例：12345123132213231321 题解由题目可以知道，火车栈存在两种情况，要么出栈，要么进栈。 于是我们模拟一下样例： 123456789101112131415161718n = 3第一种情况： 1. 1 进栈 2. 1 出栈 3. 2 进栈 4. 2 出栈 5. 3 进栈 6. 3 出栈 输出顺序：1 2 3第二种情况： 1. 1 进栈 2. 1 出栈 3. 2 进栈 4. 3 进栈 5. 3 出栈 6. 2 出栈 输出顺序：1 3 2······ 代码演示123456789101112131415161718192021222324252627282930//官方代码#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 26;int n, num = 0, st[N], top = 0, ans[N], t = 0;void z(int x) &#123; if (x == n + 1) &#123; if (++num &gt; 20) exit(0); for (int i = 1; i &lt;= t; i++) printf(\"%d\", ans[i]); for (int i = top; i; i--) printf(\"%d\", st[i]); cout &lt;&lt; endl; return; &#125; if (top) &#123; ans[++t] = st[top--]; z(x); st[++top] = ans[t--]; &#125; st[++top] = x; z(x + 1); --top;&#125;int main() &#123; cin &gt;&gt; n; z(1); return 0;&#125; 表达式计算表达式分为前缀、中缀、后缀表达式。 我们平时生活中和数学中用的都是中缀表达式，形如 $2*(9-1)$ 。 而前缀表达式又称波兰式，形如 $op A B$ ，$op$ 是要对$A B$进行的运算的运算符号。 同上，后缀表达式就是，形如 $AB$ $ op$ ，$op$ 是要对$A B$进行的运算的运算符号。 后缀表达式求值计算 建立一个栈 遇到数字就进栈 遇到运算符，取出栈顶的两个元素，进行运算后压入栈中 当栈中只剩下一个元素，就是答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 后缀表达式转中缀表达式，同时求值，O(n)// 数值栈 vector&lt;int&gt; nums; // 运算符栈 vector&lt;char&gt; ops;// 优先级 int grade(char op) &#123; switch (op) &#123; case '(': return 1; case '+': case '-': return 2; case '*': case '/': return 3; &#125; return 0;&#125;// 处理后缀表达式中的一个运算符 void calc(char op) &#123; // 从栈顶取出两个数 int y = *nums.rbegin(); nums.pop_back(); int x = *nums.rbegin(); nums.pop_back(); int z; switch (op) &#123; case '+': z = x + y; break; case '-': z = x - y; break; case '*': z = x * y; break; case '/': z = x / y; break; &#125; // 把运算结果放回栈中 nums.push_back(z); &#125; 单调栈单调栈顾名思义，就是栈中元素呈现单调性。 插入将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。 例如，栈中自顶向下的元素为 ，插入元素 时为了保证单调性需要依次弹出元素 ，操作后栈变为 。 用伪代码描述如下： 123456789101112131415161718192021/** 本伪代码对应的是单调递减栈 *共n个元素，编号为0~n-1*/while(栈为空) 栈顶元素出栈; //先清空栈a[n]=-1;for(i=0;i&lt;=n;i++)&#123; if(栈为空或入栈元素大于等于栈顶元素) 入栈; else &#123; while(栈非空并且栈顶元素大于等于入栈元素) &#123; 栈顶元素出栈; 更新结果; &#125; 将最后一次出栈的栈顶元素（即当前元素可以拓展到的位置）入栈; 更新最后一次出栈的栈顶元素其对应的值; &#125; &#125;输出结果; 使用自然就是从栈顶读出来一个元素，该元素满足单调性的某一端。 例如举例中取出的即栈中的最小值。 【例题】 直方图中最大矩形直方图是由在公共基线处对齐的一系列矩形组成的多边形。 矩形具有相等的宽度，但可以具有不同的高度。 例如，图例左侧显示了由高度为2,1,4,5,1,3,3的矩形组成的直方图，矩形的宽度都为1： 通常，直方图用于表示离散分布，例如，文本中字符的频率。 现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。 图例右图显示了所描绘直方图的最大对齐矩形。 输入格式输入包含几个测试用例。 每个测试用例占据一行，用以描述一个直方图，并以整数n开始，表示组成直方图的矩形数目。 然后跟随n个整数$h_1，…，h_n$。 这些数字以从左到右的顺序表示直方图的各个矩形的高度。 每个矩形的宽度为1。 同行数字用空格隔开。 当输入用例为n=0时，结束输入，且该用例不用考虑。 输出格式对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。 每个数据占一行。 请注意，此矩形必须在公共基线处对齐。 数据范围$1≤n≤100000$,$0≤hi≤1000000000$ 输入样例：1237 2 1 4 5 1 3 34 1000 1000 1000 10000 输出样例：1284000 题解其实这是一道贪心+单调栈的题目。 只需要证明所选矩形里面的直方条是单调增的，这时候就变成求单调栈的问题了。其答案就是每次弹出一个高度就计算一下面积，取最大值。 代码演示1234567891011121314151617181920212223242526272829303132333435//官方标程#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt; #include&lt;algorithm&gt;using namespace std;int n,p;int a[100010];int s[100010],w[100010];long long ans;int main()&#123; while(cin&gt;&gt;n&amp;&amp;n) &#123; ans=0; p=0; for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); a[n+1]=0; for(int i=1;i&lt;=n+1;i++) &#123; if(a[i]&gt;s[p]) s[++p]=a[i],w[p]=1; else&#123; int width=0; while(s[p]&gt;a[i]) &#123; width+=w[p]; ans=max(ans,(long long)width*s[p]); p--; &#125; s[++p]=a[i],w[p]=width+1; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://chicago01.top/categories/算法竞赛进阶指南/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://chicago01.top/tags/栈/"}]},{"title":"习题 3-4 周期串(Periodic Strings, UVa455)","slug":"习题-3-4-周期串-Periodic-Strings-UVa455","date":"2019-03-07T12:51:52.000Z","updated":"2019-03-07T13:19:35.513Z","comments":true,"path":"2019/03/07/习题-3-4-周期串-Periodic-Strings-UVa455/","link":"","permalink":"http://chicago01.top/2019/03/07/习题-3-4-周期串-Periodic-Strings-UVa455/","excerpt":"题意翻译如果一个字符串可以由某个长度为kk 的字符串重复多次得到，则称该串以k 为周期。例如，$abcabcabcabc$ 以$3$ 为周期（注意，它也以$6$ 和$12$ 为周期）。 输入一个长度不超过$80$ 的字符串，输出其最小周期。","text":"题意翻译如果一个字符串可以由某个长度为kk 的字符串重复多次得到，则称该串以k 为周期。例如，$abcabcabcabc$ 以$3$ 为周期（注意，它也以$6$ 和$12$ 为周期）。 输入一个长度不超过$80$ 的字符串，输出其最小周期。 题目描述PDF 输入输出格式输入格式： 输出格式： 输入输出样例输入样例#1： 121HoHoHo 输出样例#1： 12 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;int n;inline bool check(int T,int len,string s)&#123; for(int i = 0;i+T &lt; len;++i) &#123; if(s[i] != s[i+T]) return false; &#125; return true;&#125;inline int find(string s)&#123; int ans; for(int T = 1;T &lt; s.length();++T) &#123; if(s.length()%T == 0 &amp;&amp; check(T,s.length(),s)) &#123; ans = T; break; &#125; &#125; return ans;&#125;int main(void)&#123; cin &gt;&gt; n; while(n--) &#123; string s; cin &gt;&gt; s; cout &lt;&lt; find(s) &lt;&lt; endl; if(n) cout &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"算法竞赛入门经典","slug":"算法竞赛入门经典","permalink":"http://chicago01.top/categories/算法竞赛入门经典/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://chicago01.top/tags/字符串/"}]},{"title":"习题 3-3 数数字(Digit Counting , ACM/ICPC Danang 2007, UVa1225)","slug":"习题-3-3-数数字-Digit-Counting-ACM-ICPC-Danang-2007-UVa1225","date":"2019-03-07T12:47:48.000Z","updated":"2019-03-07T13:19:30.260Z","comments":true,"path":"2019/03/07/习题-3-3-数数字-Digit-Counting-ACM-ICPC-Danang-2007-UVa1225/","link":"","permalink":"http://chicago01.top/2019/03/07/习题-3-3-数数字-Digit-Counting-ACM-ICPC-Danang-2007-UVa1225/","excerpt":"题意翻译把前n（n&lt;=10000）个整数顺次写在一起：12345678910111213141516……数一数0~9分别出现了多少次。","text":"题意翻译把前n（n&lt;=10000）个整数顺次写在一起：12345678910111213141516……数一数0~9分别出现了多少次。 题目描述PDF 样例输入样例：1232313 输出样例：120 1 1 1 0 0 0 0 0 01 6 2 2 1 1 1 1 1 1 代码我的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;int n;inline int find(int a)&#123; int num[10]; memset(num,0,sizeof(num)); for(int i = 1;i &lt;= a;++i) &#123; char s[100010]; sprintf(s,\"%d\",i); for(int i = 0;i &lt; strlen(s);++i) &#123; int number = s[i] - '0'; num[number]++; &#125; &#125; for(int i = 0;i &lt; 10;++i) cout &lt;&lt; num[i] &lt;&lt; \" \"; cout &lt;&lt; endl;&#125;int main(void)&#123; cin &gt;&gt; n; while(n--) &#123; int a; cin &gt;&gt; a; find(a); &#125; return 0;&#125; 官方代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344// Digit Counting , ACM/ICPC Danang 2007, UVa1225// 陈锋#include&lt;cassert&gt;#include&lt;cctype&gt;#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;functional&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;map&gt;using namespace std;const int MAXN = 10000 + 1;int C[MAXN][10] = &#123;0&#125;;int main()&#123; for(int i = 1; i &lt; MAXN; i++) &#123; for(int k = 0; k &lt; 10; k++) C[i][k] = C[i-1][k]; int n = i; while(n) &#123; ++C[i][n%10]; n /= 10; &#125; &#125; int T, n; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n; for(int i = 0; i &lt; 10; i++) &#123; if(i) cout&lt;&lt;\" \"; cout&lt;&lt;C[n][i]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;/* 13575949 1225 Digit Counting Accepted C++ 0.016 2014-05-02 00:09:23 */","categories":[{"name":"算法竞赛入门经典","slug":"算法竞赛入门经典","permalink":"http://chicago01.top/categories/算法竞赛入门经典/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://chicago01.top/tags/字符串/"}]},{"title":"习题 3-2 分子量(Molar Mass, ACM/ICPC Seoul 2007, UVa1586)","slug":"习题-3-2-分子量-Molar-Mass-ACM-ICPC-Seoul-2007-UVa1586","date":"2019-03-07T11:40:17.000Z","updated":"2019-03-07T13:19:24.719Z","comments":true,"path":"2019/03/07/习题-3-2-分子量-Molar-Mass-ACM-ICPC-Seoul-2007-UVa1586/","link":"","permalink":"http://chicago01.top/2019/03/07/习题-3-2-分子量-Molar-Mass-ACM-ICPC-Seoul-2007-UVa1586/","excerpt":"题意翻译现给你若干个分子式需要你求分子量。 例如：$C6H5OH$的分子量为$12.016+1.0085+16.00+1.008=94.108g/mol$。 （ps：数字为数字前面元素的下标，所有分子式均无括号例如：$2OH=2*16.00+1.008$）","text":"题意翻译现给你若干个分子式需要你求分子量。 例如：$C6H5OH$的分子量为$12.016+1.0085+16.00+1.008=94.108g/mol$。 （ps：数字为数字前面元素的下标，所有分子式均无括号例如：$2OH=2*16.00+1.008$） 输入输出格式 输入：输入$n(2&lt;=n&lt;=99)$ 接下来$n$行为分子式 输出：输出每个分子的分子式 题目描述PDF 输入输出样例输入格式： 123454CC6H5OHNH2CH2COOHC12H22O11 输出格式： 123412.01094.10875.070342.296 代码官方代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Molar Mass, ACM/ICPC Seoul 2007, UVa1586// 陈锋#include &lt;cassert&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;functional&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;#define _for(i,a,b) for( int i=(a); i&lt;(b); ++i)#define _rep(i,a,b) for( int i=(a); i&lt;=(b); ++i)using namespace std;int main()&#123; int T, cnt, sz; double W[256], ans; char buf[256], c, s; W['C'] = 12.01, W['H'] = 1.008, W['O'] = 16.0, W['N'] = 14.01; scanf(\"%d\\n\", &amp;T); while(T--)&#123; scanf(\"%s\", buf); ans = 0; s = 0; cnt = -1; sz = strlen(buf); _for(i, 0, sz)&#123; char c = buf[i]; if(isupper(c)) &#123; if(i) &#123; if(cnt == -1) cnt = 1; ans += W[s] * cnt; &#125; s = c; cnt = -1; &#125; else &#123; assert(isdigit(c)); if(cnt == -1) cnt = 0; cnt = cnt*10 + c - '0'; &#125; &#125; if(cnt == -1) cnt = 1; ans += W[s] * cnt; printf(\"%.3lf\\n\", ans); &#125; return 0;&#125;/* 13555289 1586 Molar mass Accepted C++ 0.012 2014-04-27 13:51:04 */","categories":[{"name":"算法竞赛入门经典","slug":"算法竞赛入门经典","permalink":"http://chicago01.top/categories/算法竞赛入门经典/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://chicago01.top/tags/字符串/"}]},{"title":"习题 3-1 得分(Score, ACM/ICPC Seoul 2005, UVa1585)","slug":"习题-3-1-得分-Score-ACM-ICPC-Seoul-2005-UVa1585","date":"2019-03-07T11:13:40.000Z","updated":"2019-03-07T13:19:58.955Z","comments":true,"path":"2019/03/07/习题-3-1-得分-Score-ACM-ICPC-Seoul-2005-UVa1585/","link":"","permalink":"http://chicago01.top/2019/03/07/习题-3-1-得分-Score-ACM-ICPC-Seoul-2005-UVa1585/","excerpt":"题意翻译给出T个由O和X组成的字符串，长度小于等于80，统计所有字符的得分和。每个O的得分为目前连续出现的O的个数，X的得分为0。例如，OOXXOXXOOO的得分1+2+0+0+1+0+0+1+2+3=10","text":"题意翻译给出T个由O和X组成的字符串，长度小于等于80，统计所有字符的得分和。每个O的得分为目前连续出现的O的个数，X的得分为0。例如，OOXXOXXOOO的得分1+2+0+0+1+0+0+1+2+3=10 Sample Input1234565OOXXOXXOOOOOXXOOXXOOOXOXOXOXOXOXOXOOOOOOOOOOOOOOXOOOOXOOOOX Sample Output1234510975530 代码我的代码：123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int n;inline int find(string s)&#123; int ans = 0,date = 0; for(int i = 0; i &lt; s.length(); i++) &#123; if (s[i] == 'O') &#123; date++; ans += date; &#125; else &#123; date = 0; &#125; &#125; return ans;&#125;int main(void)&#123; cin &gt;&gt; n; while(n--) &#123; string s; cin &gt;&gt; s; cout &lt;&lt; find(s) &lt;&lt; endl; &#125; return 0;&#125; 官方代码：1234567891011121314151617181920212223242526272829303132// Score, ACM/ICPC Seoul 2005, UVa1585// 陈锋#include &lt;cassert&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;functional&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;#define _for(i,a,b) for( int i=(a); i&lt;(b); ++i)#define _rep(i,a,b) for( int i=(a); i&lt;=(b); ++i)int main() &#123; int T; char buf[128]; scanf(\"%d\\n\", &amp;T); while(T--) &#123; gets(buf); int cnt = 0, sum = 0, sz = strlen(buf); _for(i, 0, sz)&#123; if(buf[i] == 'O') sum += (++cnt); else cnt = 0; &#125; printf(\"%d\\n\", sum); &#125; return 0;&#125;/* 13555134 1585 Score Accepted C++ 0.006 2014-04-27 13:01:27 */","categories":[{"name":"算法竞赛入门经典","slug":"算法竞赛入门经典","permalink":"http://chicago01.top/categories/算法竞赛入门经典/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://chicago01.top/tags/字符串/"}]},{"title":"链表模板","slug":"链表模板","date":"2019-03-05T12:37:48.000Z","updated":"2019-03-05T12:50:01.949Z","comments":true,"path":"2019/03/05/链表模板/","link":"","permalink":"http://chicago01.top/2019/03/05/链表模板/","excerpt":"如题所述，本文仅仅只是模板，没有讲解。 拖更ing。。。","text":"如题所述，本文仅仅只是模板，没有讲解。 拖更ing。。。 指针型12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct Node&#123; int value; Node *prev,*next;&#125;;Node *head,*tail;inline void initialize(); //新键链表inline void insert(Node *p,int val); //在 P 后面增加数据val值inline void remove(Node *p); //删除 P inline void recycle(); //链表内存回收 inline void initialize()&#123; head = new Node(); tail = new Node(); head-&gt;next = tail; tail-&gt;prev = head;&#125;inline void insert(Node *p,int val)&#123; Node *q = new Node(); q-&gt;value = val; p-&gt;next-&gt;prev = q; q-&gt;next = p-&gt;next; p-&gt;next = q; q-&gt;prev = p;&#125;inline void remove(Node *p)&#123; p-&gt;prev-&gt;next = p-&gt;next; p-&gt;next-&gt;prev = p-&gt;prev; delete p;&#125;inline void recycle()&#123; while (head != tail) &#123; head = head-&gt;next; delete head-&gt;prev; &#125; delete tail;&#125; 数组型1234567891011121314151617181920212223242526272829303132333435363738394041struct Node&#123; int value; int prev,next;&#125;node[SIZE];int head,tail,tot;inline void initialize(); //新键链表inline void insert(int p,int val); //在 P 后面增加数据val值inline void remove(int p); //删除 P inline void recycle(); //链表内存回收 inline void initialize()&#123; tot = 2; head = 1,tail = 2; node[head].next = tail; node[tail].prev = head;&#125;inline void insert(int p,int val)&#123; int q = ++tot; node[q].value = val; node[node[p].next].prev = q; node[q].next = node[p].next; node[p].next = q; node[q].prev = p;&#125;inline void remove(int p)&#123; node[node[p].prev].next = node[p].next; node[node[p].next].prev = node[p].prev;&#125;inline void recycle()&#123; memset(node,0,sizeof(node)); head = tail = tot = 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://chicago01.top/categories/算法学习/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://chicago01.top/tags/数据结构/"}]},{"title":"OJ术语:AC WA TLE OLE MLE RE PE CE","slug":"OJ术语-AC-WA-TLE-OLE-MLE-RE-PE-CE","date":"2019-03-05T12:06:46.000Z","updated":"2019-03-05T12:11:01.122Z","comments":true,"path":"2019/03/05/OJ术语-AC-WA-TLE-OLE-MLE-RE-PE-CE/","link":"","permalink":"http://chicago01.top/2019/03/05/OJ术语-AC-WA-TLE-OLE-MLE-RE-PE-CE/","excerpt":"","text":"12345678910简写 全称 中文称谓OJ Online Judge 在线判题系统AC Accepted 通过WA Wrong Answer 答案错误TLE Time Limit Exceed 超时OLE Output Limit Exceed 超过输出限制MLE Memory Limit Exceed 超内存RE Runtime Error 运行时错误PE Presentation Error 格式错误CE Compile Error 无法编","categories":[],"tags":[]},{"title":"P1187 3D模型","slug":"P1187-3D模型","date":"2019-03-05T11:58:50.000Z","updated":"2019-03-12T10:41:42.198Z","comments":true,"path":"2019/03/05/P1187-3D模型/","link":"","permalink":"http://chicago01.top/2019/03/05/P1187-3D模型/","excerpt":"题目描述一座城市建立在规则的n×m网格上，并且网格均由1×1正方形构成。在每个网格上都可以有一个建筑，建筑由若干个1×1×1的立方体搭建而成（也就是所有建筑的底部都在同一平面上的）。几个典型的城市模型如下图所示： 现在给出每个网格上建筑的高度，即每个网格上建筑由多少个立方体搭建而成，要求这个建筑模型的表面积是多少。","text":"题目描述一座城市建立在规则的n×m网格上，并且网格均由1×1正方形构成。在每个网格上都可以有一个建筑，建筑由若干个1×1×1的立方体搭建而成（也就是所有建筑的底部都在同一平面上的）。几个典型的城市模型如下图所示： 现在给出每个网格上建筑的高度，即每个网格上建筑由多少个立方体搭建而成，要求这个建筑模型的表面积是多少。 输入输出格式输入格式：第1行包含2个正整数n,m，为城市模型的长与宽。 接下来n行，每行m个数字字符，描述了网格每个格子高度（可见所有建筑高度都大等于0且小等于9）。 输出格式：一个非负整数，为城市模型的表面积。 输入输出样例输入样例#1： 12343 3111212111 输出样例#1： 138 输入样例#2： 12343 4100000100000 输出样例#2： 112 说明本题有2个测试数据 20%的数据满足：n, m≤10n； 40%的数据满足：n, m≤100n； 100%的数据满足：n, m≤1000。 题解其实一共有六个方向，但是如果我们模拟六个方向太麻烦了，但是还好是正方体，so，我们可以直接模拟三个方向，最后乘 2 不就行了么！！！ 模拟上方 只需要判断$map[n][m]$ 是不是大于 $0$ 。 模拟前面 我们一列一列的考虑，如果后面的方块高于前面的方块，就凸出来了，$ans++$；如果是低于的，就凹下去了。 模拟侧方 和模拟前面的做法一样，但是我们一横排一横排的模拟，如果后面的方块高于前面的方块，就凸出来了，$ans++$；如果是低于的，就凹下去了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445//来源于洛谷题解#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int map[1001][1001];char input;int ans_u,ans_f,ans_r,n,m;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; cin&gt;&gt;input; map[i][j]=input-'0'; &#125; //上面 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; if(map[i][j]&gt;0) ans_u+=1; &#125; //正面 for(int j=1;j&lt;=m;j++) &#123; ans_f+=map[1][j]; //第一个先加上 for(int i=2;i&lt;=n;i++) &#123; if(map[i][j]&gt;map[i-1][j]) ans_f+=(map[i][j]-map[i-1][j]); //后面的加上与前一个的差 &#125; &#125; //侧面 for(int i=1;i&lt;=n;i++) &#123; ans_f+=map[i][1]; //第一个先加上 for(int j=2;j&lt;=m;j++) &#123; if(map[i][j]&gt;map[i][j-1]) ans_r+=(map[i][j]-map[i][j-1]); //后面的加上与前一个的差 &#125; &#125; cout&lt;&lt;(ans_u+ans_f+ans_r)*2; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://chicago01.top/categories/题解/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://chicago01.top/tags/模拟/"}]},{"title":"牛牛的朋友","slug":"牛牛的朋友","date":"2019-02-28T13:36:51.000Z","updated":"2019-03-02T14:58:18.234Z","comments":true,"path":"2019/02/28/牛牛的朋友/","link":"","permalink":"http://chicago01.top/2019/02/28/牛牛的朋友/","excerpt":"https://ac.nowcoder.com/acm/problem/21545 题目描述牛牛有一群牛友，每只小牛都站在坐标轴上的某个位置，这群牛友很听牛牛的话，每当牛牛做个手势，每只小牛都会移动恰好X个单位的距离，要么向左，要么向右 现在告诉你每只小牛在移动前的位置，求移动之后最左边的牛与最右边的牛的最小距离","text":"https://ac.nowcoder.com/acm/problem/21545 题目描述牛牛有一群牛友，每只小牛都站在坐标轴上的某个位置，这群牛友很听牛牛的话，每当牛牛做个手势，每只小牛都会移动恰好X个单位的距离，要么向左，要么向右 现在告诉你每只小牛在移动前的位置，求移动之后最左边的牛与最右边的牛的最小距离 输入描述:123第一行输入一个整数n (1 ≤ n ≤ 50)，表示牛的数量第二行输入n个数pi (-1e8 ≤ pi ≤ 1e8)，表示每只牛的位置 第三行输入一个整数X (0 ≤ X ≤ 1e8) 输出描述:1输出一个整数 示例1 输入1233-3 0 13 输出13 示例2 输入12334 7 -75 输出14 说明12 示例3 输入1232-100000000 100000000100000000 输出10 示例4 输入12393 7 4 6 -10 7 10 9 -57 输出17 示例5 输入1234-4 0 4 04 输出14 示例6 输入123170 输出10 备注:123子任务1：n &lt;= 10子任务2: n &lt;= 20子任务3: n &lt;= 50 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;int n,x;int num[100];inline void init()&#123; cin &gt;&gt; n; for(int i=1;i &lt;= n;++i) cin &gt;&gt; num[i]; cin &gt;&gt; x;&#125;inline int find()&#123; sort(num+1,num+n+1); int ans = 1e9; for(int i = 1;i &lt;= n;++i) &#123; int next[100]; for(int j = 1;j &lt;= i;++j) next[j] = num[j] + x; for(int j = i+1;j &lt;= n;++j) next[j] = num[j] - x; sort(next + 1,next + 1 + n); ans = min(ans,next[n]-next[1]); &#125; return ans;&#125;int main(void)&#123; init(); cout &lt;&lt; find(); return 0;&#125;","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://chicago01.top/tags/贪心/"}]},{"title":"牛牛学括号","slug":"牛牛学括号","date":"2019-02-28T13:36:51.000Z","updated":"2019-03-02T14:58:12.659Z","comments":true,"path":"2019/02/28/牛牛学括号/","link":"","permalink":"http://chicago01.top/2019/02/28/牛牛学括号/","excerpt":"https://ac.nowcoder.com/acm/problem/21579 题目描述 牛牛最近在学习括号匹配问题 给你一个合法的括号序列，每次操作分两步，第一步删除第一个左括号，第二步删除某一个右括号，要保证删除之后的括号序列还是合法的,求将括号删到空为止一共有多少种不同的删除方法，两种方法不同当且仅当存在某一步右括号的删除位置不同，答案膜1e9+7","text":"https://ac.nowcoder.com/acm/problem/21579 题目描述 牛牛最近在学习括号匹配问题 给你一个合法的括号序列，每次操作分两步，第一步删除第一个左括号，第二步删除某一个右括号，要保证删除之后的括号序列还是合法的,求将括号删到空为止一共有多少种不同的删除方法，两种方法不同当且仅当存在某一步右括号的删除位置不同，答案膜1e9+7 输入描述:1输入一个字符串s只包含左右括号, 2 ≤ |s| ≤ 2500 输出描述:1输出一个整数 示例1 输入复制 1()()()()() 输出复制 11 示例2 输入复制 1(((()))) 输出复制 124 示例3 输入复制 1((()))(()(()))((())) 输出复制 1432 备注:12345子任务一30分：n&lt;=20子任务二30分：n&lt;=100子任务三40分：n&lt;=2500 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;string ss;stack&lt;char&gt; s;inline void init()&#123; cin &gt;&gt; ss;&#125;inline long long find()&#123; long long ans = 1; for(int i = 0;i &lt; ss.size();++i) &#123; if(ss[i] == '(') s.push('('); if(ss[i] == ')') &#123; int len = s.size(); ans *= len; s.pop(); &#125; &#125; return ans;&#125;int main(void)&#123; init(); cout &lt;&lt; find() ; return 0;&#125;","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://chicago01.top/tags/贪心/"}]},{"title":"0x07 贪心","slug":"0x07 贪心","date":"2019-02-26T14:34:50.000Z","updated":"2019-03-02T14:58:04.591Z","comments":true,"path":"2019/02/26/0x07 贪心/","link":"","permalink":"http://chicago01.top/2019/02/26/0x07 贪心/","excerpt":"基础知识贪贪贪。。。 例1 防嗮有C头奶牛进行日光浴，第i头奶牛需要minSPF[i]到maxSPF[i]单位强度之间的阳光。 每头奶牛在日光浴前必须涂防晒霜，防晒霜有L种，涂上第i种之后，身体接收到的阳光强度就会稳定为SPF[i]，第i种防晒霜有cover[i]瓶。 求最多可以满足多少头奶牛进行日光浴。","text":"基础知识贪贪贪。。。 例1 防嗮有C头奶牛进行日光浴，第i头奶牛需要minSPF[i]到maxSPF[i]单位强度之间的阳光。 每头奶牛在日光浴前必须涂防晒霜，防晒霜有L种，涂上第i种之后，身体接收到的阳光强度就会稳定为SPF[i]，第i种防晒霜有cover[i]瓶。 求最多可以满足多少头奶牛进行日光浴。 输入格式第一行输入整数C和L。 接下来的C行，按次序每行输入一头牛的minSPF和maxSPF值,即第i行输入minSPF[i]和maxSPF[i]。 再接下来的L行，按次序每行输入一种防晒霜的SPF和cover值,即第i行输入SPF[i]和cover[i]。 每行的数据之间用空格隔开。 输出格式输出一个整数，代表最多可以满足奶牛日光浴的奶牛数目。 数据范围1≤C,L≤2500,1≤minSPF≤maxSPF≤1000,1≤SPF≤1000 输入样例：1234563 23 102 51 56 24 1 输出样例：12 题解 匈牙利算法 将所有奶牛按照 minSPF 从大到小的顺序排序，然后依次考虑每头奶牛； 对于每头奶牛，扫描当前所有能用的防晒霜，选择 SPF 值最大的防晒霜来用； 代码演示12 例2畜栏预定 有N头牛在畜栏中吃草。 每个畜栏在同一时间段只能提供给一头牛吃草，所以可能会需要多个畜栏。 给定N头牛和每头牛开始吃草的时间A以及结束吃草的时间B，每头牛在[A,B]这一时间段内都会一直吃草。 当两头牛的吃草区间存在交集时（包括端点），这两头牛不能被安排在同一个畜栏吃草。 求需要的最小畜栏数目和每头牛对应的畜栏方案。 输入格式第1行：输入一个整数N。 第2..N+1行：第i+1行输入第i头牛的开始吃草时间A以及结束吃草时间B，数之间用空格隔开。 输出格式第1行：输入一个整数，代表所需最小畜栏数。 第2..N+1行：第i+1行输入第i头牛被安排到的畜栏编号，编号从1开始，只要方案合法即可。 数据范围1≤N≤50000,1≤A,B≤1000000 输入样例：12345651 102 43 65 84 7 输出样例：123456412324 题解代码演示12 例3 雷达设备 假设海岸是一条无限长的直线，陆地位于海岸的一侧，海洋位于另外一侧。 每个小岛都位于海洋一侧的某个点上。 雷达装置均位于海岸线上，且雷达的监测范围为d，当小岛与某雷达的距离不超过d时，该小岛可以被雷达覆盖。 我们使用笛卡尔坐标系，定义海岸线为x轴，海的一侧在x轴上方，陆地一侧在x轴下方。 现在给出每个小岛的具体坐标以及雷达的检测范围，请你求出能够使所有小岛都被雷达覆盖所需的最小雷达数目。 输入格式第一行输入两个整数n和d，分别代表小岛数目和雷达检测范围。 接下来n行，每行输入两个整数，分别代表小岛的x，y轴坐标。 同一行数据之间用空格隔开。 输出格式输出一个整数，代表所需的最小雷达数目，若没有解决方案则所需数目输出“-1”。 数据范围1≤n≤1000 输入样例：12343 21 2-3 12 1 输出样例：12 题解代码演示12 例4 国王游戏恰逢 H 国国庆,国王邀请 n 位大臣来玩一个有奖游戏。 首先,他让每个大臣在左、右手上面分别写下一个整数,国王自己也在左、右手上各写一个整数。 然后,让这 n 位大臣排成一排,国王站在队伍的最前面。 排好队后,所有的大臣都会获得国王奖赏的若干金币,每位大臣获得的金币数分别是: 排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数,然后向下取整得到的结果。 国王不希望某一个大臣获得特别多的奖赏,所以他想请你帮他重新安排一下队伍的顺序,使得获得奖赏最多的大臣,所获奖赏尽可能的少。 注意,国王的位置始终在队伍的最前面。 输入格式第一行包含一个整数 n,表示大臣的人数。 第二行包含两个整数 a 和 b,之间用一个空格隔开,分别表示国王左手和右手上的整数。 接下来 n 行,每行包含两个整数 a 和 b,之间用一个空格隔开,分别表示每个大臣左手和右手上的整数。 输出格式输出只有一行,包含一个整数,表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。 数据范围1≤n≤10000&lt;a,b&lt;10000 输入样例：1234531 12 37 44 6 输出样例：12 题解代码演示12","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://chicago01.top/categories/算法竞赛进阶指南/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://chicago01.top/tags/贪心/"}]},{"title":"","slug":"190214","date":"2019-02-13T17:56:50.000Z","updated":"2019-02-13T18:12:39.028Z","comments":true,"path":"2019/02/14/190214/","link":"","permalink":"http://chicago01.top/2019/02/14/190214/","excerpt":"","text":"人生苦短，何必念念不忘。 ——网易云音乐《消愁》","categories":[],"tags":[]},{"title":"0x05 排序","slug":"0x05排序","date":"2019-02-09T03:34:50.000Z","updated":"2019-02-09T09:13:20.704Z","comments":true,"path":"2019/02/09/0x05排序/","link":"","permalink":"http://chicago01.top/2019/02/09/0x05排序/","excerpt":"几大常见的排序算法算法分类 非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破$O(nlogn)$，因此称为非线性时间比较类排序。 线性时间非比较类排序： 不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。","text":"几大常见的排序算法算法分类 非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破$O(nlogn)$，因此称为非线性时间比较类排序。 线性时间非比较类排序： 不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 时间复杂度 相关定义 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 冒泡排序（Bubble Sort）冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 算法流程 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 动画演示http://www.atool.org/sort.php 代码演示1234567891011121314151617inline void BubbleSort()&#123; int len = arr.length(); for(int i = 0;i &lt; len - 1;++i) &#123; for(int j = 0;j &lt; len - 1;++j) &#123; if(arr[j] &gt; arr[j + i]) &#123; t = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = t; &#125; &#125; &#125;&#125; 选择排序（Selection Sort）选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 算法流程n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 动画演示http://www.atool.org/sort.php 代码演示123456789101112131415161718inline void SelectionSort()&#123; int len = arr.length(); int minindex,temp; for(int i = 0;i &lt; len - 1;++i) &#123; minindex = i; for(int j = i+1;j &lt; len;++i) &#123; if(a[j] &lt; a[minindex]) minindex = j; &#125; temp = a[i]; a[i] = a[minindex]; a[minindex] = temp; &#125;&#125; 插入排序（Insertion Sort）插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 算法流程一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 动画演示http://www.atool.org/sort.php 代码演示12345678910111213141516171819202122void insertSort(int a[], int n)&#123; for(int i = 1; i &lt; n; i++) //第一个元素作为基准元素，从第二个元素开始把其插到正确的位置 &#123; if(a[i] &lt; a[i-1]) //如果第i个元素比前面的元素小 &#123; int j = i-1; //需要判断第i个元素与前面的多个元素的大小，换成j继续判断 int x = a[i]; //将第i个元素复制为哨兵 while(j &gt;= 0 &amp;&amp; x &lt; a[j]) //找哨兵的正确位置，比哨兵大的元素依次后移 &#123; a[j+1] = a[j]; j--; &#125; a[j+1] = x; //把哨兵插入到正确的位置 &#125; &#125;&#125; 归并排序（Merge Sort）归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 算法流程 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 动画演示http://www.atool.org/sort.php 代码演示12345678910111213141516171819202122232425262728293031323334353637void Merge(int arr[], int p, int q, int r)&#123; int n1 = q - p + 1; int n2 = r - q + 1; int left[n1 + 1], right[n2]; for (int i = 0; i != n1; ++i)&#123; left[i] = arr[p + i]; &#125; left[n1] = N; for (int j = 0; j != n2 - 1; ++j)&#123; right[j] = arr[q + j + 1]; &#125; right[n2 - 1] = N; int i = 0, j = 0; for(int k = p; k != r + 1; ++k)&#123; if(left[i] &gt; right[j])&#123; arr[k] = right[j]; ++j; &#125; else&#123; arr[k] = left[i]; ++i; &#125; &#125;&#125;void MergeSort(int arr[], int p, int r)&#123; if(p &lt; r)&#123; int q = (p + r)/2; MergeSort(arr, p, q); MergeSort(arr, q + 1, r); Merge(arr, p, q, r); &#125;&#125; 快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 算法流程快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 动画演示http://www.atool.org/sort.php 代码演示1234567891011121314151617181920212223242526void quicksort(int left, int right) &#123; int i, j, t, temp; if(left &gt; right) return; temp = a[left]; //temp中存的就是基准数 i = left; j = right; while(i != j) &#123; //顺序很重要，要先从右边开始找 while(a[j] &gt;= temp &amp;&amp; i &lt; j) j--; while(a[i] &lt;= temp &amp;&amp; i &lt; j)//再找右边的 i++; if(i &lt; j)//交换两个数在数组中的位置 &#123; t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; //最终将基准数归位 a[left] = a[i]; a[i] = temp; quicksort(left, i-1);//继续处理左边的，这里是一个递归的过程 quicksort(i+1, right);//继续处理右边的 ，这里是一个递归的过程&#125; 离散化在很多情况下，问题的范围虽然定义在整数集合$Z$，但是只涉及其中$m$个有限数值，并且与数值的绝对大小无关（只把这些数值作为代表，或只与它们的相对顺序有关）。此时，我们就可以把整数集合$Z$中的这$m$个整数与$1～m$建立映射关系。 通俗来讲，就是把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。 算法流程 预处理 先将无序数组排序。 去重。 二分查找 知识拓展 C++STL中的unique函数解析 C++ lower_bound 与 upper_bound 函数 模板123456789101112131415161718//离散化预处理inline void discrete()&#123; //排序 sort(a + 1,a + n + 1); //去重 for(int i = 1;i &lt;= n;++i) &#123; if(i == 1 || a[i] != a[i-1]) b[++m] = a[i]; &#125;&#125;//二分查找 x映射为那个1~m之间的整数inline int query(int x)&#123; return lower_bound(b + 1,b + m + 1,x) - b;&#125; 例1 Cinema莫斯科正在举办一个大型国际会议，有$n$个来自不同国家的科学家参会。 每个科学家都只懂得一种语言。 为了方便起见，我们把世界上的所有语言用$1$到$10^9$之间的整数编号。 在会议结束后，所有的科学家决定一起去看场电影放松一下。 他们去的电影院里一共有$m$部电影正在上映，每部电影的语音和字幕都采用不同的语言。 对于观影的科学家来说，如果能听懂电影的语音，他就会很开心；如果能看懂字幕，他就会比较开心；如果全都不懂，他就会不开心。 现在科学家们决定大家看同一场电影。 请你帮忙选择一部电影，可以让观影很开心的人最多。 如果有多部电影满足条件，则在这些电影中挑选观影比较开心的人最多的那一部。 输入格式第一行输入一个整数$n$，代表科学家的数量。 第二行输入$n$个整数$a_1,a_2…a_n$,其中$a_i$表示第$i$个科学家懂得的语言的编号。 第三行输入一个整数$m$，代表电影的数量。 第四行输入$m$个整数$b_1,b_2…b_m$,其中$b_i$表示第i部电影的语音采用的语言的编号。 第五行输入$m$个整数$c_1,c_2…c_m$,其中$c_i$表示第i部电影的字幕采用的语言的编号。 请注意对于同一部电影来说，$b_i≠c_i$。 同一行内数字用空格隔开。 输出格式输出一个整数，代表最终选择的电影的编号。 如果答案不唯一，输出任意一个均可。 数据范围$1≤n,m≤200000$,$1≤a_i,b_i,c_i≤10^9$ 输入样例：1234532 3 223 22 3 输出样例：12 题解用不可重集map来进行映射，很容易想到。 然后再排序查找，这里要进行重载，因为语言和字幕的权重是不一样的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;const int MAX = 200010;int n,mm;unordered_map&lt;int, int&gt; m;struct node &#123; int pos,lan,sub; bool operator &lt;(const node &amp;num) const &#123; if(lan == num.lan) return sub &gt; num.sub; else return lan &gt; num.lan; &#125;&#125;a[MAX];inline void init()&#123; cin &gt;&gt; n; for(int i = 1;i &lt;= n;++i) &#123; int x; cin &gt;&gt; x; m[x]++; &#125; cin &gt;&gt; mm; for(int i = 1;i &lt;= mm;++i) &#123; int x; cin &gt;&gt; x; a[i].pos = i; a[i].lan = m[x]; &#125; for(int i = 1;i &lt;= mm;++i) &#123; int x; cin &gt;&gt; x; a[i].sub = m[x]; &#125;&#125;inline void find()&#123; sort(a+1,a+mm+1); cout &lt;&lt; a[1].pos;&#125;int main(void)&#123; init(); find(); return 0;&#125; 中位数没什么，就是中位数。。。 例1 货仓选址 在一条数轴上有 $N$ 家商店，它们的坐标分别为 $A_1$~$A_N$。 现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。 为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。 输入格式第一行输入整数$N$。 第二行$N$个整数$A_1$~$A_N$。 输出格式输出一个整数，表示距离之和的最小值。 数据范围$1≤N≤100000$ 输入样例：1246 2 9 1 输出样例：112 题解排序之后查找中位数，然后相加，完事。 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;const int MAX = 1e5 + 10;int num[MAX],n;inline void init()&#123; cin &gt;&gt; n; for(int i = 1;i &lt;= n;++i) cin &gt;&gt; num[i];&#125;inline long long find()&#123; sort(num+1,num+n+1); int mid = num[(1+n)/2]; long long ans = 0; for(int i = 1;i &lt;= n;++i) ans += abs(num[i] - mid); return ans;&#125;int main(void)&#123; init(); cout &lt;&lt; find(); return 0;&#125; 逆序对设有一个序列$a_1, a_2, a_3,…a_{n-1}, a_n$,对于序列中任意两个元素$a_i,a_j$，若$i&lt;j,a_i&gt;a_j$，则说明$a_i$和$a_j$是一对逆序对。 逆序对求解暴力写两层循环，时间复杂度为$O(n^2)$ 。 归并排序比如将下面两个区间排序 $a_i$ $mid=4$ $a_j$ $3,4,7,9$ $1,5,8,10$ 首先将右区间的 $1$ 取出，放到$r_k$中，此时 $1$ 是比每个$a_i$中的元素都小，也就是说此时i的指针指向 $a_1$ 的位置，此刻得到的逆序对的数量为 $4$ ； $r_k= 1$ ; 然后再将$a_i$和$a_j$比较（直到$a_i&lt;a_j$），$a_i&lt;a_j$ 将$a_i$的元素放到$r_k$中； $r_k= 1,3,4$; 现在$a_j&gt;a_i$,$ i$ 指向$a_3$的位置，将 $5$ 放到$r_k$中，得到的逆序对数量为 $2$ ； $r_k= 1,3,4,5$ 以此类推，直到进行完归并排序，每次合并都会求出逆序对的数目，即$mid-i+1$,最后每次将$ans$加上$mid-i+1$即可得到最后的答案； 树状数组 咕咕咕。。。。 参考资料 十大经典排序算法总结 洛谷：逆序对题解","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://chicago01.top/categories/算法竞赛进阶指南/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://chicago01.top/tags/排序/"}]},{"title":"","slug":"190208","date":"2019-02-08T13:56:50.000Z","updated":"2019-02-13T18:10:33.778Z","comments":true,"path":"2019/02/08/190208/","link":"","permalink":"http://chicago01.top/2019/02/08/190208/","excerpt":"","text":"自己选择的路，跪着也要走完🐷","categories":[],"tags":[]},{"title":"0x04 二分","slug":"0x04二分","date":"2019-02-08T10:34:50.000Z","updated":"2019-02-08T13:06:01.033Z","comments":true,"path":"2019/02/08/0x04二分/","link":"","permalink":"http://chicago01.top/2019/02/08/0x04二分/","excerpt":"整数域二分二分模板一共有两个，分别适用于不同情况。算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。","text":"整数域二分二分模板一共有两个，分别适用于不同情况。算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。 版本1当区间[l, r]的更新操作是r = mid; l = mid + 1;时，计算mid时不需要加1。 C++ 代码模板： 12345678910int bsearch_1(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; &#125; return l;&#125; 解读我们要在下面一串数中用上面的二分查找代码查找 $11$ 第一次查询，$(l + r)/2 = 4$，查到 $8$ ，是小于 $11$ 的，于是更新，$l = 4 + 1 = 5$ 第二次查询，$(l + r)/2 = 6$ ，查到$12$ ，是大于$11$的，于是更新，$r = mid = 6$ 第三次查询，$(l+r)/2 = 5$ ，查到$10$，是小于$11$的，于是更新，$l = 5+1 = 6$ 最终得到结果为$12$ 。12是我们查找到这一串数中，大于等于11(查找数)中最小值。 我们可以得到一个结论：以上二分模板用来解，最大值最小问题。 版本2当区间[l, r]的更新操作是r = mid - 1; l = mid;时，计算mid时需要加1。 C++ 代码模板： 12345678910int bsearch_2(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; 解读我们要在下面一串数中用上面的二分查找代码查找 $11$ 第一次查询，$(l + r+1)/2 = 4$，查到 $8$ ，是小于 $11$ 的，于是更新，$l = 4$ 第二次查询，$(l + r+1)/2 = 6$，查到 $12$ ，是大于 $11$ 的，于是更新，$r = 6-1 = 5$ 第三次查询，$(l + r+1)/2 = 5$，查到 $10$ ，是小于 $11$ 的，于是更新，$l = 5$ 最终得到结果为$10$ 。10是我们查找到这一串数中，小于等于11(查找数)中最大值。 我们可以得到一个结论：以上二分模板用来解，最小值最大问题。 二分答案二分答案与二分查找类似，即对有着单调性的答案进行二分，大多数情况下用于求解满足某种条件下的最大（小）值。 答案单调性答案的单调性大多数情况下可以转化为一个函数，其单调性证明多种多样，如下： 移动石头的个数越多，答案越大（NOIP2015跳石头）。 前i天的条件一定比前 i + 1 天条件更容易（NOIP2012借教室）。 满足更少分配要求比满足更多的要求更容易（NOIP2010关押罪犯）。 满足更大最大值比满足更小最大值的要求更容易（NOIP2015运输计划）。 时间越长，越容易满足条件（NOIP2012疫情控制）。 可以解决的问题把求最优解的问题，转化为给定一个值 $mid$ ，判定是否存在一个方案，达到 $mid$ 的的问题。(二分答案转化为判定)。 求最大的最小值（NOIP2015跳石头）。 求最小的最大值（NOIP2010关押罪犯）。 求满足条件下的最小（大）值。 求最靠近一个值的值。 求最小的能满足条件的代价。 一个小例子 有 $N$ 本书排成一行，已知第 $i$ 本书的厚度是 $A_i$ 。 把他们分成连续的 $M$ 组，$T$ 表示厚度之和最大的一组的厚度，使 $T$ 最小。 问的是最大值最小，很明显是一道二分题，题目让求 $T$ 值，我们可以直接来二分查找 $T$ 的值，在整数数轴上，肯定存在值，使得 $T$ 成立。呢么对应着使 $T$ 成立的这段数轴上，肯定也存在一个值，使得 $T$ 最小。 因此，可得，本题的做法就是，在整数数轴上二分查找一个 $T$ 值。 这道题也没有测试数据，只是书上的一个举例，我就不打打码了。 例1农夫约翰的农场由 $N$ 块田地组成，每块地里都有一定数量的牛,其数量不会少于1头，也不会超过2000头。 约翰希望用围栏将一部分连续的田地围起来，并使得围起来的区域内每块地包含的牛的数量的平均值达到最大。 围起区域内至少需要包含 $F$ 块地，其中 $F$ 会在输入中给出。 在给定条件下，计算围起区域内每块地包含的牛的数量的平均值可能的最大值是多少。 输入格式第一行输入整数 $N$ 和 $F$ ，数据间用空格隔开。 接下来 $N$ 行，每行输出一个整数，第$i+1$行输出的整数代表，第$i$片区域内包含的牛的数目。 输出格式输出一个整数，表示围起区域内每块地包含的牛的数量的平均值可能的最大值乘以1000得到的数值。 数据范围$1≤N≤100000$$1≤F≤N$ 输入样例：123456789101110 66 4210385941 输出样例：16500 题解：题意：给$N$个数，找一个平均值最大的，且长度大于等于$F$的子段。 题目问的是让我们找一个最大值，这种最大，最小的问题，无碍于两种做法，一种是单纯的枚举，另一种是二分查找，当然后面还有一些更高级的算法。这道题的数据范围，很明显是二分查找(其实$10^5$枚举也可以，但是这里并不是整数，是可以存在小数的)。 二分查找出来一个平均值$avg$来判定，能否成立一个子段大于等于$F$组且大于等于这个平均值$avg$。 1234567891011int search()&#123; while(r - l &gt; 1e-5) &#123; double mid = (l + r) / 2; if(find(mid)) l = mid; else r = mid; &#125; return (int)(r * 1000); &#125; 可以利用前缀和，$sum[i] = sum[i-1] + num[i] - avg$ ，如果这个前缀和中存在连续长度大于等于$F$且和大于等于$0$，就成立了。 123456789101112131415bool find(double avg)&#123; for(int i = 1;i &lt;= n;++i) sum[i] = sum[i-1] + num[i] - avg; double minn = 0; for(int i = f,j = 0;i &lt;= n;++i,++j) &#123; minn = min(minn,sum[j]); if(sum[i] - minn &gt;= 0) return true; &#125; return false;&#125; 关于这个式子怎么推出，😂，我还小，我表达不清楚，如果非要说说，呢，大概是经验告诉我这个式子要这么写。 上全部代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;const int MAX = 100010;int num[MAX],n,f;double l,r;double sum[MAX];void init()&#123; cin &gt;&gt; n &gt;&gt; f; for(int i = 1;i &lt;= n;++i) &#123; cin &gt;&gt; num[i]; r = max(r,(double)num[i]); &#125;&#125;bool find(double avg)&#123; for(int i = 1;i &lt;= n;++i) sum[i] = sum[i-1] + num[i] - avg; double minn = 0; for(int i = f,j = 0;i &lt;= n;++i,++j) &#123; minn = min(minn,sum[j]); if(sum[i] - minn &gt;= 0) return true; &#125; return false;&#125;int search()&#123; while(r - l &gt; 1e-5) &#123; double mid = (l + r) / 2; if(find(mid)) l = mid; else r = mid; &#125; return (int)(r * 1000); &#125;int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); init(); cout &lt;&lt; search(); return 0;&#125; 参考资料 Cosmos二分答案模板及二分答案问题讲解 yxc二分查找算法模板 《算法竞赛进阶指南》 lyd 秦淮岸~灯火阑珊 最佳的牛栏题解","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://chicago01.top/categories/算法竞赛进阶指南/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://chicago01.top/tags/二分/"}]},{"title":"","slug":"190207","date":"2019-02-07T13:34:50.000Z","updated":"2019-02-07T11:03:49.741Z","comments":true,"path":"2019/02/07/190207/","link":"","permalink":"http://chicago01.top/2019/02/07/190207/","excerpt":"","text":"一会去看《流浪地球》😜，夜间场，到明天早上一点啦😝。","categories":[],"tags":[]},{"title":"二分查找算法模板","slug":"[转]二分查找算法模板","date":"2019-02-07T03:34:50.000Z","updated":"2019-02-07T11:06:55.979Z","comments":true,"path":"2019/02/07/[转]二分查找算法模板/","link":"","permalink":"http://chicago01.top/2019/02/07/[转]二分查找算法模板/","excerpt":"原文链接:yxc学长:二分查找算法模板 二分模板一共有两个，分别适用于不同情况。算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。","text":"原文链接:yxc学长:二分查找算法模板 二分模板一共有两个，分别适用于不同情况。算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。 版本1当区间[l, r]的更新操作是r = mid; l = mid + 1;时，计算mid时不需要加1。 C++ 代码模板： 12345678910int bsearch_1(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; &#125; return l;&#125; 版本2当区间[l, r]的更新操作是r = mid - 1; l = mid;时，计算mid时需要加1。 C++ 代码模板： 12345678910int bsearch_2(int l, int r)&#123; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; return l;&#125; 补充一个对应最大值最小是什么什么的问题。一个对应最小值最大是什么什么的问题。","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://chicago01.top/categories/算法学习/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://chicago01.top/tags/二分/"}]},{"title":"0x02(2) 前缀和差分","slug":"0x02(2)前缀和差分","date":"2019-02-06T15:34:50.000Z","updated":"2019-02-06T07:07:37.490Z","comments":true,"path":"2019/02/06/0x02(2)前缀和差分/","link":"","permalink":"http://chicago01.top/2019/02/06/0x02(2)前缀和差分/","excerpt":"前缀和基本概念普通(一维，二维)前缀和: 12345a[1],a[2],a[3].....a[n]s[i] = a[i] + a[i-1]...a[2] + a[1]a[3] + a[4]...a[14] + a[15] = s[15] - s[3-1]s[l,r] = s[r] - s[l-1] 二维前缀和: 假设在一个二维平面上，每个点具有一定的权值，我们要计算点（2，2）到（8，4）的权值和。","text":"前缀和基本概念普通(一维，二维)前缀和: 12345a[1],a[2],a[3].....a[n]s[i] = a[i] + a[i-1]...a[2] + a[1]a[3] + a[4]...a[14] + a[15] = s[15] - s[3-1]s[l,r] = s[r] - s[l-1] 二维前缀和: 假设在一个二维平面上，每个点具有一定的权值，我们要计算点（2，2）到（8，4）的权值和。 首先我们要找到这么几块面积： 我们可以发现，我们所要求的黄色区域，就是黑色 - 绿色 - 粉色 + 青色。 好了，知识都听少的，看例题。 例1激光炸弹一种新型的激光炸弹，可以摧毁一个边长为 R 的正方形内的所有的目标。 现在地图上有 N 个目标，用整数Xi,Yi表示目标在地图上的位置，每个目标都有一个价值Wi。 激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个边长为 RR 的正方形的边必须和x，y轴平行。 若目标位于爆破正方形的边上，该目标不会被摧毁。 求一颗炸弹最多能炸掉地图上总价值为多少的目标。 输入格式第一行输入正整数 N 和 R ,分别代表地图上的目标数目和正方形的边长，数据用空格隔开。 接下来NN行，每行输入一组数据，每组数据包括三个整数Xi,Yi,Wi,分别代表目标的x坐标，y坐标和价值，数据用空格隔开。 输出格式输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。 数据范围0&lt;N≤100000≤Xi,Yi≤5000 输入样例：1232 10 0 11 1 1 输出样例：11 题解：这很明显就是一道二维前缀和的问题了，找区域最值。 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5010;int g[maxn][maxn];int main(void)&#123; int N,R; cin &gt;&gt; N &gt;&gt; R; int n = R, m = R; for(int i = 0,x,y,w;i &lt; N;++i) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; x++,y++; n = max(n,x); m = max(m,y); g[x][y] += w; &#125; for(int i = 1; i &lt;= n; i++) for(int j = 1;j &lt;= m; j++) g[i][j] += g[i-1][j] + g[i][j-1] - g[i][j]; int ans = 0; for(int i = R;i &lt;= n;i++) for(int j = R;j &lt;= m;j++) ans = max(ans,g[i][j]-g[i-R][j]-g[i][j-R]+g[i-R][j-R]); cout &lt;&lt; ans ; return 0;&#125; 差分基本概念12345a[1],a[2],.…a[n]b[i]=a[i]-a[i-1],b[1]=a[1]a[i]=b[1]+b[2]+.…+b[i] =a[1]+a[2]-a[1]+a[3]-a[2]+.…+a[i]-a[i-1] 由此可见，原数组就是差分数组的前缀和。我们可以举个例子： 12原始数组：9 3 6 2 6 8差分数组：9 -6 3 -4 4 2 现在有一个任务，在区间$[l,r]$上加一个常数c。 我们可以利用原数组就是差分数组的前缀和这个特性，来解决这个问题。显然可得出公式：$b[l] += c,b[r + 1] -= c$ 。 例2IncDec序列 给定一个长度为 $n$ 的数列 $a1,a2,…,an$，每次可以选择一个区间 $[l,r]$，使下标在这个区间内的数都加一或者都减一。 求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。 输入格式第一行输入正整数$n$。 接下来$n$行，每行输入一个整数，第$i+1$行的整数代表$ai$。 输出格式第一行输出最少操作次数。 第二行输出最终能得到多少种结果。 数据范围$0&lt;n≤10^5$,$0≤ai&lt;2147483648$ 输入样例：1234541122 输出样例：1212 题解：要使最后的数都一样，那么$b$数组中的$b2=&gt;bn$ 一定全 $0$ 因为 1234b2 = a2-a1;b3 = a3-a2;......bn = an-an-1; 如果全0 的话， $a1=a2=a3=…=an$ 所以我们可以用贪心的思想，来使得b中所有数变成零。 我们知道我们在做b[L]++,b[R+1]--;操作的时候，要找两个数配对，那么 负数++，正数--，是不是就最快了。 但是最终结果可能依然不是全 $0$ 的，因为 $abs(sum(正数)) 可能 ！= abs(sum(负数))$ 所以，我们可以 让最后不等于0 的数全和 $b1|| bn+1$来换。 $ans1 = min(pos,neg)+abs(pos-neg)$ $ans2 = abs(pos-neg)+1$ 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;int num[maxn];inline void init()&#123; int n = 0; cin &gt;&gt; n; for(int i = 1;i &lt;= n;++i) cin &gt;&gt; num[i]; for(int i = n;i &gt; 1;--i) num[i] -= num[i-1];&#125;inline void frond()&#123; long long pos = 0,neg = 0; for(int i = 2;i &lt;= n;++i) &#123; if(a[i] &gt; 0) pos += a[i]; else neg -= a[i]; &#125; cout &lt;&lt; min(pos,neg) + abs(pos - neg) &lt;&lt; endl &lt;&lt; abs(pos - neg) + 1;&#125;int main(void)&#123; init(); frond(); return 0;&#125;","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://chicago01.top/categories/算法竞赛进阶指南/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://chicago01.top/tags/数据结构/"}]},{"title":"","slug":"190206","date":"2019-02-06T07:34:50.000Z","updated":"2019-02-06T07:45:53.564Z","comments":true,"path":"2019/02/06/190206/","link":"","permalink":"http://chicago01.top/2019/02/06/190206/","excerpt":"","text":"最近在搞《算法竞赛进阶指南》。","categories":[],"tags":[]},{"title":"0x03 递归","slug":"0x03递归","date":"2019-02-01T14:34:50.000Z","updated":"2019-02-05T14:43:29.141Z","comments":true,"path":"2019/02/01/0x03递归/","link":"","permalink":"http://chicago01.top/2019/02/01/0x03递归/","excerpt":"例题1：递归实现指数型枚举 从 1~n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。 输入格式输入一个整数n。 输出格式每行输出一种方案。 同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。 对于没有选任何数的方案，输出空行。 本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。","text":"例题1：递归实现指数型枚举 从 1~n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。 输入格式输入一个整数n。 输出格式每行输出一种方案。 同一行内的数必须升序排列，相邻两个数用恰好1个空格隔开。 对于没有选任何数的方案，输出空行。 本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。 数据范围1≤n≤15 输入样例：13 输出样例：1234567322 311 31 21 2 3 题解：可以很单纯的用STL中的vector枚举就行了，存在两种操作，要或不要。 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;int n;vector&lt;int&gt; num;void dfs(int k)&#123; //到达枚举边界，输出结果并结束 if(k == n + 1) &#123; for(int i = 0;i &lt; num.size();++i) cout &lt;&lt; num[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return; &#125; //不选择这个数 dfs(k+1); //选择这个数 num.push_back(k); dfs(k+1); //回溯 num.pop_back();&#125;int main(void)&#123; cin &gt;&gt; n; dfs(1); return 0;&#125; 当然也可以向yxc大神学习，用二进制状态压缩。也就是用二进制上的位来记录数有没有被用过。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;int n;// u是当前枚举到的数，state是二进制数记录哪些数被选void dfs(int u, int state) &#123; if (u == n) &#123; for (int i = 0; i &lt; n; i++) &#123; //判断第i位是不是1，即有没有被选，如果被选就输出 if (state &gt;&gt; i &amp; 1) //因为题目是从1开始的，所以要加1 cout &lt;&lt; i + 1 &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; return ; &#125; //不用这个数，不进行操作 dfs (u + 1, state); //用这个数，把第u位变成1 dfs (u + 1, state | (1 &lt;&lt; u));&#125;int main(void) &#123; cin &gt;&gt; n; dfs(0, 0); return 0;&#125; 例2：递归实现组合型枚举 从 1~n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。 输入格式两个整数 n,m ,在同一行用空格隔开。 输出格式按照从小到大的顺序输出所有方案，每行1个。 首先，同一行内的数升序排列，相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如1 3 5 7排在1 3 6 8前面）。 数据范围n&gt;0,0≤m≤n ,n+(n−m)≤25 输入样例：15 3 输出样例：123456789101 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5 题解：其实只需要把例1的代码稍加修改就可以了。再增加两个情况，一种是动态数组所选择的数已经超过了m个，或者剩余的数凑不够m个，排除这两种情况就是我们所要的答案了。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;vector&lt;int&gt; num;void dfs(int k)&#123; //如题解所述 if(num.size() &gt; m || num.size() + (n - k + 1) &lt; m) return; //到达枚举边界，输出结果并结束 if(k == n + 1) &#123; for(int i = 0;i &lt; num.size();++i) cout &lt;&lt; num[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return; &#125; //选择这个数 num.push_back(k); dfs(k+1); //回溯 num.pop_back(); //不选择这个数 dfs(k+1);&#125;int main(void)&#123; cin &gt;&gt; n &gt;&gt; m; dfs(1); return 0;&#125; 例3：递归实现排列型枚举 把 1~n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。 输入格式一个整数n。 输出格式按照从小到大的顺序输出所有方案，每行1个。 首先，同一行相邻两个数用一个空格隔开。 其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。 数据范围1≤n≤9 输入样例：13 输出样例：1234561 2 31 3 22 1 32 3 13 1 23 2 1 题解：这种问题是裸的全排列问题。 我的做法是用一个桶来统计我那些数用过，那些没有用过，然后再用一个数组，把我所用的数加进去，同样的，对于每个数来说，只有两种操作，就是要或不要。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;int n;int num[10];bool tong[10];void dfs(int k)&#123; if(k == n + 1) &#123; for(int i = 1;i &lt;= n;++i) cout &lt;&lt; num[i] &lt;&lt; \" \"; cout &lt;&lt; endl; return; &#125; for(int i = 1;i &lt;= n;++i) &#123; if(tong[i] == 0) &#123; num[k] = i; tong[i] = 1; dfs(k + 1); num[k] = 0; tong[i] = 0; &#125; &#125;&#125;int main(void)&#123; cin &gt;&gt; n; dfs(1); return 0;&#125;","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://chicago01.top/categories/算法竞赛进阶指南/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://chicago01.top/tags/搜索/"}]},{"title":"0x02 递推","slug":"0x02(1)递推","date":"2019-01-31T14:34:50.000Z","updated":"2019-02-05T15:02:47.573Z","comments":true,"path":"2019/01/31/0x02(1)递推/","link":"","permalink":"http://chicago01.top/2019/01/31/0x02(1)递推/","excerpt":"例1：费解的开关 你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。","text":"例1：费解的开关 你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。 我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态 123451011101101101111000011011 在改变了最左上角的灯的状态后将变成： 123450111111101101111000011011 再改变它正中间的灯后状态将变成： 123450111111001110011010011011 给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。 输入格式第一行输入正整数n，代表数据中共有n个待解决的游戏初始状态。 以下若干行数据分为n组，每组数据有5行，每行5个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。 输出格式一共输出n行数据，每行有一个小于等于6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。 对于某一个游戏初始状态，若6步以内无法使所有灯变亮，则输出“-1”。 数据范围0&lt;n≤500 输入样例：1234567891011121314151617183001110101110001110101110011101111011111011111111110111111111111111111111111 输出样例：12332-1 题解：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3fffffff;char g[6][6];int dx[6] = &#123;0,-1,0,1,0&#125;,dy[6] = &#123;0,0,1,0,-1&#125;;void turn(int x,int y)&#123; for(int i = 0;i &lt; 5;++i) &#123; int nx = x + dx[i],ny = y + dy[i]; if(nx &gt;= 0 &amp;&amp; nx &lt; 5 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; 5) g[nx][ny] ^= 1; &#125;&#125;int work()&#123; int ans = inf; for(int i = 0;i &lt; 1 &lt;&lt; 5;++i) &#123; int res = 0; char cpy[6][6]; memcpy(cpy,g,sizeof(g)); for(int j = 0;j &lt; 5;++j) &#123; if(i &gt;&gt; j &amp; 1) &#123; res ++; turn(0,j); &#125; &#125; for(int y = 0;y &lt; 4;++y) &#123; for(int x = 0;x &lt; 5;++x) &#123; if(g[y][x] == '0') &#123; res ++ ; turn(y + 1,x); &#125; &#125; &#125; bool qwq = true; for(int x = 0;x &lt; 5;++x) if(g[4][x] == '0') &#123; qwq = false; break; &#125; if(qwq) ans = min(ans,res); memcpy(g,cpy,sizeof(g)); &#125; if(ans &gt; 6) ans = -1; return ans;&#125;int main(void)&#123; int T; cin &gt;&gt; T; while(T--) &#123; for(int i = 0;i &lt; 5;++i) cin &gt;&gt; g[i]; cout &lt;&lt; work() &lt;&lt; endl; &#125; return 0;&#125; 例2：奇怪的汉诺塔 汉诺塔问题，条件如下： 1、这里有A、B、C和D四座塔。 2、这里有n个圆盘，n的数量是恒定的。 3、每个圆盘的尺寸都不相同。 4、所有的圆盘在开始时都堆叠在塔A上，且圆盘尺寸从塔顶到塔底逐渐增大。 5、我们需要将所有的圆盘都从塔A转移到塔D上。 6、每次可以移动一个圆盘，当塔为空塔或者塔顶圆盘尺寸大于被移动圆盘时，可将圆盘移至这座塔上。 请你求出将所有圆盘从塔A移动到塔D，所需的最小移动次数是多少。 汉诺塔塔参考模型 输入格式没有输入 输出格式对于每一个整数n(1≤n≤12),输出一个满足条件的最小移动次数，每个结果占一行。 输入样例：1没有输入 输出样例：1参考输出格式 题解：先看图： 三柱两盘的情况（刨去初时状态，共移动了3次） 三柱三盘的情况（刨去初时状态，共移动了7次） 综上两图，我们可以看到，对于n盘3塔问题，移动的最小步数就是，把前n-1个盘子从A柱移到B柱，然后把第n个盘子移到C柱，最后再把前n-1个盘子移动到C柱。可以得出递推式$d[n] = d[n-1] * 2 + 1$ 。 但是本题没有呢么友善，题目要求我们求四塔情况下最小的移动步数，难受死我了，呢就继续画图看看？？ 四塔3盘（除去初始状态，共移动5次） 四塔4盘（除去初始状态，共盘他9次） 综上，可得先把i个盘子在四塔的模式下，移动到一根柱子上（不可以是D柱），然后把n-i个盘子，盘到D柱上。考虑到i可能存在最小值，如上图⑤⑥中的C柱。可得递推式$f[i] = min_{1≤i＜n}(2*f[i] + d[n-i]) , f[1] = 1$ 。 代码献丑了。。。 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int a[15],f[15];int main(void)&#123; a[1] = 1; for(int i = 2;i &lt;= 12;++i) a[i] = 1 + a[i-1] * 2; memset(f,0x3f,sizeof(f)); f[0] = 0; for(int i = 1;i &lt;= 12;++i) &#123; for(int j = 0;j &lt; i;++j) f[i] = min(f[i],f[j] * 2 + a[i - j]); &#125; for(int i = 1;i &lt;= 12;++i) cout &lt;&lt; f[i] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://chicago01.top/categories/算法竞赛进阶指南/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://chicago01.top/tags/搜索/"}]},{"title":"0x01 位运算","slug":"0x01-位运算","date":"2019-01-30T14:34:50.000Z","updated":"2019-01-30T17:04:09.479Z","comments":true,"path":"2019/01/30/0x01-位运算/","link":"","permalink":"http://chicago01.top/2019/01/30/0x01-位运算/","excerpt":"基本操作1234与 &amp; 都为真为真或 | 有一个为真就为真非 ! 真的变假，假的变真异或 ^ 如果相同为0，不同为1 补码int 32位 首位符号位，如果是0为正数，为1为负数。 1231: 0000000000...012: 0000000000...103: 0000000000...11 补码：","text":"基本操作1234与 &amp; 都为真为真或 | 有一个为真就为真非 ! 真的变假，假的变真异或 ^ 如果相同为0，不同为1 补码int 32位 首位符号位，如果是0为正数，为1为负数。 1231: 0000000000...012: 0000000000...103: 0000000000...11 补码： 123456781 + x = 000000000...00x = 1111111111...111 + 1111111111...11 = 0000000000...002 + 1111111111...10 = 0000000000...00x + ??????????...?? = 0000000000...00? = ~x + 1~x + 1 是 x 的补码-n = ~n + 1 小技巧 数组初始化memset(f,0x3f,sizeof(f)) 左移运算符 &lt;&lt; 123二进制 ： 1 -&gt; 10 -&gt; 100 -&gt; 1000十进制 ： 1 -&gt; 2 -&gt; 4 -&gt; 8综上所述：1 &lt;&lt; n == 2^n 右移运算符&gt;&gt; 123二进制 ： 1000 -&gt; 100 -&gt; 10 -&gt; 1十进制 : 8 -&gt; 4 -&gt; 2 -&gt; 1综上所述: n &gt;&gt; x == n / (2^x) 例题1a^b快速幂求 a 的 b 次方对 p 取模的值。 输入格式三个整数 a,b,p,在同一行用空格隔开。 输出格式输出一个整数，表示a^b mod p的值。 数据范围$1≤a,b,p≤10^9$ 输入样例：13 2 7 输出样例：12 题解：按照朴素算法就是把a连乘b次，这样一来时间复杂度是O(b)也即是O(n)级别，快速幂能做到O(logn)。 $a^b$，那么其实b是可以拆成二进制的，该二进制数第i位的权为$2^{(i-1)}$，例如当b==11时，$a^{11}=a^{(2^0+2^1+2^3)}$ 。 11的二进制是1011，11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为算 $a^(2^0)a^(2^1)a^(2^3) $ 。 由于是二进制，很自然地想到用位运算这个强大的工具： &amp; 和 &gt;&gt; ，&amp;运算通常用于二进制取位操作，例如一个数 &amp; 1 的结果就是取二进制的最末位。还可以判断奇偶x&amp;1==0为偶，x&amp;1==1为奇。&gt;&gt;运算比较单纯,二进制去掉最后一位 。 代码：12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int a,b,mod;int main(void)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; mod; int res = 1 % mod; while(b) &#123; if(b&amp;1) res = 1ll * res * a % mod; a = 1ll * a * a % mod; b &gt;&gt;= 1; &#125; cout &lt;&lt; res; return 0;&#125; 例题2:64位整数乘法求 a 乘 b 对 p 取模的值。 输入格式第一行输入整数aa，第二行输入整数bb，第三行输入整数pp。 输出格式输出一个整数，表示a*b mod p的值。 数据范围1≤a,b,p≤10181≤a,b,p≤1018 输入样例：123345 输出样例：12 题解：1234567a * ba + a + a + a + a + a +...+ aa * 1 = aa * 2 = 2aa * 3 = 3a...a * (2^k) = 2^k * a 代码：12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;long long a,b,mod;int main(void)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; mod; long long ans; while(b) &#123; if(b&amp;1) ans = (ans + a) % mod; a = a * 2 % mod; b &gt;&gt;= 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法竞赛进阶指南","slug":"算法竞赛进阶指南","permalink":"http://chicago01.top/categories/算法竞赛进阶指南/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"http://chicago01.top/tags/位运算/"}]},{"title":"CH 2101 可达性统计","slug":"做题记录-CH-2101-可达性统计","date":"2019-01-30T14:15:50.000Z","updated":"2019-02-08T14:04:57.558Z","comments":true,"path":"2019/01/30/做题记录-CH-2101-可达性统计/","link":"","permalink":"http://chicago01.top/2019/01/30/做题记录-CH-2101-可达性统计/","excerpt":"题目链接 题目描述给定一张N个点M条边的有向无环图，分别统计从每个点出发能够到达的点的数量。 输入格式第一行两个整数N,M，接下来M行每行两个整数x,y，表示从x到y的一条有向边。","text":"题目链接 题目描述给定一张N个点M条边的有向无环图，分别统计从每个点出发能够到达的点的数量。 输入格式第一行两个整数N,M，接下来M行每行两个整数x,y，表示从x到y的一条有向边。 输出格式输出共N行，表示每个点能够到达的点的数量。 数据范围1≤N,M≤30000 输入样例：123456789101110 103 82 32 55 95 92 33 94 82 104 9 输出样例：123456789101633211111 题意分析：题目已经说明白，给我们的是DAG(有向无环图)。既然是DAG，可以很容易的联想到拓扑排序。题目让我们统计每个点出发能到达的点的数量，我们可以先模拟一下样例，如下图(只例举出1，2，3三个点)。 题解：综上所述，设从点 x 出发能够到达的点构成的集合是 f(x)，从点 x 出发能够到达的点，是从 x 的各个后继节点 y 出发能够到达的点的并集，再加上点 x 自身 。 f(2) = f(3) ∪ f(5) ∪ f(10) = … 先按照拓扑排序算法求出拓扑序，然后按照拓扑序的倒叙进行计算——因为在拓扑序中，任意一条边 (x , y)，x 都排在 y 之前。 关于状态压缩 bitset容器：1转载：https://oi-wiki.org/ds/stl/bitset/ 介绍¶std :: bitset 是标准库中的一个固定大小序列，其储存的数据只包含 0/1 众所周知，由于内存地址是按字节即 byte 寻址，而非比特 bit , 我们一个 bool 类型的变量，虽然只能表示 0/1 , 但是也占了 1byte 的内存 bitset 就是通过固定的优化，使得一个字节的八个比特能分别储存 8 位的 0/1 对于一个 4 字节的 int 变量，在只存 0/1 的意义下， bitset 占用空间只是其 在某些情况下通过 bitset 可以使你的复杂度除以 32 当然， vector 的一个特化 vector&lt;bool&gt; 的储存方式同 bitset 一样，区别在于其支持动态开空间， bitset 则和我们一般的静态数组一样，是在编译时就开好了的。 那么为什么要用 bitset 而非 vector&lt;bool&gt; ? 通过以下的介绍，你可以更加详细的看到 bitset 具备的方便操作 1#include &lt;bitset&gt; // 包含 bitset 的头文件 运算符¶ operator[] : 访问其特定的一位 operator ==/！= : 比较两个 bitset 内容是否完全一样 operator &amp;=/|=/^=/~ : 进行按位与/或/异或/取反操作 operator &lt;&lt;/&gt;&gt;/&lt;&lt;=/&gt;&gt;= : 进行二进制左移/右移 operator &lt;&lt;/&gt;&gt; : 流运算符，这意味着你可以通过 cin/cout 进行输入输出 vector&lt;bool&gt; 只具有前两项 成员函数¶ test() : 它和 vector 中的 at() 的作用是一样的，和 [] 运算符的区别就是越界检查 count() : 返回 true 的数量 set() : 将整个 bitset 设置成 true , 你也可以传入参数使其设置成你的参数 reset() : 将整个 bitset 设置成 false flip() : 翻转该位 (0 变 1,1 变 0), 相当于逻辑非/异或 1 to_string() : 返回转换成的字符串表达 to_ulong() : 返回转换成的 unsigned long 表达 ( long 在 NT 及 32 位 POSIX 系统下与 int 一样，在 64 位 POSIX 下与 long long 一样） to_ullong() C++11, 返回转换成的 unsigned long long 表达 这些 vector&lt;bool&gt; 基本都没有 作用¶一般来讲，我们可以用 bitset 优化一些可行性 DP, 或者线筛素数 ( notprime 这种 bool 数组可以用 bitset 开到 之类的） 它最主要的作用还是压掉了内存带来的时间优化， 的常数优化已经可以是复杂度级别的优化了，比如一个 的 算法， 显然很卡，在常数大一点的情况下必然卡不过去，O（松）不能算！, 这时候如果我们某一维除以 32, 则可以比较保险的过了这道题 其实 bitset 不光是一个容器，更是一种思想，我们可以通过手写的方式，来把 long long 什么的压成每 bit 表示一个信息，用 STL 的原因更多是因为它的运算符方便 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 30000 + 5;int n,m;int in[maxn];vector&lt;int&gt; e[maxn];vector&lt;int&gt; topo;bitset&lt;maxn&gt; f[maxn];inline void toposort()&#123; topo.clear(); queue&lt;int&gt; q; for(int i = 1;i &lt;= n;++i) if(in[i] == 0) q.push(i); while(q.size()) &#123; int u = q.front(); q.pop(); topo.push_back(u); for(int i = 0;i &lt; e[u].size();++i) if(--in[e[u][i]] == 0) q.push(e[u][i]); &#125; &#125;void init()&#123; cin &gt;&gt; n &gt;&gt; m; memset(in,0,sizeof(in)); for(int i = 1;i &lt;= m;++i) &#123; int x,y; cin &gt;&gt; x &gt;&gt; y; in[y]++; e[x].push_back(y); &#125;&#125;void find()&#123; toposort(); for(int i = topo.size() - 1;i &gt;= 0;i--) &#123; int x = topo[i]; f[x].reset(),f[x][x] = 1; for(int k = 0;k &lt; e[x].size();++k) f[x] |= f[e[x][k]]; &#125; for(int i = 1;i &lt;= n;++i) cout &lt;&lt; f[i].count() &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123; ios::sync_with_stdio(false); init(); find(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://chicago01.top/categories/题解/"}],"tags":[{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://chicago01.top/tags/拓扑排序/"}]},{"title":"图论入门","slug":"图论入门","date":"2019-01-29T06:05:37.000Z","updated":"2019-01-30T17:04:27.074Z","comments":true,"path":"2019/01/29/图论入门/","link":"","permalink":"http://chicago01.top/2019/01/29/图论入门/","excerpt":"图概念 有向图 无向图 入度出度 节点 边权 路径 圈/环 存储 邻接矩阵 邻接表","text":"图概念 有向图 无向图 入度出度 节点 边权 路径 圈/环 存储 邻接矩阵 邻接表 vector存图 12345678910111213141516171819202122232425262728293031 #include &lt;vector&gt;using namespace std; //个人习惯sreuct Edge &#123; int from, to, dist; Edge() &#123;&#125; Edge(int _from, int _to, int _dist): from(_from), to(_to), dist(_dist) &#123;&#125;&#125;;vector&lt;Edge&gt; g[MAXN];void insert(int u, int v, in w) &#123; //双向边带权值w g[u].push_back(Edge(u, v, w)); g[v].push_back(Edge(v, u, w));&#125;int now;//枚举点now的出边//不推荐的写法，完全没有使用STL特性for (int i = 0; i &lt; g[now].size(); i++) &#123; Edge &amp;e = g[now][i]; printf(\"%d\\n\", e.to);&#125;//推荐的写法for (vector&lt;Edge&gt;::iterator it = g[now].begin(); it != g[now].end(); it++) &#123; printf(\"%d\\n\", it-&gt;to);&#125;//C++11for (auto &amp;e : g[now]) &#123; printf(\"%d\\n\", e.to);&#125; 链式前向星 12345678910111213141516171819202122232425struct Edge &#123; int from, to, dist; Edge() &#123;&#125; Edge(int _from, int _to, int _dist): from(_from), to(_to), dist(_dist) &#123;&#125;&#125;;Edge ed[MAXM];int he[MAXN], ne[MAXM], etop = 1;//边编号从1开始，0代表没有下一条边，对应链表的NULL//he[i]代表点i边集中的第一条边编号，对应链表的head指针//ne[i]代表边i的下一条边编号，对应链表中的next指针//ed[i]代表边i的信息void insert(int u, int v, int w) &#123; //单向边带权值w ed[etop] = Edge(u, v, w); ne[etop] = he[u]; he[u] = etop++; //单向链表从头部插入元素&#125;int now;for (int i = he[now]; i; i = ne[i]) &#123; Edge &amp;e = ed[i]; printf(\"%d\\n\", e.to);&#125; INF 未连通的边，把边权视为无限大 -1：非负权值使用 0x7fffffff : 理论非常大，但相加会溢出 0x3fffffff : 相加不会溢出 0x3f3f3f3f : 常用，不溢出，可用memset(); 拓扑排序遍历节点时，有一个特殊的遍历顺序。对DAG(有向无环图)进行特殊的遍历：寻找DAG上的最长链。 建图时记录入度 把没有入度的每一个点放进队列里 队头出 出队点相连的点入度– 回到步骤2，直到所有点都遍历完 最小生成树 Prim 适用于稠密图，时间复杂度 O(n2)O(n2)。 核心思想：每次挑一条与当前集合相连的最短边。 1234567891011121314151617181920212223242526272829303132// st[i] 表示点i是否在当前生成树集合中// dist[i] 表示点i到当前集合的最短边的长度// gi 表示点i和点j之间边的长度// 返回值：最小生成树中所有边的总长度int Prim()&#123; int res = 0; for (int i = 1; i &lt;= n; i ++ ) &#123; dist[i] = INF; st[i] = false; &#125; dist[1] = 0; for (int i = 1; i &lt;= n; i ++ ) &#123; int id = -1, min_dist = INF; // 寻找最短边 for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; dist[j] &lt; min_dist) &#123; id = j; min_dist = dist[j]; &#125; st[id] = true; res += dist[id]; // 用新加入的点更新其余点到生成树的最短边 for (int j = 1; j &lt;= n; j ++ ) if (!st[j]) dist[j] = min(dist[j], gid); &#125; return res;&#125; 克鲁斯卡尔 适用于稀疏图，时间复杂度 O(mlogm)O(mlogm)。 核心思想：从小到大挑不多余的边。 123456789101112131415161718192021222324252627282930313233343536// 边的信息struct Edge&#123; int a, b, v; bool operator&lt; (const Edge &amp;W) const &#123; return v &lt; W.v; &#125;&#125;;// 并查集——寻找当前集合的代表元素int find(int x)&#123; if (father[x] != x) father[x] = find(father[x]); return father[x];&#125;// 所有边存储在 Edge edges[M]; // 函数返回最小生成树中所有边的总长度int Kruskal()&#123; int res = 0; // 初始化并查集代表元素 for (int i = 1; i &lt;= n; i ++ ) father[i] = i; sort(edge, edge + m); for (int i = 0; i &lt; m; i ++ ) &#123; int a = edge[i].a, b = edge[i].b; if (find(a) != find(b)) &#123; res += edge[i].v; father[find(a)] = find(b); &#125; &#125; return res;&#125; 最短路 Floyd算法： 多源最短路，求出所有点对的最短路长度 时间复杂度：0（$n^3$） Dijkstra算法: 单源最短路，求出某个点s到所有点的最短路长度 时间复杂度：$0（n^2）$/$0（mlogn）$ 无法处理负权 SPFA算法，即队列优化的Be11man-Ford算法 单源最短路，求出某个点s到所有点的最短路长度 时间复杂度：声称为0（m），最坏0（nm），容易卡到最坏 可以处理负权边，可以判断负权环 Floyd算法：本质就是DP。 设d[i][j][k]为从i到j，仅通过编号为1-k的中间节点的最短路径距离 $d[i][j][k]=min（d[i][j][k-1]，d[i][k][k-1]+d[k][j][k-1]）$ 初始值d[i][j][e]为两点之间边权值，未连通为INF 从1到n枚举k，然后枚举（i，j） 为了方便可以不开第三维，在原地迭代 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N = 1010, M = 2000010, INF = 1000000000;int n, m;int d[N][N];int main()&#123; cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) d[i][j] = i == j ? 0 : INF; for (int i = 0; i &lt; m; i++) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; d[a][b] = d[b][a] = min(c, d[a][b]); &#125; // floyd 算法核心 for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); cout &lt;&lt; d[1][n] &lt;&lt; endl; return 0;&#125; Dijkstra算法:$O(n^2)$做法，不优化版本：最裸的dijkstra算法，不用堆优化。每次暴力循环找距离最近的点。只能处理边权为正数的问题。图用邻接矩阵存储。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010, M = 2000010, INF = 1000000000;int n, m;int g[N][N], dist[N];bool st[N];void dijkstra()&#123; for (int i = 1; i &lt;= n; i++) dist[i] = INF; dist[1] = 0; for (int i = 0; i &lt; n; i++) &#123; int id, mind = INF; for (int j = 1; j &lt;= n; j++) if (!st[j] &amp;&amp; dist[j] &lt; mind) &#123; mind = dist[j]; id = j; &#125; st[id] = 1; for (int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], dist[id] + g[id][j]); &#125;&#125;int main()&#123; cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) g[i][j] = INF; for (int i = 0; i &lt; m; i++) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; g[a][b] = g[b][a] = min(g[a][b], c); &#125; dijkstra(); cout &lt;&lt; dist[n] &lt;&lt; endl; return 0;&#125; dijkstra+heap优化 $O(mlogn)$用堆维护所有点到起点的距离。时间复杂度是 O(mlogn)。这里我们可以手写堆，可以支持对堆中元素的修改操作，堆中元素个数不会超过 n。也可以直接使用STL中的priority_queue，但不能支持对堆中元素的修改，不过我们可以将所有修改过的点直接插入堆中，堆中会有重复元素，但堆中元素总数不会大于 m。只能处理边权为正数的问题。图用邻接表存储。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;functional&gt;using namespace std;const int N = 1010, M = 2000010, INF = 1000000000;int n, m;int dist[N];int h[N], e[M], v[M], ne[M], idx;void add(int a, int b, int c)&#123; e[idx] = b, v[idx] = c, ne[idx] = h[a], h[a] = idx++;&#125;void dijkstra_heap()&#123; priority_queue &lt; pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; heap; for (int i = 1; i &lt;= n; i++) dist[i] = INF; dist[1] = 0; heap.push(make_pair(dist[1], 1)); while (heap.size()) &#123; pair&lt;int, int&gt; t = heap.top(); heap.pop(); if (t.first &gt; dist[t.second]) continue; for (int i = h[t.second]; i != -1; i = ne[i]) if (dist[e[i]] &gt; t.first + v[i]) &#123; dist[e[i]] = t.first + v[i]; heap.push(make_pair(dist[e[i]], e[i])); &#125; &#125;&#125;int main()&#123; memset(h, -1, sizeof h); cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; m; i++) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); add(b, a, c); &#125; dijkstra_heap(); cout &lt;&lt; dist[n] &lt;&lt; endl; return 0;&#125; SPFA算法：bellman-ford算法的优化版本，可以处理存在负边权的最短路问题。最坏情况下的时间复杂度是 O(nm)，但实践证明spfa算法的运行效率非常高，期望运行时间是 O(km)，其中 k 是常数。但需要注意的是，在网格图中，spfa算法的效率比较低，如果边权为正，则尽量使用 dijkstra 算法。 图采用邻接表存储。队列为手写的循环队列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N = 1010, M = 2000010, INF = 1000000000;int n, m;int dist[N], q[N];int h[N], e[M], v[M], ne[M], idx;bool st[N];void add(int a, int b, int c)&#123; e[idx] = b, v[idx] = c, ne[idx] = h[a], h[a] = idx++;&#125;void spfa()&#123; int hh = 0, tt = 0; for (int i = 1; i &lt;= n; i++) dist[i] = INF; dist[1] = 0; q[tt++] = 1, st[1] = 1; while (hh != tt) &#123; int t = q[hh++]; st[t] = 0; if (hh == n) hh = 0; for (int i = h[t]; i != -1; i = ne[i]) if (dist[e[i]] &gt; dist[t] + v[i]) &#123; dist[e[i]] = dist[t] + v[i]; if (!st[e[i]]) &#123; st[e[i]] = 1; q[tt++] = e[i]; if (tt == n) tt = 0; &#125; &#125; &#125;&#125;int main()&#123; memset(h, -1, sizeof h); cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; m; i++) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); add(b, a, c); &#125; spfa(); cout &lt;&lt; dist[n] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://chicago01.top/categories/算法学习/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://chicago01.top/tags/图论/"}]},{"title":"Markdown中优美的打出数学公式","slug":"Markdown中优美的打出数学公式","date":"2019-01-28T14:15:10.000Z","updated":"2019-01-28T17:19:17.080Z","comments":true,"path":"2019/01/28/Markdown中优美的打出数学公式/","link":"","permalink":"http://chicago01.top/2019/01/28/Markdown中优美的打出数学公式/","excerpt":"转载：https://blog.csdn.net/u014630987/article/details/70156489","text":"转载：https://blog.csdn.net/u014630987/article/details/70156489","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://chicago01.top/categories/计算机科学/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://chicago01.top/tags/杂项/"}]},{"title":"树状数组","slug":"树状数组","date":"2019-01-28T14:05:24.000Z","updated":"2019-01-30T17:04:32.556Z","comments":true,"path":"2019/01/28/树状数组/","link":"","permalink":"http://chicago01.top/2019/01/28/树状数组/","excerpt":"例1：给出一个长度为n的序到，有m个询问，每次形如l，r，求[l，r]的区间和。 法1： 暴力 每次询问都扫一遍。 法2： 前缀和 预处理O(n),每询问次O(1)时间复杂度。 法3： 线段树 &amp; 树状数组 弱智。。。","text":"例1：给出一个长度为n的序到，有m个询问，每次形如l，r，求[l，r]的区间和。 法1： 暴力 每次询问都扫一遍。 法2： 前缀和 预处理O(n),每询问次O(1)时间复杂度。 法3： 线段树 &amp; 树状数组 弱智。。。 例2：给出一个长度为n的序到，有m个操作，分别为询问[l，r]的区间和，和将x位置上的值增加c。 暴力前缀和行不通，每次修改都需要重新计算前缀和，这时候正解就是树状数组了。 lowbit(x) : 等于x在二进制下最右边呢个1代表的多少。 1234567891011121314151 对应的二进制是 -&gt; 1 最右边呢个1对应的10进制 -&gt; 12 对应的二进制是 -&gt; 10 最右边呢个1对应的10进制 -&gt; 23 对应的二进制是 -&gt; 11 最右边呢个1对应的10进制 -&gt; 14 对应的二进制是 -&gt; 100 最右边呢个1对应的10进制 -&gt; 45 对应的二进制是 -&gt; 101 最右边呢个1对应的10进制 -&gt; 16 对应的二进制是 -&gt; 110 最右边呢个1对应的10进制 -&gt; 2······lowbit(1) = 1lowbit(2) = 2lowbit(3) = 1lowbit(4) = 4lowbit(5) = 1lowbit(6) = 2······lowbit(x) = (x) &amp; (-x) 先感受一下这个lowbit有什么用： $-x$ 代表 $x$ 的负数，计算机中负数使用对应的正数的补码来表示。 例如： $x = 88_{(10)} = 1011000_{(2)} $ $-x = -88_{(10)} = (0100111_{(2)} + 1_{(2)}) = 101000_{(2)}$ $x &amp; (-x) = 1000_{(2)} = 8_{(10)}$ lowbit(x)代码实现： 1234inline int lowbit(int x)&#123; return x &amp; -x;&#125; 那么C[]如何求得？ 下面利用C[i]数组，求A数组中前i项的和 举个例子 $i=7$ sum[7]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7] C[4]=A[1]+A[2]+A[3]+A[4]; C[6]=A[5]+A[6]; C[7]=A[7]; 可以推出: sum[7]=C[4]+C[6]+C[7]; 序号写为二进制: sum[(111)]=C[(100)]+C[(110)]+C[(111)]; 再举个例子 $i=5$ sum[5]=A[1]+A[2]+A[3]+A[4]+A[5] C[4]=A[1]+A[2]+A[3]+A[4]; C[5]=A[5]; 可以推出: sum[5]=C[4]+C[5]; 序号写为二进制: sum[(101)]=C[(100)]+C[(101)]; 12345678C[1]=A[1];C[2]=A[1]+A[2];C[3]=A[3];C[4]=A[1]+A[2]+A[3]+A[4];C[5]=A[5];C[6]=A[5]+A[6];C[7]=A[7];C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]; 结论： lowbit(x) 的值为纵轴，x轴为A数组下标。$C[i] = A[i-lowbit(i)+1] + … + A[i]$ 后缀和更新代码： 123456789101112131415inline void init()&#123; for(int i = 1;i &lt;= n;++i) &#123; int w; cin &gt;&gt; w; add(i,w); &#125;&#125;inline void add(int x,int w)&#123; for(int i = x;i &lt;= n;i += lowbit(i)) c[i] += w;&#125; 求区间 $0 — x$ 的和代码： 123456789inline int getsum(int x)&#123; int ans = 0; for(int i = x;i &gt; 0;i -= lowbit(i)) &#123; ans += C[i]; &#125; return 0;&#125; 例2：https://www.luogu.org/problemnew/show/P2068代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;int C[1000100],N = 0,q = 0;int lowbit(int x)&#123; return x &amp; (-x);&#125;void add(int x,int k)&#123; while(x&lt;=N) &#123; C[x]+=k; x+=lowbit(x); &#125;&#125;inline long long sum(int x)&#123; long long ans = 0; for(;x;x-=lowbit(x)) &#123; ans += C[x]; &#125; return ans;&#125;int main(int argc, char const *argv[])&#123; cin &gt;&gt; N &gt;&gt; q; while(q--) &#123; char qwq; cin &gt;&gt; qwq; if(qwq == 'x') &#123; int x,y; cin &gt;&gt; x &gt;&gt; y; add(x,y); &#125; if(qwq == 'y') &#123; int x,y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; sum(y) - sum(x-1) &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://chicago01.top/categories/算法学习/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://chicago01.top/tags/数据结构/"}]},{"title":"原码反码补码","slug":"原码 反码 补码","date":"2019-01-27T14:05:24.000Z","updated":"2019-01-30T03:34:00.818Z","comments":true,"path":"2019/01/27/原码 反码 补码/","link":"","permalink":"http://chicago01.top/2019/01/27/原码 反码 补码/","excerpt":"有符号数据的表示符号：用0、1表示正、负号，放在数值的最高位小数点： 定点数：约定小数点隐含在某一位置上 浮点数：小数点可以任意浮动点可以任意浮动","text":"有符号数据的表示符号：用0、1表示正、负号，放在数值的最高位小数点： 定点数：约定小数点隐含在某一位置上 浮点数：小数点可以任意浮动点可以任意浮动 有符号数的表示在计算机中：有符号数可表示为原码、反码、补码。 原码：最高位表示数的符号，其它位表示数值 例：[+7]原=00000111B [-7]原=10000111B 反码： 正数的反码和原码相同。例：[+7]反=00000111B=[+7]原 负数的反码是由其原码的符号位不变，其余位按位取反。 例：[-7]反=11111000B 补码： 正数的补码和原码相同。例：[+7]补=00000111B=[+7]原 负数的补码是由其原码的符号位不变，其余位按位取反，再在最低位加1. 例：[-7]补=11111001B","categories":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://chicago01.top/categories/计算机科学/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://chicago01.top/tags/杂项/"}]},{"title":"回望2018，展望未来！","slug":"回望2018，展望未来！","date":"2019-01-24T16:00:00.000Z","updated":"2019-06-08T05:57:45.847Z","comments":true,"path":"2019/01/25/回望2018，展望未来！/","link":"","permalink":"http://chicago01.top/2019/01/25/回望2018，展望未来！/","excerpt":"回望2018，展望未来！感觉标题怪怪的。。。 有人在催我写年终总结催了一个月了，呢我还是写写吧，总结过去失败的经验，还是挺有必要的吧！","text":"回望2018，展望未来！感觉标题怪怪的。。。 有人在催我写年终总结催了一个月了，呢我还是写写吧，总结过去失败的经验，还是挺有必要的吧！ 2018年一月元旦三天假，我硬是休了五天假期，年前呢段时间太累了，正想着怎样多休息几天。然而不出意料犯了错误，三天假变一星期，无所谓了。 和爸妈买了去北京的往返火车票，31号早上到了北京，坐了一晚上硬座，一路上想了很多事情。期间也有后悔选择的硬座，后来想了想，这段硬座经历也是蛮让我成长的，真的让我看到了社会的阶级性。 我累了，坚持不住了，我可以去补张硬卧睡个好觉，可是呢些打工的人，没有坐，宁愿站上六七个小时，也不愿意多花一百块钱补个硬卧，穷啊，真实什么都能委屈自己。 二月意料之中的分班考试考到了重点班。内心感觉也是所谓的重点罢了。 其实高一上努力学习，是真的怕了，害怕自己真的再像中考呢样。 其实还有一个原因，现在说出来并不太好，每次吃饭都能看见她，痴迷了，但至今看来这都是不切实际的。 2019年6月8日：吾佳人所有，在水一方♥。 三月竞赛和文化课双双沦陷。平衡点被打破。 以前文化课学的轻松，很大一部分因素是因为老师在无限次数的重复，像个复读机一样，现在到了好班，拿着以前的套路，沦陷。 信息学竞赛学完了语法，之后不知路在何方。。。。 四月奶奶去世三周年，呢个夜晚，爸爸用奶奶爱看的烟花点亮了整个夜空。 刚回到学校，接到通知要求参加省选。。。 当时真的什么都不会，连省选是什么都不知道，连名额都是顶替别人的。 五月联考爆炸，省选爆炸，一晚上没睡，这是我上高中以来最难受的一段时间。几乎不想和任何人说话。 和一个以前对我很好的老师聊了天，他说，什么都别想，放手干就行了。 当时傻不懂，现在懂了。 月底高三毕业了，一个学姐送来很多东西，有零食，有药，有资料，挺感动的QwQ。 六月 &amp;&amp; 七月对这两个月讲真没什么记忆。 八月第一次参加信息学集训，洛谷夏令营，学了很多很多东西。认识很多大犇，才知道，原来信息学竞赛是多么的有意思，开阔了视野。 kkk老师的寄包柜、rxz老师的智障、还有呢zcy的打码速度、will爷的鸽子。 暑假过去，rxz老师去了哈工大，zcy失踪，will去了清北。。。 九月申请了停课搞竞赛，家里人都支持，可学校领导真是。。。 最后在老班的帮助下还是请下来长假了。 疯狂学习竞赛知识，不会的太多了，熬夜补，一两点睡觉都是日常了。。。 十月疯狂刷题，有时候一天能写十道竞赛题，接近李煜东学长速度了。 一个月刷够了200道题。 十一月奔赴考场，这次，我是正式选手了。 还是熟悉的呢群人。 Day1下午，wxh说去郑大转转吧，坐地铁到门口，说参观要从另一个校门进入，oh。。。。霉运到家的下起了雨，越来越大。。。。然后我们三个变成了落汤鸡。。。。 今年比赛霉运到家，Day1T2智障题，我竟然考场不看，去看T3。活该与二等奖擦肩而过。。。整整100分给扔掉了。。。 十二月回到学校学习文化课。。。 还行吧，比竞赛简单多了。。。 降维打击。。。 想退役都没办法，只能今年再打一次比赛了。 2018我的洛谷 2018总结这一整年，真是活到哪里就活到哪里，没有任何的计划，碌碌无为，一事无成。为了解决这样的事情重现，2019年要制定计划。 学习竞赛的经历让我成长很多，认识了很多清北的学长，年末在他们的指导下，走了很少的弯路，感谢你们。 展望未来2019上半年上半年要在文化课上下大功夫，因为下半年还要为竞赛奋斗，一轮复习只能比别人提前半个学期。累就累点吧，闲着也是闲着，无聊。 未来五年仔细想想还是需要长远规划，宏观调控的，不然一年年就这样过去了，碌碌无为，一事无成。 end.","categories":[{"name":"心路成长","slug":"心路成长","permalink":"http://chicago01.top/categories/心路成长/"}],"tags":[{"name":"游记","slug":"游记","permalink":"http://chicago01.top/tags/游记/"}]},{"title":"题解 P1312 【Mayan游戏】","slug":"题解 P1312 【Mayan游戏】","date":"2018-11-06T16:00:00.000Z","updated":"2019-01-25T10:19:07.477Z","comments":true,"path":"2018/11/07/题解 P1312 【Mayan游戏】/","link":"","permalink":"http://chicago01.top/2018/11/07/题解 P1312 【Mayan游戏】/","excerpt":"题解 P1312 【Mayan游戏】题面过长已遮挡 题意体面已经陈述题意（这题没有考语文阅读理解） 题解* 我还记得我曾经给自己找的锅，给某些人讲课的时候说过一句话：体面越长的题，越简单。** *这句话没有错，我会用接下来解决这道题的思路过程，来证明这句话。 首先我们知道存在这么几种操作： a. 交换操作 b. 下沉操作 c. 消除操作 d. 搜索操作 e. 玩完判断 f. 拷贝操作（回溯） 这时候可以看得出来这里面除了搜索操作，剩余的操作都是模拟，我们只需要分出多个函数进行模拟就好了。 但是思路就是如此简单的一道题我却调了一个下午。（代码量是真的大，不压横150+行代码），还是我太菜了。 因为数据量非常小，不用怎么优化也能过，但是写代码的时候一定要小心。","text":"题解 P1312 【Mayan游戏】题面过长已遮挡 题意体面已经陈述题意（这题没有考语文阅读理解） 题解* 我还记得我曾经给自己找的锅，给某些人讲课的时候说过一句话：体面越长的题，越简单。** *这句话没有错，我会用接下来解决这道题的思路过程，来证明这句话。 首先我们知道存在这么几种操作： a. 交换操作 b. 下沉操作 c. 消除操作 d. 搜索操作 e. 玩完判断 f. 拷贝操作（回溯） 这时候可以看得出来这里面除了搜索操作，剩余的操作都是模拟，我们只需要分出多个函数进行模拟就好了。 但是思路就是如此简单的一道题我却调了一个下午。（代码量是真的大，不压横150+行代码），还是我太菜了。 因为数据量非常小，不用怎么优化也能过，但是写代码的时候一定要小心。 下沉操作每次交换完 or 消除完都要进行的操作。 遍历图上的每一个点，如果有颜色，判断下面是否还有颜色 没有颜色：立一个$flag$，向下一直找到呢个有颜色的点，然后利用$flag$下沉到有显色点的上方。 有颜色：跳出当前列。 1234567891011121314151617void update()&#123; for(int i = 1;i &lt;= 5;++i) &#123; int flag = 0; for(int j = 1;j &lt;= 7;++j) &#123; if(!mapp[i][j]) flag++; else &#123; if(!flag) continue; mapp[i][j - flag] = mapp[i][j]; mapp[i][j] = 0; &#125; &#125; &#125;&#125; 消除操作每次下沉完都要进行的操作。根据题意会有三种情况：只有横着的三个；只有竖着的三个；横着三个交叉在竖着三个之间；横着三个和竖着三个同时出现但不相交。 但是我们可以把它们归纳到一种情况，就是只要有三个连续相同的出现就加到桶里面，然后再把桶扫一遍，全部染回没有颜色，这样就消除了。 这里呢还可以加一个小优化，立一个$flag$。因为根据题意，消除完还要进行下沉操作，但是如果我们没有可消除，就浪费了下沉的一些时间。 代码操作非常简单，只要根据上面的分析进行模拟就好了。 123456789101112131415161718192021222324252627282930313233343536bool reover()&#123; bool flag = 1; for(int i = 1;i &lt;= 5;++i) for(int j = 1;j &lt;= 7;++j) &#123; if(i-1 &gt;= 1 &amp;&amp; i+1 &lt;= 5 &amp;&amp; mapp[i][j] &amp;&amp; mapp[i][j] == mapp[i-1][j] &amp;&amp; mapp[i][j] == mapp[i+1][j]) &#123; tong[i][j] = 1; tong[i-1][j] = 1; tong[i+1][j] = 1; flag = 0; &#125; if(j-1 &gt;= 1 &amp;&amp; j+1 &lt;= 7 &amp;&amp; mapp[i][j] &amp;&amp; mapp[i][j] == mapp[i][j-1] &amp;&amp; mapp[i][j] == mapp[i][j+1]) &#123; tong[i][j] = 1; tong[i][j-1] = 1; tong[i][j+1] = 1; flag = 0; &#125; &#125; if(flag) return 0; for(int i = 1;i &lt;= 5;++i) for(int j = 1;j &lt;= 7;++j) &#123; if(tong[i][j]) &#123; mapp[i][j] = 0; tong[i][j] = 0; &#125; &#125; return 1;&#125; 交换操作根据题意可得，交换的流程是这样的： 交换两个点颜色 -&gt; 下沉操作 -&gt; 消除操作 -&gt; 下沉操作 -&gt; 消除操作 一直到不能再消除，交换结束。 123456void move(int i,int j,int flag)&#123; swap(mapp[i][j],mapp[i+flag][j]); update(); while(reover()) update();&#125; 玩完判断只需要扫描最后一层，如果还有颜色，肯定是没有玩完。 1234567bool gameover()&#123; for(int i = 1;i &lt;= 5;++i) if(mapp[i][1]) return 0; return 1;&#125; 拷贝操作（回溯）留一个备份是为了方便我们搜索完一轮后，返回时恢复初值。 代码非常的简单容易理解。 123456void move(int i,int j,int flag)&#123; swap(mapp[i][j],mapp[i+flag][j]); update(); while(reover()) update();&#125; 搜索操作这一块是最容易出错的，但是细心一些还是能过得，毕竟这个搜索也不需要优化。 如果已经玩完了，直接输出答案，结束程序。 如果搜索长度大于等于n了，不用再往后面搜了。 留一个备份，方便一会回溯。 1和2都不成立，就继续搜。分两种情况，左搜和右搜。 a. 左搜：首先左边界肯定要大于等于1，左边的方块还没有颜色。 b. 右搜：首先右边界肯定要小于等于5，相邻两颜色还不能相同。 搜完一定要记得回溯 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void dfs(int x)&#123; if(gameover()) &#123; for(int i = 1;i &lt;= n;++i) &#123; if(i != 1) cout &lt;&lt; endl; cout &lt;&lt; ans[i][1] &lt;&lt;\" \"&lt;&lt; ans[i][2] &lt;&lt;\" \"&lt;&lt; ans[i][3]; &#125; exit(0); &#125; if(x == n+1) return; copy(x); for(int i = 1;i &lt;= 5;++i) for(int j = 1;j &lt;= 7;++j) &#123; if(mapp[i][j]) &#123; if(i-1 &gt;= 1 &amp;&amp; mapp[i-1][j] == 0) &#123; move(i,j,-1); ans[x][1] = i-1; ans[x][2] = j-1; ans[x][3] = -1; dfs(x+1); for(int i = 1;i &lt;= 5;++i) for(int j = 1;j &lt;= 7;++j) mapp[i][j] = last[x][i][j]; ans[x][1] = 0; ans[x][2] = 0; ans[x][3] = 0; &#125; if(i+1 &lt;= 5 &amp;&amp; mapp[i][j] != mapp[i+1][j]) &#123; move(i,j,1); ans[x][1] = i-1; ans[x][2] = j-1; ans[x][3] = 1; dfs(x+1); for(int i = 1;i &lt;= 5;++i) for(int j = 1;j &lt;= 7;++j) mapp[i][j] = last[x][i][j]; ans[x][1] = 0; ans[x][2] = 0; ans[x][3] = 0; &#125; &#125; &#125;&#125; 代码这道题的代码挺考察耐心的，我调了两个小时才调出来AC100分的结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;bits/stdc++.h&gt;using namespace std;#define il inlineint n;int mapp[10][10],ans[10][10],last[10][10][10],tong[10][10];il int read()&#123; int X=0,w=0; char ch=0; while(!isdigit(ch)) &#123;w|=ch=='-';ch=getchar();&#125; while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); return w?-X:X;&#125;il bool reover()&#123; bool flag = 1; for(int i = 1;i &lt;= 5;++i) for(int j = 1;j &lt;= 7;++j) &#123; if(i-1 &gt;= 1 &amp;&amp; i+1 &lt;= 5 &amp;&amp; mapp[i][j] &amp;&amp; mapp[i][j] == mapp[i-1][j] &amp;&amp; mapp[i][j] == mapp[i+1][j]) &#123; tong[i][j] = 1; tong[i-1][j] = 1; tong[i+1][j] = 1; flag = 0; &#125; if(j-1 &gt;= 1 &amp;&amp; j+1 &lt;= 7 &amp;&amp; mapp[i][j] &amp;&amp; mapp[i][j] == mapp[i][j-1] &amp;&amp; mapp[i][j] == mapp[i][j+1]) &#123; tong[i][j] = 1; tong[i][j-1] = 1; tong[i][j+1] = 1; flag = 0; &#125; &#125; if(flag) return 0; for(int i = 1;i &lt;= 5;++i) for(int j = 1;j &lt;= 7;++j) &#123; if(tong[i][j]) &#123; mapp[i][j] = 0; tong[i][j] = 0; &#125; &#125; return 1;&#125;il bool gameover()&#123; for(int i = 1;i &lt;= 5;++i) if(mapp[i][1]) return 0; return 1;&#125;il void copy (int x)&#123; for(int i = 1;i &lt;= 5;++i) for(int j = 1;j &lt;= 7;++j) &#123; last[x][i][j] = mapp[i][j]; &#125;&#125;il void update()&#123; for(int i = 1;i &lt;= 5;++i) &#123; int flag = 0; for(int j = 1;j &lt;= 7;++j) &#123; if(!mapp[i][j]) flag++; else &#123; if(!flag) continue; mapp[i][j - flag] = mapp[i][j]; mapp[i][j] = 0; &#125; &#125; &#125;&#125;il void move(int i,int j,int flag)&#123; swap(mapp[i][j],mapp[i+flag][j]); update(); while(reover()) update();&#125;void dfs(int x)&#123; if(gameover()) &#123; for(int i = 1;i &lt;= n;++i) &#123; if(i != 1) cout &lt;&lt; endl; cout &lt;&lt; ans[i][1] &lt;&lt;\" \"&lt;&lt; ans[i][2] &lt;&lt;\" \"&lt;&lt; ans[i][3]; &#125; exit(0); &#125; if(x == n+1) return; copy(x); for(int i = 1;i &lt;= 5;++i) for(int j = 1;j &lt;= 7;++j) &#123; if(mapp[i][j]) &#123; if(i-1 &gt;= 1 &amp;&amp; mapp[i-1][j] == 0) &#123; move(i,j,-1); ans[x][1] = i-1; ans[x][2] = j-1; ans[x][3] = -1; dfs(x+1); for(int i = 1;i &lt;= 5;++i) for(int j = 1;j &lt;= 7;++j) mapp[i][j] = last[x][i][j]; ans[x][1] = 0; ans[x][2] = 0; ans[x][3] = 0; &#125; if(i+1 &lt;= 5 &amp;&amp; mapp[i][j] != mapp[i+1][j]) &#123; move(i,j,1); ans[x][1] = i-1; ans[x][2] = j-1; ans[x][3] = 1; dfs(x+1); for(int i = 1;i &lt;= 5;++i) for(int j = 1;j &lt;= 7;++j) mapp[i][j] = last[x][i][j]; ans[x][1] = 0; ans[x][2] = 0; ans[x][3] = 0; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; n = read(); for(int i = 1;i &lt;= 5;++i) for(int j = 1;j &lt;= 8;++j) &#123; int x = read(); if(x == 0) break; mapp[i][j] = x; &#125; dfs(1); printf(\"-1\\n\"); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://chicago01.top/categories/题解/"}],"tags":[{"name":"DFS剪枝","slug":"DFS剪枝","permalink":"http://chicago01.top/tags/DFS剪枝/"}]},{"title":"题解 P1550 【[USACO08OCT]打井Watering Hole】","slug":"题解 P1550 【[USACO08OCT]打井Watering Hole】","date":"2018-11-06T16:00:00.000Z","updated":"2019-01-25T10:09:13.183Z","comments":true,"path":"2018/11/07/题解 P1550 【[USACO08OCT]打井Watering Hole】/","link":"","permalink":"http://chicago01.top/2018/11/07/题解 P1550 【[USACO08OCT]打井Watering Hole】/","excerpt":"题解 P1550 【[USACO08OCT]打井Watering Hole】题面（翻译有点问题，最后一句话）农民John 决定将水引入到他的n(1&lt;=n&lt;=300)个牧场。他准备通过挖若干井，并在各块田中修筑水道来连通各块田地以供水。在第i 号田中挖一口井需要花费W_i(1&lt;=W_i&lt;=100,000)元。连接i 号田与j 号田需要P_ij (1 &lt;= P_ij &lt;= 100,000 , P_ji=P_ij)元。","text":"题解 P1550 【[USACO08OCT]打井Watering Hole】题面（翻译有点问题，最后一句话）农民John 决定将水引入到他的n(1&lt;=n&lt;=300)个牧场。他准备通过挖若干井，并在各块田中修筑水道来连通各块田地以供水。在第i 号田中挖一口井需要花费W_i(1&lt;=W_i&lt;=100,000)元。连接i 号田与j 号田需要P_ij (1 &lt;= P_ij &lt;= 100,000 , P_ji=P_ij)元。 请求出农民John 需要为使所有农场都与有水的农场相连或拥有水井所需要的钱数。 题意有n个点，每个点之间都有边权，但是每个点也有点权。 要求算出每个点都连通的情况下（但是不要求每个点的点权都算上），最小价值。 题解这题很容易想到最小生成树，但是又有好多人不敢下手去写最小生成树，因为这里的每个点还有点权。 我们可以转换一下思路，把每个点的点权当成一个指向自己的边权，然后构造一棵最小生成树就好了！ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;const int maxx = 1e3+10;int n,cnt = 0,fa[maxx*maxx];struct edge&#123; int u,v,w; bool operator &lt; (const edge &amp;qwq) &#123; return w &lt; qwq.w; &#125;&#125;G[maxx*maxx];inline void init()&#123; cin &gt;&gt; n; for(int i = 1;i &lt;= n;++i) &#123; int w; cin &gt;&gt; w; G[++cnt].u = 0; G[cnt].v = i; G[cnt].w = w; &#125; for(int i = 1;i &lt;= n;++i) &#123; for(int j = 1;j &lt;= n;++j) &#123; int w; cin &gt;&gt; w; if(i &gt; j) &#123; G[++cnt].u = i; G[cnt].v = j; G[cnt].w = w; &#125; &#125; &#125; for(int i = 1;i &lt;= cnt;++i) fa[i] = i;&#125; inline int fin(int x)&#123; return fa[x] == x ? x : fa[x] = fin(fa[x]);&#125;inline int kul()&#123; sort(G+1,G+cnt+1); int ans = 0,qwq = 0; for(int i = 1;i &lt;= cnt;++i) &#123; int x = fin(G[i].u),y = fin(G[i].v); if(x != y) &#123; fa[x] = y; ++qwq; ans += G[i].w; &#125; if(qwq == n) break; &#125; return ans;&#125;int main(int argc, char const *argv[])&#123; init(); cout &lt;&lt; kul(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://chicago01.top/categories/题解/"}],"tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"http://chicago01.top/tags/最小生成树/"}]},{"title":"题解 P2920 【[USACO08NOV]时间管理Time Management】","slug":"题解 P2920 【[USACO08NOV]时间管理Time Management】","date":"2018-11-06T16:00:00.000Z","updated":"2019-03-12T11:17:23.795Z","comments":true,"path":"2018/11/07/题解 P2920 【[USACO08NOV]时间管理Time Management】/","link":"","permalink":"http://chicago01.top/2018/11/07/题解 P2920 【[USACO08NOV]时间管理Time Management】/","excerpt":"题面作为一名忙碌的商人，约翰知道必须高效地安排他的时间.他有N工作要 做，比如给奶牛挤奶，清洗牛棚，修理栅栏之类的. 为了高效，列出了所有工作的清单.第i分工作需要T_i单位的时间来完成，而 且必须在S_i或之前完成.现在是0时刻.约翰做一份工作必须直到做完才能停 止. 所有的商人都喜欢睡懒觉.请帮约翰计算他最迟什么时候开始工作，可以让所有工作按时完成.（如果无法完成全部任务，输出-1）","text":"题面作为一名忙碌的商人，约翰知道必须高效地安排他的时间.他有N工作要 做，比如给奶牛挤奶，清洗牛棚，修理栅栏之类的. 为了高效，列出了所有工作的清单.第i分工作需要T_i单位的时间来完成，而 且必须在S_i或之前完成.现在是0时刻.约翰做一份工作必须直到做完才能停 止. 所有的商人都喜欢睡懒觉.请帮约翰计算他最迟什么时候开始工作，可以让所有工作按时完成.（如果无法完成全部任务，输出-1） 题意有一个人有N项工作，给N组数据，每组数据有Ti和Si，分别表示第i组工作需要花费的时间和最晚完成的时间。 初始时间为0，要求算出最晚可以什么时间开始工作。 题解50分操作 (有BUG 不严谨证明)由题意可以知道这道题可以尝试以下模拟操作。 排序每一项最晚完成的时间。 枚举，如果前i项任务完成时间超过第i项任务花费的时间，就非法，输出-1。 统计出每一项任务 最晚完成时间 - 花费时间的值。 排序输出最小的统计值。 （不完全归纳法得出3、4操作，不严谨证明） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;int n = 0,tong[1010];struct edge&#123; int t,s; bool operator &lt; (const edge &amp;qxq) &#123; return s &lt; qxq.s; &#125;&#125;num[1010];int main(int argc, char const *argv[])&#123; cin &gt;&gt; n; for(int i = 1;i &lt;= n;i++) &#123; cin &gt;&gt; num[i].t &gt;&gt; num[i].s; if(num[i].t &gt; num[i].s) &#123; cout &lt;&lt; -1; return 0; &#125; tong[i] = num[i].s - num[i].t; &#125; sort(num+1,num+n+1); sort(tong+1,tong+n+1); long long sum = 0; for(int i = 1;i &lt;= n;i++) &#123; sum += num[i].t; if(sum &gt; num[i].s) &#123; cout &lt;&lt; -1; return 0; &#125; &#125; cout &lt;&lt; tong[1]; return 0;&#125; 满分做法 AC100建立在50分的操作上进行严谨的贪心证明。 排序每一项最晚完成的时间。 得出最晚完成的时间，并用一个中间变量存储。 枚举，用中间变量减去每一项所要花费的时间。 对结果进行判断，如果中间变量小于0，非法，输出-1；否则中间变量剩余的时间就是答案，也就是商人最晚起床时间。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int n = 0;struct edge&#123; int t,s; bool operator &lt; (const edge &amp;qxq) &#123; return s &gt; qxq.s; &#125;&#125;num[1010];int main(int argc, char const *argv[])&#123; cin &gt;&gt; n; for(int i = 1;i &lt;= n;i++) &#123; cin &gt;&gt; num[i].t &gt;&gt; num[i].s; &#125; sort(num+1,num+n+1); int ans = num[1].s; for(int i = 1;i &lt;= n;i++) &#123; if(ans &lt;= num[i].s) ans -= num[i].t; else ans = num[i].s - num[i].t; &#125; if(ans &lt; 0) cout &lt;&lt; \"-1\"; else cout &lt;&lt; ans; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://chicago01.top/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://chicago01.top/tags/贪心/"}]},{"title":"题解 P2701 【[USACO5.3]巨大的牛棚Big Barn】","slug":"题解 P2701 【[USACO5.3]巨大的牛棚Big Barn】","date":"2018-11-06T16:00:00.000Z","updated":"2019-01-25T10:19:33.479Z","comments":true,"path":"2018/11/07/题解 P2701 【[USACO5.3]巨大的牛棚Big Barn】/","link":"","permalink":"http://chicago01.top/2018/11/07/题解 P2701 【[USACO5.3]巨大的牛棚Big Barn】/","excerpt":"题解 P2701 【[USACO5.3]巨大的牛棚Big Barn】题面农夫约翰想要在他的正方形农场上建造一座正方形大牛棚。 他讨厌在他的农场中砍树，想找一个能够让他在空旷无树的地方修建牛棚的地方。 我们假定，他的农场划分成 N x N 的方格。输入数据中包括有树的方格的列表。你的任务是计算并输出，在他的农场中，不需要砍树却能够修建的最大正方形牛棚。 牛棚的边必须和水平轴或者垂直轴平行。","text":"题解 P2701 【[USACO5.3]巨大的牛棚Big Barn】题面农夫约翰想要在他的正方形农场上建造一座正方形大牛棚。 他讨厌在他的农场中砍树，想找一个能够让他在空旷无树的地方修建牛棚的地方。 我们假定，他的农场划分成 N x N 的方格。输入数据中包括有树的方格的列表。你的任务是计算并输出，在他的农场中，不需要砍树却能够修建的最大正方形牛棚。 牛棚的边必须和水平轴或者垂直轴平行。 题意给你一个图，要求找出图中符合规则的最大正方形。 题意同： P1387 最大正方形 题解这是一道非常经典的矩阵（二维）动态规划，还有一道相似的题目： P1508 Likecloud-吃、吃、吃(学会一道题，然后三倍经验😀) 遇到矩阵（二维）动态规划的题目，常规的思路就是手动构造-&gt;找状态转移方程。 非常规的思路就是：”这题我做个类似的，这个状态转移方程我知道!” 首先画一个图，这是一个原始的图。 0 1 1 0 1 1 1 1 1 0 0 1 1 1 0 1 1 1 1 0 0 1 1 0 1 然后构造出每一个点的最大正方形边长。 0 1 1 0 1 1 1 2 1 0 0 1 2 2 0 1 1 2 3 0 0 1 2 0 1 由下图和上图可推出状态转移方程 ： $ dp[i][j] = min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1 $ 最后只需要找出整个图中最大的点就行了。 代码动态规划的题目的代码都非常的简单。 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,mapp[1010][1010];int dp[1010][1010];int main(int argc, char const *argv[])&#123; cin &gt;&gt; n &gt;&gt; m; memset(mapp,1,sizeof(mapp)); for(int i = 1;i &lt;= m;++i) &#123; int x,y; cin &gt;&gt; x &gt;&gt; y; mapp[x][y] = 0; &#125; int maxx = -1; for(int i = 1;i &lt;= n;++i) &#123; for(int j = 1;j &lt;= n;++j) &#123; if(mapp[i][j]) &#123; dp[i][j] = min(min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1])+1; &#125; maxx = max(maxx,dp[i][j]); &#125; &#125; cout &lt;&lt; maxx; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://chicago01.top/categories/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://chicago01.top/tags/动态规划/"}]},{"title":"题解 P1120 【小木棍 ［数据加强版］】","slug":"题解 P1120 【小木棍 ［数据加强版］】","date":"2018-11-06T16:00:00.000Z","updated":"2019-01-25T10:19:22.733Z","comments":true,"path":"2018/11/07/题解 P1120 【小木棍 ［数据加强版］】/","link":"","permalink":"http://chicago01.top/2018/11/07/题解 P1120 【小木棍 ［数据加强版］】/","excerpt":"题解 P1120 【小木棍 ［数据加强版］】题面乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过50。 现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。 给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。 题意有n段同样长的木棍，现在将这n段木棍随意分段（保证每段长度不超过50）。乔治比较闲，又想把它拼回原始木棍，但是又比较智障，忘了原来有多少根，长度是多少。 给出每段的长度，求出木棍最小可能长度。（使n尽量大，又要保证每段都拼上） 题解题目看上去很简单，也很好想到这是一个搜索题，但是拿到后非常难以无法下手，数据的加强非常容易使这题超时。这是一道剪枝的经典题目","text":"题解 P1120 【小木棍 ［数据加强版］】题面乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过50。 现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。 给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。 题意有n段同样长的木棍，现在将这n段木棍随意分段（保证每段长度不超过50）。乔治比较闲，又想把它拼回原始木棍，但是又比较智障，忘了原来有多少根，长度是多少。 给出每段的长度，求出木棍最小可能长度。（使n尽量大，又要保证每段都拼上） 题解题目看上去很简单，也很好想到这是一个搜索题，但是拿到后非常难以无法下手，数据的加强非常容易使这题超时。这是一道剪枝的经典题目 从最优性方面分析，可以做以下两种剪枝： 设所有木棍的长度和是sum，那么原长度（也就是需要输出的长度）一定能够被sum整除，不然就没法拼了，即一定要拼出整数根。 木棍原来的长度一定大于等于所有木棍中最长的那根。 综合上述两点，可以确定原木棍的长度len在最长木棍的长度与sum之间，且sum能被len整除。 所以，在搜索原木棍的长度时，可以设定为从截断后所有木棍中最长的长度开始，每次增加长度后，必须能整除sum。这样可以有效地优化程序。 从可行性方面分析，可以再做以下七种剪枝： 一根长木棍肯定比几根短木棍拼成同样长度的用处小，即短小的可以更灵活组合，所以可以对输入的所有木棍按长度从大到小排序。 在截断后的排好序的木棍中，当用木棍i拼合原始木棍时，可以从第i+1后的木棍开始搜。因为根据优化（1），i前面的木棍已经用过了。 用当前最长长度的木棍开始搜，如果拼不出当前设定的原木棍长度len，则直接返回，换一个原始木棍长度len。 相同长度的木棍不要搜索多次。用当前长度的木棍搜下去得不出结果时，用一支同样长度的还是得不到结果，所以，可以提前返回。 判断搜到的几根木棍组成的长度是否大于原始长度len，如果大于，没必要搜下去，可以提前返回。 判断当前剩下的木棍根数是否够拼成木棍，如果不够，肯定拼合不成功，直接返回。 找到结果后，在能返回的地方马上返回到上一层的递归处。 代码这道题的思想不仅不简单，对代码能力也是一种考验。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;const int maxx = 66;int n,maxn = -maxx,minn = maxx;int tong[maxx];void dfs( int res , int sum , int target , int p ) &#123; if( res == 0 ) &#123; printf(\"%d\", target ); exit( 0 ); &#125; if( sum == target ) &#123; dfs( res - 1 , 0 , target , maxn ); return; &#125; for( int i = p ; i &gt;= minn ; i -- ) &#123; if( tong[ i ] &amp;&amp; i + sum &lt;= target ) &#123; tong[ i ] -- ; dfs( res , sum + i , target , i ); tong[ i ] ++ ; if ( sum == 0 || sum + i == target); break; &#125; &#125; return;&#125;int main(int argc, char const *argv[])&#123; scanf(\"%d\",&amp;n); int x,cnt = 0,sum; while(n--) &#123; scanf(\"%d\",&amp;x); if(x &lt;= 50) &#123; cnt++; tong[x]++; sum += x; maxn = max(maxn,x); minn = min(minn,x); &#125; &#125; x = sum/2; for(int i = maxn;i &lt;= x;i++) &#123; if(sum%i == 0) &#123; dfs(sum/i,0,i,maxn); &#125; &#125; printf(\"%d\",sum); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://chicago01.top/categories/题解/"}],"tags":[{"name":"DFS剪枝","slug":"DFS剪枝","permalink":"http://chicago01.top/tags/DFS剪枝/"}]}]}